---
title: LC-2536.子矩阵元素加1
date: 2023-01-17 01:54:09
tags:
- 差分/二维差分
- TODO
---

## 题目描述
[leetcode 中等题](https://leetcode.cn/problems/increment-submatrices-by-one/)

给你一个正整数 n ，表示最初有一个 n x n 、下标从 0 开始的整数矩阵 mat ，矩阵中填满了 0 。

另给你一个二维整数数组 query 。针对每个查询 query[i] = [row1i, col1i, row2i, col2i] ，请你执行下述操作：

找出 左上角 为 (row1i, col1i) 且 右下角 为 (row2i, col2i) 的子矩阵，将子矩阵中的 每个元素 加 1 。也就是给所有满足 row1i <= x <= row2i 和 col1i <= y <= col2i 的 mat[x][y] 加 1 。
返回执行完所有操作后得到的矩阵 mat 。

![](../img/Snipaste_2023-01-17_01-55-33.png)

示例1：
```
输入：n = 3, queries = [[1,1,2,2],[0,0,1,1]]
输出：[[1,1,0],[1,2,1],[0,1,1]]
解释：上图所展示的分别是：初始矩阵、执行完第一个操作后的矩阵、执行完第二个操作后的矩阵。
- 第一个操作：将左上角为 (1, 1) 且右下角为 (2, 2) 的子矩阵中的每个元素加 1 。 
- 第二个操作：将左上角为 (0, 0) 且右下角为 (1, 1) 的子矩阵中的每个元素加 1 。 
```

提示1：
```
1 <= n <= 500
1 <= queries.length <= 104
0 <= row1i <= row2i < n
0 <= col1i <= col2i < n
```
## 数据规模分析
## n次一维差分
```Java
class Solution {
    public int[][] rangeAddQueries(int n, int[][] queries) {
        int[][] a = new int[n][n];
        for(int[] item : queries){
            // [row1i, col1i, row2i, col2i]
            for(int i = item[0]; i <= item[2]; i++){
                a[i][item[1]]++;
                if(item[3] + 1 < n)/*  */{
                    a[i][item[3] + 1]--;
                } 
            }
        }
        for(int i = 0; i < n; i++){
            for(int j = 1; j < n; j++){
                a[i][j] += a[i][j - 1];
            }
        }
        return a;
    }
}
```
## 二维差分