---
title: 字符串哈希
date: 2022-11-03 21:55:00
tags: 字符串
---

>参考：
[OI-WIKI-# 字符串哈希](https://oi-wiki.org/string/hash/)
[宫水三叶-# 字符串哈希入门](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247489813&idx=1&sn=7f3bc18ca390d85b17655f7164d8e660)
[Leetcode-187重复的 DNA 序列](https://leetcode.cn/problems/repeated-dna-sequences/)
## 性质
具体来说，哈希函数最重要的性质可以概括为下面两条：

1.  在 Hash 函数值不一样的时候，两个字符串一定不一样；
    
2.  在 Hash 函数值一样的时候，两个字符串不一定一样（哈希冲突/碰撞。但大概率一样，且我们当然希望它们总是一样的）。

## 哈希函数

我们需要关注的是什么？

时间复杂度和 Hash 的准确率。

通常我们采用的是**多项式 Hash**的方法，对于一个长度为 L 的字符串 s 来说，我们可以这样定义多项式 Hash 函数：

![](/img/20221001012815.png)

这种情况下，对于字符串 xyz ，其哈希函数值为 xb^2 + yb + z。

对于该 Hash 函数的参考实现如下(（效率低下的版本，实际使用时一般不会这么写）)
```C++
using std::string;

const int M = 1e9 + 7; 
const int B = 233; 

typedef long long ll; 


int get_hash(const string& s) { 
	int res = 0; 
	for (int i = 0; i < s.size(); ++i) { 
		res = (ll)(res * B + s[i]) % M; 
	} 
	return res; 
} 

bool cmp(const string& s, const string& t) { 
	return get_hash(s) == get_hash(t); 
}
```

## 多次询问子串哈希

单次计算一个字符串的哈希值复杂度是 O(n)，其中 n 为串长，与暴力匹配没有区别，如果需要多次询问一个字符串的子串的哈希值，每次重新计算效率会非常低下。

一般采取的方法是对整个字符串先 **预处理出每个前缀的哈希值(设该数组为H)** ，将哈希值看成一个 b 进制的数对 m 取模的结果，这样的话可以做到快速求出子串的哈希。

首先对于F(s[1, i]) ，即原串长度为 i 的前缀（即子串s[1, i]）的哈希值 **(即H[i])** ，按照定义为

**F(s[1, i])  = s[1] * b^ (i - 1) + s[2] * b ^ (i - 2) + ... + s[i - 1] * b +s[i]** 

现在，我们想要用类似前缀和的方式快速求出子串 s[L, R] 的哈希值即 F(s[L, R])，按照定义哈希值为

**F(s[L, R])  = s[L] * b^ (R - L) + s[L + 1] * b ^ (R - L - 1) + ... + s[R - 1] * b +s[R]**

对比观察上述两个式子，可以发现 `式2` 其实可以由 `式1` 得出，即
**F(s[L, R])  = F(s[1, R]) - F(s[1, L-1]) * b ^ (r - L + 1)** 

那么即字串 S[L, R] 的哈希值等于 H[R] - H[L-1] * B ^ (R - L +1)

而 B ^ (r - L + 1)  又可以通过 O(n) 的预处理出次方数组，以实现 O(1) 的回答每次询问

实现，[Leetcode187](https://leetcode.cn/problems/repeated-dna-sequences/):
```Java
public class Hash {  
    private static final int B = 131313;  
    private static final int M = (int)1e5 + 10;  
    private static final int[] POWER = new int[M]; // 次方数组  
  
    public List<String> findRepeatedDnaSequences(String s) {  
        int[] hashTable = new int[s.length() + 1];  
        POWER[0] = 1;  
        for(int i = 1; i <= s.length(); i++){  
            // 预处理前缀哈希数组  
            hashTable[i] = hashTable[i - 1] * B + s.charAt(i - 1) % M;  
            // 预处理次方数组
            POWER[i] = POWER[i - 1] * B;  
        }  
        Map<Integer, Integer> countMap = new HashMap<>();  
        List<String> ans = new ArrayList<>();  
        for(int i = 0; i < s.length() - 10 + 1; i++){  
            // 子串哈希等于 h(r) - h(l - 1) * b ^ (r - l + 1)            
            int hash = hashTable[i + 9 + 1] - hashTable[i] * POWER[i + 9 - i + 1];  
            int count = countMap.merge(hash, 0, (oldValue, __) -> ++oldValue);  
            if(count == 1){  
                ans.add(s.substring(i, i + 10));  
            }  
        }  
        return ans;  
    }  
  
}
```