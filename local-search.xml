<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LC-464.我能赢吗</title>
    <link href="/2022/11/03/LC-464-%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97/"/>
    <url>/2022/11/03/LC-464-%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/can-i-win/submissions/">leetcode 中等题</a></p><p>两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过  100 的玩家，即为胜者。</p><p>两位玩家不能使用重复的整数 </p><p>给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家是否能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。</p><p>示例 1:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：maxChoosableInteger = 10, desiredTotal = 11<br>输出：false<br>解释：<br>无论第一个玩家选择哪个整数，他都会失败。<br>第一个玩家可以选择从<span class="hljs-number"> 1 </span>到<span class="hljs-number"> 10 </span>的整数。<br>如果第一个玩家选择 1，那么第二个玩家只能选择从<span class="hljs-number"> 2 </span>到<span class="hljs-number"> 10 </span>的整数。<br>第二个玩家可以通过选择整数 10（那么累积和为<span class="hljs-number"> 11 </span>&gt;= desiredTotal），从而取得胜利.<br>同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">maxChoosableInteger</span> = <span class="hljs-number">10</span>, <span class="hljs-attr">desiredTotal</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">maxChoosableInteger</span> = <span class="hljs-number">10</span>, <span class="hljs-attr">desiredTotal</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= maxChoosableInteger &lt;= <span class="hljs-number">20</span><br><span class="hljs-symbol">0 </span>&lt;= desiredTotal &lt;= <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><h2 id="递归-TLE"><a href="#递归-TLE" class="headerlink" title="递归 (TLE)"></a>递归 (TLE)</h2><p>最无脑的做法是直接递归, 用一个 <code>List</code> 来模拟选数的情况，每次选走一个数时 <code>remove</code> 掉对应元素即可，但同时因为要找到最优决策，所以不能改变原集合，只能改变拷贝的 <code>List</code>（如果直接对原集合 <code>remove</code> ，递归结束后不好还原，重新 <code>add</code> 会添加到集合末尾，那整个 for 循环遍历集合就不正确了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canIWin</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> dest)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(IntStream.rangeClosed(<span class="hljs-number">1</span>, n).boxed().collect(Collectors.toList()), dest);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; list, <span class="hljs-type">int</span> dest)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-keyword">if</span>(item &gt;= dest)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            List&lt;Integer&gt; copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list);<br>            copy.remove(i);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> dfs(copy, dest - item);<br>            <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>上面方案有问题的地方在于直接使用了 <code>List</code> 模拟选数过程，而整个递归过程是存在很多重复计算的，使用 <code>List</code> 无法进行记忆化搜索。</p><p>所以容易发现从一开始使用 <code>List</code> 就是一个 <strong>错误的思路</strong> 。</p><p>由于 n 数据范围为 20，且每个数只能被选择一次，所以我们可以 <strong>用一个 int (32位)</strong> 来表示选数的情况，对应二进制为 1 代表已被选择，否则代表未被选择。这种方案的好处在于很容易就能实现 <code>记忆化搜索</code>，不管是用 <code>int[1 &lt;&lt; 20]</code> 又或者是 <code>Map&lt;Integer, Integer&gt;</code> 。</p><p>整体实现的逻辑还是和上面的版本一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>]; <span class="hljs-comment">// int 的第 n 位为 1 代表 n - 1 被选择</span><br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canIWin</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> dest)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt; dest) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 依题意平手算先出手的玩家输</span><br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, dest) == <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> state, <span class="hljs-type">int</span> dest)</span>&#123;<br>        <span class="hljs-keyword">if</span>(cache[state] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> cache[state];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(((state &gt;&gt; (i - <span class="hljs-number">1</span>)) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">// 玩家不能重复使用整数</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i &gt;= dest)&#123;<br>                <span class="hljs-keyword">return</span> cache[state] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dfs((state | (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>))), dest - i) == -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> cache[state] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cache[state] = -<span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串哈希</title>
    <link href="/2022/11/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <url>/2022/11/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<br><a href="https://oi-wiki.org/string/hash/">OI-WIKI-# 字符串哈希</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247489813&idx=1&sn=7f3bc18ca390d85b17655f7164d8e660">宫水三叶-# 字符串哈希入门</a><br><a href="https://leetcode.cn/problems/repeated-dna-sequences/">Leetcode-187重复的 DNA 序列</a></p></blockquote><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>具体来说，哈希函数最重要的性质可以概括为下面两条：</p><ol><li><p>在 Hash 函数值不一样的时候，两个字符串一定不一样；</p></li><li><p>在 Hash 函数值一样的时候，两个字符串不一定一样（哈希冲突&#x2F;碰撞。但大概率一样，且我们当然希望它们总是一样的）。</p></li></ol><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>我们需要关注的是什么？</p><p>时间复杂度和 Hash 的准确率。</p><p>通常我们采用的是<strong>多项式 Hash</strong>的方法，对于一个长度为 L 的字符串 s 来说，我们可以这样定义多项式 Hash 函数：</p><p><img src="/img/20221001012815.png"></p><p>这种情况下，对于字符串 xyz ，其哈希函数值为 xb^2 + yb + z。</p><p>对于该 Hash 函数的参考实现如下(（效率低下的版本，实际使用时一般不会这么写）)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">233</span>; <br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll; <br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_hash</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span> </span>&#123; <br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123; <br>res = (ll)(res * B + s[i]) % M; <br>&#125; <br><span class="hljs-keyword">return</span> res; <br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">const</span> string&amp; t)</span> </span>&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">get_hash</span>(s) == <span class="hljs-built_in">get_hash</span>(t); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多次询问子串哈希"><a href="#多次询问子串哈希" class="headerlink" title="多次询问子串哈希"></a>多次询问子串哈希</h2><p>单次计算一个字符串的哈希值复杂度是 O(n)，其中 n 为串长，与暴力匹配没有区别，如果需要多次询问一个字符串的子串的哈希值，每次重新计算效率会非常低下。</p><p>一般采取的方法是对整个字符串先 <strong>预处理出每个前缀的哈希值(设该数组为H)</strong> ，将哈希值看成一个 b 进制的数对 m 取模的结果，这样的话可以做到快速求出子串的哈希。</p><p>首先对于F(s[1, i]) ，即原串长度为 i 的前缀（即子串s[1, i]）的哈希值 <strong>(即H[i])</strong> ，按照定义为</p><p><strong>F(s[1, i])  &#x3D; s[1] * b^ (i - 1) + s[2] * b ^ (i - 2) + … + s[i - 1] * b +s[i]</strong> </p><p>现在，我们想要用类似前缀和的方式快速求出子串 s[L, R] 的哈希值即 F(s[L, R])，按照定义哈希值为</p><p><strong>F(s[L, R])  &#x3D; s[L] * b^ (R - L) + s[L + 1] * b ^ (R - L - 1) + … + s[R - 1] * b +s[R]</strong></p><p>对比观察上述两个式子，可以发现 <code>式2</code> 其实可以由 <code>式1</code> 得出，即<br><strong>F(s[L, R])  &#x3D; F(s[1, R]) - F(s[1, L-1]) * b ^ (r - L + 1)</strong> </p><p>那么即字串 S[L, R] 的哈希值等于 H[R] - H[L-1] * B ^ (R - L +1)</p><p>而 B ^ (r - L + 1)  又可以通过 O(n) 的预处理出次方数组，以实现 O(1) 的回答每次询问</p><p>实现，<a href="https://leetcode.cn/problems/repeated-dna-sequences/">Leetcode187</a>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-number">131313</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] POWER = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M]; <span class="hljs-comment">// 次方数组  </span><br>  <br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findRepeatedDnaSequences</span><span class="hljs-params">(String s)</span> &#123;  <br>        <span class="hljs-type">int</span>[] hashTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length() + <span class="hljs-number">1</span>];  <br>        POWER[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++)&#123;  <br>            <span class="hljs-comment">// 预处理前缀哈希数组  </span><br>            hashTable[i] = hashTable[i - <span class="hljs-number">1</span>] * B + s.charAt(i - <span class="hljs-number">1</span>) % M;  <br>            <span class="hljs-comment">// 预处理次方数组</span><br>            POWER[i] = POWER[i - <span class="hljs-number">1</span>] * B;  <br>        &#125;  <br>        Map&lt;Integer, Integer&gt; countMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length() - <span class="hljs-number">10</span> + <span class="hljs-number">1</span>; i++)&#123;  <br>            <span class="hljs-comment">// 子串哈希等于 h(r) - h(l - 1) * b ^ (r - l + 1)            </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hashTable[i + <span class="hljs-number">9</span> + <span class="hljs-number">1</span>] - hashTable[i] * POWER[i + <span class="hljs-number">9</span> - i + <span class="hljs-number">1</span>];  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> countMap.merge(hash, <span class="hljs-number">0</span>, (oldValue, __) -&gt; ++oldValue);  <br>            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">1</span>)&#123;  <br>                ans.add(s.substring(i, i + <span class="hljs-number">10</span>));  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> ans;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collector-and-Stream.reduce()</title>
    <link href="/2022/11/03/Collector-and-Stream.reduce()/"/>
    <url>/2022/11/03/Collector-and-Stream.reduce()/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://leetcode.cn/problems/reformat-phone-number/">删除字符串中的破折号和空字符</a></p><blockquote><p>当然，最简洁的方式是<br>        String s &#x3D; number.replace(“ “, “”).replace(“-“, “”);<br>但这里暂时忽略这种方案，只是为了指出该背景</p></blockquote><p>一种较复杂的方案是使用 Stream，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">justCase</span><span class="hljs-params">(String str)</span>&#123;  <br>    <span class="hljs-keyword">return</span> str.chars()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>)<br>            .collect(Collector.of(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    (__, ___) -&gt; &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;un support parallel stream&quot;</span>);&#125;,<br>                    StringBuilder::toString));  <br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，要将字符数组重新收集成 <code>String</code> 的合理做法应该只有使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">.collect(supplier,  accumulator,  combiner);<br><span class="hljs-comment">// or</span><br>.collect(Collector.of());  <br></code></pre></td></tr></table></figure><p>其余做法例如 <code>mapToObj(String::valueOf).collect(joining)</code> 会频繁创建 String；<br>而 <code>reduce</code> 严格来讲既不是<strong>可变规约</strong>也没有简洁多少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">justCase</span><span class="hljs-params">(String str)</span>&#123;  <br>    <span class="hljs-keyword">return</span>  str.chars().parallel()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>)  <br>            .reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(),  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString();  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实例化-CollectorImpl"><a href="#实例化-CollectorImpl" class="headerlink" title="实例化 CollectorImpl"></a>实例化 CollectorImpl</h2><blockquote><p>这里只对 <code>Collector</code> 做该话题下的简单介绍，详细知识见 javadocs</p></blockquote><p>Collector 接口由四个抽象函数指定，这些函数协同工作以将条目累积到可变结果容器中，并可选择对结果执行最终转换。他们是：</p><ul><li>supplier() ：创建一个新的结果容器</li><li>accumulator() ：将新数据元素合并到结果容器中</li><li>combiner()：将两个结果容器合并为一个（  ）</li><li>finisher() ：对容器执行可选的最终转换</li></ul><p><code>Collector</code> 接口在 JDK 中的实现类位于 <code>Collectors.CollectorImpl</code><br>而实例化  <code>CollectorImpl</code> 有两种途径：</p><ul><li>通过 <code>Collectors</code> 类预定义的例如 <code>Collectors.toList()</code> 等静态工厂方法实例化</li><li>通过 <code>Collector</code> 接口中暴露出的两种 <code>Collector.of</code> 方法实例化：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collector</span>&lt;T, A, R&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T, R&gt; Collector&lt;T, R, R&gt; <span class="hljs-title function_">of</span><br><br><span class="hljs-params">(Supplier&lt;R&gt; supplier,  </span><br><span class="hljs-params">                                          BiConsumer&lt;R, T&gt; accumulator,  </span><br><span class="hljs-params">                                          BinaryOperator&lt;R&gt; combiner,  </span><br><span class="hljs-params">                                          Characteristics... characteristics)</span> <br>                                          <br>                                          &#123;...&#125;<br>                                          <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T, A, R&gt; Collector&lt;T, A, R&gt; <span class="hljs-title function_">of</span><br>    <br><span class="hljs-params">(Supplier&lt;A&gt; supplier,  </span><br><span class="hljs-params">                                             BiConsumer&lt;A, T&gt; accumulator,  </span><br><span class="hljs-params">                                             BinaryOperator&lt;A&gt; combiner,  </span><br><span class="hljs-params">                                             Function&lt;A, R&gt; finisher,  </span><br><span class="hljs-params">                                             Characteristics... characteristics)</span><br><br>                                             &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>可以看到，<code>Collector</code> 接口只提供了两种重载用于实例化 <code>CollectorImpl</code><br>并且这两种重载都必须传入 <code>supplier</code> 、<code>accmulator</code> 以及 <code>combiner</code>，前两个参数很好理解，毕竟 <code>CollectorImpl</code> 不好对此提供默认的实现<br>但是对于组合器  <code>combiner</code>，<strong>由于组合器只有在执行并发规约时会使用到</strong>，也就是说，对于上面场景下的收集器（即不考虑使用并发流的场景），提供一个 <code>combiner</code> 并没有实际意义</p><h2 id="为什么必须提供-combiner"><a href="#为什么必须提供-combiner" class="headerlink" title="为什么必须提供 combiner"></a>为什么必须提供 combiner</h2><p>在<a href="https://stackoverflow.com/questions/24308146/why-is-a-combiner-needed-for-reduce-method-that-converts-type-in-java-8/24316429#24316429">该问题中</a>，发现这种操作在 <code>Scala</code> 中被称为<code>foldLeft</code>。需要注意的是，Java 的库函数中并没有提供等效于 <code>foldLeft</code> 的实现。</p><blockquote><p>在上面的回答中提到：<br>Finally, Java doesn’t provide <code>foldLeft</code> and <code>foldRight</code> operations because they imply a particular ordering of operations that is inherently sequential. This clashes with the design principle stated above of providing APIs that support sequential and parallel operation equally.<br>最后，Java 不提供<code>foldLeft</code>and<code>foldRight</code>操作，因为它们暗示了一种特定的操作顺序，这种顺序本质上是顺序的。这与上述提供同样支持顺序和并行操作的 API 的设计原则相冲突。</p></blockquote><p>虽然该说法有一定说服力，但还是继续搜索了为什么 Java 没有提供 <code>foldLeft</code>，试图继续理解所提到的<code>设计原则</code>。<br>但是结果却找到了<a href="https://bugs.openjdk.org/browse/JDK-8292845">JDK-8292845</a>和<a href="https://bugs.openjdk.org/browse/JDK-8292845">JDK-8292845</a>，但在这两个增强请求中，却没有对相关<code>设计原则</code>进行讨论，而是计划会在将来对此进行实现。</p><p>也许在不久的将来，就会有一种更合理的 folding operations 可以替换上方看似不合理的实现</p><h2 id="reduce-vs-collect"><a href="#reduce-vs-collect" class="headerlink" title="reduce vs collect"></a>reduce vs collect</h2><p>先看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">justCase</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a-b&quot;</span>;  s<br>    Function&lt;String, Stream&lt;Character&gt;&gt; function = str -&gt; str.chars()  <br>            .parallel()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>);  <br>  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(),  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString(); <span class="hljs-comment">// baba  </span><br>  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .collect(Collector.of(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    StringBuilder::append,  <br>                    StringBuilder::toString)); <span class="hljs-comment">// ab</span><br>                    <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .collect(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString(); <span class="hljs-comment">// ab</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现在 <code>parallel stream</code> 下 <code>reduce()</code> 的输出并不符合我们的预期，先查看 <code>reduce()</code> 的方法注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java">...<br> identity值必须是组合器函数的标识。这意味着对于所有u ，<br>     combiner(identity , u) == u<br> 此外， combiner函数必须与accumulator函数兼容；对于所有u和t ，必须满足以下条件：<br>     combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)<br>...<br><br>&lt;U&gt; U <span class="hljs-title function_">reduce</span><span class="hljs-params">(U identity,  BiFunction&lt;U, ? <span class="hljs-built_in">super</span> T, U&gt; accumulator,  BinaryOperator&lt;U&gt; combiner)</span>;<br></code></pre></td></tr></table></figure><p>对这里的约定进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">justCase</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// combiner(identity , u) == u  </span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">identity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(<span class="hljs-string">&#x27;b&#x27;</span>);  <br>BinaryOperator&lt;StringBuilder&gt; combiner = StringBuilder::append;  <br><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply0</span> <span class="hljs-operator">=</span> combiner.apply(identity, u);  <br>log.debug(String.valueOf(apply0.toString().equals(u.toString()))); <span class="hljs-comment">// true  </span><br><br><br><span class="hljs-comment">// combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)  </span><br><span class="hljs-type">Object</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;  <br>BiFunction&lt;StringBuilder, Object, StringBuilder&gt; acc = StringBuilder::append;  <br>  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply1</span> <span class="hljs-operator">=</span> acc.apply(identity, t);  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply2</span> <span class="hljs-operator">=</span> combiner.apply(u, apply1);  <br>  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply3</span> <span class="hljs-operator">=</span> acc.apply(u, t);  <br><br>log.debug(String.valueOf(apply2.toString().equals(apply3.toString()))); <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现我们的用例其实是符合 <code>reduce()</code> 方法在 javadocs 中的约定的，于是继续查看相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 使用提供的标识、累积和组合函数对该流的元素执行 归约 </span><br>reduce(U identity, BiFunction&lt;U,? <span class="hljs-built_in">super</span> T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)<br><br><span class="hljs-comment">// 对此流的元素执行 可变归约 操作</span><br>collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? <span class="hljs-built_in">super</span> T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)<br></code></pre></td></tr></table></figure><p>会发现这其实是因为 <code>reduce()</code> 只是 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#ReductionOperations">Reduction operations</a> 导致的（而 <code>StringBuilder</code> 是可变对象），在该场景下应该使用  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#MutableReduction">Mutable reduction(可变规约)</a> ，也就是 <code>collect()</code></p><p>实际上仔细查看代码会发现 <code>reduce</code> 和 <code>collect</code> 的累加器 <code>accumulator</code> 定义也并不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// Reduction operations 在累加器中返回处理结果，处理结果的类型不能是可变的</span><br>reduce(... BiFunction&lt;U, ? <span class="hljs-built_in">super</span> T, U&gt; accumulator...)<br><span class="hljs-comment">// Mutable reduction(可变规约) 在累加器中不返回处理结果而是通过修改可变容器本身</span><br>collect(...BiConsumer&lt;R, ? <span class="hljs-built_in">super</span> T&gt; accumulator...) <br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#MutableReduction">Mutable reduction(可变规约)</a></p><p><a href="https://stackoverflow.com/questions/56023452/how-does-reduce-method-work-with-parallel-streams-in-java-8">how-does-reduce-method-work-with-parallel-streams-in-java-8</a></p><blockquote><p>The problem lies in you using Stream::reduce for mutable reduction.<br>You should instead use Stream::collect</p></blockquote><p><a href="https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce/38728166#38728166">java-8-streams-collect-vs-reduce</a></p><blockquote><p>The reason is simply that:</p><ul><li>collect() can only work with mutable result objects.</li><li>reduce() is designed to work with immutable result objects.</li></ul></blockquote><p><a href="https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce/22577274#22577274">java-8-streams-collect-vs-reduce</a></p><blockquote><p>reduce是一个“折叠”操作，它将二元运算符应用于流中的每个元素，其中运算符的第一个参数是前一个应用程序的返回值，第二个参数是当前流元素。<br>collect是一种聚合操作，其中创建“集合”并将每个元素“添加”到该集合中。然后将流中不同部分的集合添加到一起。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
