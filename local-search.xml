<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LC-1139.最大的以1为边界的正方形</title>
    <link href="/2023/02/17/LC-1139-%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BB%A51%E4%B8%BA%E8%BE%B9%E7%95%8C%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <url>/2023/02/17/LC-1139-%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BB%A51%E4%B8%BA%E8%BE%B9%E7%95%8C%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/largest-1-bordered-square/">leetcode 中等题</a></p><p>给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。</p><p>示例1：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,1,1],[1,0,1],[1,1,1]]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> &lt;= grid.length &lt;= <span class="hljs-number">100</span><br><span class="hljs-attribute">1</span> &lt;= grid[<span class="hljs-number">0</span>].length &lt;= <span class="hljs-number">100</span><br><span class="hljs-attribute">grid</span>[i][j] 为 <span class="hljs-number">0</span> 或 <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="前缀和-x2F-动态规划"><a href="#前缀和-x2F-动态规划" class="headerlink" title="前缀和&#x2F;动态规划"></a>前缀和&#x2F;动态规划</h2><p>容易想到，我们可以枚举所有点 $g[i][j]$ 作为正方形的左上顶点时，所能取到的最大边长是多少，取所有点所取的最大边长再开方，即为答案。</p><p>我们可以尝试枚举所有点、所有可能的边长，此时最多约有 $100 \times 100 \times 100 &#x3D; 10^6$ 次运算，所以对于判断某个正方形是否满足题目条件，需要在较短最好是 $O(1)$ 的时间内做到。 </p><p>我们如果能预处理出以每个顶点向右最多有几个 $1$ ，向下最多有几个 $1$ ，设其分别为 $right[i][j]、down[i][j]$ ，就能在 $O(1)$ 的时间内判断出以 $g[i][j]$ 作为左上端点、以 $k$ 作为边长的正方形是否满足条件，显然此时当 $right[i][j] &gt;&#x3D; k　and　down[i][j] &gt;&#x3D; k　and　right[i + k][j] &gt;&#x3D; k　and　down[i][j + k] &gt;&#x3D; k$ 时，该正方形合法。</p><p>对于 $right、down$ 数组的维护，可以从两个角度理解。一是前缀和，两个数组分别为不同方向的前缀和，只需要处理好遍历顺序即可；二是动态规划，以 $right$ 为例，显然有以下转移方程：<br>$$<br>\begin{align}<br>&amp;right[i][j] &#x3D; 0　　　　　　　　　　　　　　　　　　　 g[i][j] &#x3D;&#x3D; 0\\<br>&amp;right[i][j] &#x3D; right[i][j + 1] + 1　　　　　　　　　　　g[i][j] &#x3D;&#x3D; 1 \\<br>\end{align}<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largest1BorderedSquare</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] g)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> g.length, m = g[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>], down = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>                <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-number">1</span>)&#123;<br>                    right[i][j] = right[i][j+ <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    down[i][j] = down[i + <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, maxLength - <span class="hljs-number">1</span>); right[i][j] &gt;= k + <span class="hljs-number">1</span> &amp;&amp; down[i][j] &gt;= k + <span class="hljs-number">1</span> &amp;&amp; k + j &lt; m &amp;&amp; k + i &lt; n; k++)&#123;<br>                    <span class="hljs-keyword">if</span>(right[i + k][j] &gt;= k + <span class="hljs-number">1</span> &amp;&amp; down[i][j + k] &gt;= k + <span class="hljs-number">1</span>)&#123;<br>                        maxLength = Math.max(maxLength, k + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLength * maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1124.表现良好的最长时间段</title>
    <link href="/2023/02/14/LC-1124-%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5/"/>
    <url>/2023/02/14/LC-1124-%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/longest-well-performing-interval/">leetcode 中等题</a></p><p>给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。</p><p>我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。</p><p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。</p><p>请你返回「表现良好时间段」的最大长度。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：hours = <span class="hljs-comment">[9,9,6,0,6,6,9]</span><br>输出：3<br>解释：最长的表现良好时间段是 <span class="hljs-comment">[9,9,6]</span>。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= hours.length &lt;= <span class="hljs-number">104</span><br><span class="hljs-symbol">0 </span>&lt;= hours[i] &lt;= <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h2 id="贪心-单调栈"><a href="#贪心-单调栈" class="headerlink" title="贪心 + 单调栈"></a>贪心 + 单调栈</h2><blockquote><p>我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。</p></blockquote><p>那么可以将大于 8 小时的天数转化成 $1$ ，否则转换成 $-1$ ，此时 <code>表现良好的时间段</code> 指的就是某段和为正数的子数组，满足条件的最长子数组的长度即为答案。</p><p>需要满足子数组和为正数，那么容易想到构造一个原数组的前缀和数组，其中 $preSum[i]$ 表示原数组 $[0…i - 1]$ 的元素和。此时可以通过遍历前缀和数组，对于 $preSum[i]$ 找到一个左边最远的下标 $left$ ，使得满足 $preSum[i] - preSum[left] &gt; 0$ ，此时 $max(i - left)$ 为答案。</p><p>对于下标 $i$ 找到左边最远的满足 $preSum[left] &lt; preSum[i]$ 的 $left$ ，一种方法是通过单调栈来实现。</p><p>我们维护一个栈，从栈底到栈顶元素单调递减。</p><p>考虑顺序遍历，若 $preSum[i] &gt; stk.peek()$，则弹出栈顶最小元素。</p><ul><li>如果 $preSum[i] &gt; preSum[i + 1]$ ，当前的 $i$ 可能将后续所需要的栈元素弹出，且以后续下标为右端点的区间可能更长，导致结果不正确；</li></ul><p>考虑逆序遍历，若 $preSum[i] &gt; stk.peek()$，则弹出栈顶最小元素。</p><ul><li>如果 $preSum[i - 1] &lt; preSum[i]$ ，虽然当前 $i$ 弹出的元素也会影响到 $i - 1$ ，但是因为如果以 $preSum[i - 1]$ 为右端点能取到一个满足题意的区间时，$preSum[i]$ 也必然能够取到，且更长，所以没必要考虑 $i - 1$ 。</li><li>如果 $preSum[i - 1] &gt; preSum[i]$，则当前 $i$ 所弹出的元素都是 $i - 1$ 所要弹出的，所以不会影响答案的正确性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestWPI</span><span class="hljs-params">(<span class="hljs-type">int</span>[] hours)</span> &#123;<br>        hours = Arrays.stream(hours).map(i -&gt; i &gt; <span class="hljs-number">8</span> ? <span class="hljs-number">1</span> : - <span class="hljs-number">1</span>).toArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> hours.length;<br>        <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + hours[i - <span class="hljs-number">1</span>]; <br>        &#125;<br>        Deque&lt;Integer&gt; monoStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++)&#123; <span class="hljs-comment">// push 0 避免后面特判 preSum[i] 为正数</span><br>            <span class="hljs-keyword">if</span>(monoStack.isEmpty() || preSum[monoStack.peek()] &gt; preSum[i])&#123;<br>                monoStack.push(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt;= <span class="hljs-number">1</span>; i--)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(!monoStack.isEmpty() &amp;&amp; preSum[monoStack.peek()] &lt; preSum[i])&#123;<br>                left = monoStack.pop();<br>            &#125;<br>            ans = left == -<span class="hljs-number">1</span> ? ans : Math.max(ans, i - left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="贪心-哈希表"><a href="#贪心-哈希表" class="headerlink" title="贪心 + 哈希表"></a>贪心 + 哈希表</h2><p>我们也可以不需要单调栈来实现找到左边最远的满足 $preSum[left] &lt; preSum[i]$ 的 $left$ 。</p><p>这是因为前缀和数组满足连续性，也就是如果某个数 $i$ 存在，则 $i - 1$ 也必然存在。</p><p>所以对于某个 $preSum[i]$ ，此时左边最远的小于 $preSum[i]$ 的值，就必然是 $preSum[i] - 1$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestWPI</span><span class="hljs-params">(<span class="hljs-type">int</span>[] hours)</span> &#123;<br>        hours = Arrays.stream(hours).map(i -&gt; i &gt; <span class="hljs-number">8</span> ? <span class="hljs-number">1</span> : - <span class="hljs-number">1</span>).toArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> hours.length;<br>        <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + hours[i - <span class="hljs-number">1</span>]; <br>        &#125;<br>        Map&lt;Integer, Integer&gt; indexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(preSum[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                ans = Math.max(ans, i);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            indexMap.putIfAbsent(preSum[i], i);<br>            <span class="hljs-keyword">if</span>(indexMap.get(preSum[i] - <span class="hljs-number">1</span>) != <span class="hljs-literal">null</span>)&#123;<br>                ans = Math.max(ans, i - indexMap.get(preSum[i] - <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>单调栈</tag>
      
      <tag>贪心</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1234.替换子串得到平衡字符串</title>
    <link href="/2023/02/13/LC-1234-%E6%9B%BF%E6%8D%A2%E5%AD%90%E4%B8%B2%E5%BE%97%E5%88%B0%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/02/13/LC-1234-%E6%9B%BF%E6%8D%A2%E5%AD%90%E4%B8%B2%E5%BE%97%E5%88%B0%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/">leetcode 中等题</a></p><p>有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。</p><p>假如在该字符串中，这四个字符都恰好出现 n&#x2F;4 次，那么它就是一个「平衡字符串」。</p><p>给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。</p><p>你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。</p><p>请返回待替换子串的最小可能长度。</p><p>如果原字符串自身就是一个平衡字符串，则返回 0。</p><p>示例1：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;QQWE&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：我们需要把一个 &#x27;Q&#x27; 替换成 &#x27;R&#x27;，这样得到的 <span class="hljs-string">&quot;RQWE&quot;</span> (或 <span class="hljs-string">&quot;QRWE&quot;</span>) 是平衡的。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-number">1</span> &lt;= s.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br>s.<span class="hljs-built_in">length</span> 是 <span class="hljs-number">4</span> 的倍数<br>s 中只含有 <span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span> 四种字符<br></code></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>一个关键的结论是 <code>代替换子串</code> 区间外的其他元素，必须满足 $cnt[Q&#x2F;W&#x2F;E&#x2F;R] &lt;&#x3D; n&#x2F;4$ ，否则显然无法替换得到一个平衡字符串。</p><p>那么我们可以通过滑动窗口得到 <code>代替换子串</code> 区间，并取该区间最小长度即可。</p><p>具体来说，初始时左右指针均指向 $0$ 下标处，右指针每次右移一位，直到满足区间外的元素 $cnt[Q&#x2F;W&#x2F;E&#x2F;R] &lt;&#x3D; n&#x2F;4$ ，显然此时在左指针不变的情况下，右指针没必要继续右移，因为这只会增加区间的长度，所以此时尝试将左指针右移，直到不满足条件，在这个过程中维护一个满足条件的区间长度最小值即为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">balancedString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        Map&lt;Character, Long&gt; cnt = s.chars().mapToObj(__ -&gt; (<span class="hljs-type">char</span>)__)<br>                        .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));<br>        <span class="hljs-keyword">if</span>(check(cnt, n))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>; left &lt; n &amp;&amp; right &lt; n; right++)&#123; <br>            cnt.compute(s.charAt(right), (key, value) -&gt; --value);<br>            <span class="hljs-keyword">while</span>(left &lt; n &amp;&amp; left &lt;= right &amp;&amp; check(cnt, n))&#123;<br>                ans = Math.min(ans, right - left + <span class="hljs-number">1</span>);<br>                cnt.compute(s.charAt(left++), (key, value) -&gt; ++value);<br>            &#125;                 <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(Map&lt;Character, Long&gt; cnt, <span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">return</span> cnt.values().stream().allMatch(count -&gt; count &lt;= n / <span class="hljs-number">4</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6357.最少得分子序列</title>
    <link href="/2023/02/13/LC-6357-%E6%9C%80%E5%B0%91%E5%BE%97%E5%88%86%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2023/02/13/LC-6357-%E6%9C%80%E5%B0%91%E5%BE%97%E5%88%86%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/subsequence-with-the-minimum-score/">leetcode 困难题</a></p><p>给你两个字符串 s 和 t 。</p><p>你可以从字符串 t 中删除任意数目的字符。</p><p>如果没有从字符串 t 中删除字符，那么得分为 0 ，否则：</p><p>令 left 为删除字符中的最小下标。<br>令 right 为删除字符中的最大下标。<br>字符串的得分为 right - left + 1 。</p><p>请你返回使 t 成为 s 子序列的最小得分。</p><p>一个字符串的 子序列 是从原字符串中删除一些字符后（也可以一个也不删除），剩余字符不改变顺序得到的字符串。（比方说 “ace” 是 “abcde” 的子序列，但是 “aec” 不是）。</p><p>示例1：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;abacaba&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;bzaa&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：这个例子中，我们删除下标 <span class="hljs-number">1</span> 处的字符 <span class="hljs-string">&quot;z&quot;</span> （下标从 <span class="hljs-number">0</span> 开始）。<br>字符串 <span class="hljs-built_in">t</span> 变为 <span class="hljs-string">&quot;baa&quot;</span> ，它是字符串 <span class="hljs-string">&quot;abacaba&quot;</span> 的子序列，得分为 <span class="hljs-number">1</span> - <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">1</span> 。<br><span class="hljs-number">1</span> 是能得到的最小得分。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> &lt;= s.length, t.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-attribute">s</span> 和 t 都只包含小写英文字母<br></code></pre></td></tr></table></figure><h2 id="前后缀分解-双指针"><a href="#前后缀分解-双指针" class="headerlink" title="前后缀分解 + 双指针"></a>前后缀分解 + 双指针</h2><p>注意到得分只取决于删除的最大&#x2F;最小下标，那么我们不妨将 $left, right$ 之间的元素全部删除，这样既不影响得分，$t$ 也依旧是 $s$ 的一个子序列。也就是说此时除了 $t[left…right]$ 区间的元素，$t$ 中剩余的元素都必须与 $s$ 的子序列匹配。</p><p>这样一来我们就可以进行前后缀分解，设 $i$ 为 $s$ 的某个下标</p><ul><li>$pre[i]$ 表示 $s[0…i]$ 子序列能够在 $t$ 中匹配到的最长前缀</li><li>$suf[i]$ 表示 $s[i…n]$ 子序列能够在 $t$ 中匹配到的最长后缀</li></ul><p>那么显然答案就为 $max( suf[i + 1] - 1 - (pre[i] + 1) + 1 )$ 。</p><p>接下来考虑如何维护 $pre$ 和 $suf$ ，可以通过双指针进行维护。以 $pre$ 为例，初始时指针 $i、j$ 分别指向 $s、t$ 的 $0$ 下标处，匹配过程中每次 $i$ 往后移动一位，而当 $s[i] &#x3D;&#x3D; t[j]$ 时，说明匹配成功，$j$ 往后移动一位，每次更新 $pre[i]$ 为 $j - 1$ 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumScore</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span>[] pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n &amp;&amp; j &lt; m; i++)&#123;   <br>            <span class="hljs-keyword">if</span>(s.charAt(i) == t.charAt(j))&#123;<br>                j++;<br>            &#125;<br>            pre[i] = j - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(pre[n - <span class="hljs-number">1</span>] == m - <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] suf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>, j = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--)&#123; <br>            <span class="hljs-keyword">if</span>(s.charAt(i) == t.charAt(j))&#123;<br>                j--;<br>            &#125;<br>            suf[i] = j + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> suf[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span> - (-<span class="hljs-number">1</span> + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>; <span class="hljs-comment">// i.e. suf[0]</span><br>        suf[n] = m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            ans = Math.min(ans, suf[i + <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> - (pre[i] + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>); <span class="hljs-comment">// i.e. suf[i + 1] - pre[i] - 1</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(ans, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>双指针/多指针</tag>
      
      <tag>前后缀分解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6356.子字符串异或查询</title>
    <link href="/2023/02/12/LC-6356-%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2/"/>
    <url>/2023/02/12/LC-6356-%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/substring-xor-queries/">leetcode 中等题</a></p><p>给你一个 二进制字符串 s 和一个整数数组 queries ，其中 queries[i] &#x3D; [firsti, secondi] 。</p><p>对于第 i 个查询，找到 s 的 最短子字符串 ，它对应的 十进制值 val 与 firsti 按位异或 得到 secondi ，换言之，val ^ firsti &#x3D;&#x3D; secondi 。</p><p>第 i 个查询的答案是子字符串 [lefti, righti] 的两个端点（下标从 0 开始），如果不存在这样的子字符串，则答案为 [-1, -1] 。如果有多个答案，请你选择 lefti 最小的一个。</p><p>请你返回一个数组 ans ，其中 ans[i] &#x3D; [lefti, righti] 是第 i 个查询的答案。</p><p>子字符串 是一个字符串中一段连续非空的字符序列。</p><p>示例1：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：s = <span class="hljs-string">&quot;101101&quot;</span>, queries = <span class="hljs-string">[[0,5],[1,2]]</span><br>输出：<span class="hljs-string">[[0,2],[2,3]]</span><br>解释：第一个查询，端点为 [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>] 的子字符串为 <span class="hljs-string">&quot;101&quot;</span> ，对应十进制数字 <span class="hljs-number">5</span> ，且 <span class="hljs-number">5</span> ^ <span class="hljs-number">0</span> = <span class="hljs-number">5</span> ，所以第一个查询的答案为 [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]。第二个查询中，端点为 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] 的子字符串为 <span class="hljs-string">&quot;11&quot;</span> ，对应十进制数字 <span class="hljs-number">3</span> ，且 <span class="hljs-number">3</span> ^ <span class="hljs-number">1</span> = <span class="hljs-number">2</span> 。所以第二个查询的答案为 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] 。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> &lt;= s.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-attribute">s</span>[i] 要么是 &#x27;<span class="hljs-number">0</span>&#x27; ，要么是 &#x27;<span class="hljs-number">1</span>&#x27; 。<br><span class="hljs-attribute">1</span> &lt;= queries.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-attribute">0</span> &lt;= firsti, secondi &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>题目 $val \oplus first &#x3D; second$ 可以转化成 $val &#x3D; first \oplus second$，此时我们对每个询问可以直接计算出对应的 $val$ ，再判断该 $val$ 是否为原字符串的一个子串即可。</p><p>但是注意到 $queries.length &lt;&#x3D; 10^5, s.length &lt;&#x3D; 10 ^4$ ，也就是说就算使用 <code>KMP</code> 算法 $O(n + m)$ 的判断子串也会超时。</p><p>一个关键的部分是 $0 &lt;&#x3D; firsti, secondi &lt;&#x3D; 10^9$ ，所以他们的异或结果的二进制表示不会超过 $30$ 位，那么我们就可以预处理出原字符串所有小于等于 $30$ 长度的子串及其对应下标的映射关系，后面的询问过程就只需直接查询结果即可，此时时间复杂度为 $O(30N + M)$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] substringXorQueries(String s, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> queries.length;<br>        Map&lt;String, <span class="hljs-type">int</span>[]&gt; memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt;= i + <span class="hljs-number">30</span> &amp;&amp; j &lt; n; j++)&#123;<br>                sb.append(s.charAt(j));<br>                memo.putIfAbsent(sb.toString(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[] noExist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Integer.toBinaryString(queries[i][<span class="hljs-number">0</span>] ^ queries[i][<span class="hljs-number">1</span>]);<br>            ans[i] = memo.getOrDefault(cur, noExist);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>预处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1223.掷骰子模拟</title>
    <link href="/2023/02/10/LC-1223-%E6%8E%B7%E9%AA%B0%E5%AD%90%E6%A8%A1%E6%8B%9F/"/>
    <url>/2023/02/10/LC-1223-%E6%8E%B7%E9%AA%B0%E5%AD%90%E6%A8%A1%E6%8B%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/dice-roll-simulation/">leetcode 困难题</a></p><p>有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。</p><p>不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。</p><p>现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。</p><p>假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2, rollMax = [1,1,2,2,2,3]<br>输出：34<br>解释：我们掷<span class="hljs-number"> 2 </span>次骰子，如果没有约束的话，共有<span class="hljs-number"> 6 </span>*<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 36 </span>种可能的组合。但是根据 rollMax 数组，数字<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 2 </span>最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> n &lt;<span class="hljs-operator">=</span> <span class="hljs-number">5000</span><br>rollMax.length <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">6</span><br><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> rollMax[i] &lt;<span class="hljs-operator">=</span> <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>定义 $dp[i][j]$ 表示第 $i$ 次掷骰子结果点数为 $j$ 的序列个数，那么答案为 $\sum\limits_{j&#x3D;1}^6 dp[n][j]$ 。</p><p>先不考虑连续点数上限的限制，那么 $dp[i][j] &#x3D; \sum\limits_{k&#x3D;1}^6dp[i-1][k]$ 。此时只需要再减去以 $j$ 点数结尾并刚好超过 $rollMax[j-1]$ 点数的序列个数即可。</p><p>举例说明，设 $j &#x3D; 3, rollMax[3] &#x3D; 4$ ，考虑 $dp[7][3]$ ，也就是第 $7$ 次掷出 $3$ 时，此时连续出现 $5$ 个 $3$ 的序列个数为多少。显然该序列只会有一种形式，也就是 $x_1x_233333$，其中 $x_2$ 为不等于 $3$ 的任意点数，该序列的数量即 $dp[2][1] + dp[2][2] + dp[2][4] + dp[2][5] + dp[2][6]$。</p><p>也就是说，对于 $dp[i][j]$，我们只需要在上面累加的基础上再减去 $\sum\limits_{k&#x3D;1\&amp;k!&#x3D;j}^6dp[i - rollMax[j - 1] - 1][k]$ 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dieSimulator</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] rollMax)</span> &#123;<br>        <span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">2</span>][<span class="hljs-number">7</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">6</span>; j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= <span class="hljs-number">6</span>; k++)&#123; <br>                    dp[i][j] = (dp[i][j] + dp[i - <span class="hljs-number">1</span>][k]) % MOD;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i &lt; n + <span class="hljs-number">1</span> &amp;&amp; i &gt; rollMax[j - <span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= <span class="hljs-number">6</span>; k++)&#123;<br>                        <span class="hljs-keyword">if</span>(k == j)&#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        dp[i][j] = dp[i][j] - dp[i - rollMax[j - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>][k];<br>                        <span class="hljs-keyword">if</span>(dp[i][j] &lt;= <span class="hljs-number">0</span>)&#123;<br>                            dp[i][j] += MOD;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)dp[n + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有另一种更暴力，但是也较为繁琐的解法。</p><p>定义 $dp[i][j][k]$ 表示第 $i$ 次掷骰子结果点数为 $j$ 且此时已经连续出现了 $k$ 次 $j$ 的序列个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dieSimulator</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] rollMax)</span> &#123;<br>        <span class="hljs-type">long</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">7</span>][<span class="hljs-number">16</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++)&#123;<br>            dp[<span class="hljs-number">1</span>][i][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">6</span>; j++)&#123; <br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">15</span>; k++)&#123;<br>                   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; p &lt;= <span class="hljs-number">6</span>; p++)&#123; <br>                        <span class="hljs-keyword">if</span>(j == p &amp;&amp; k &lt;= rollMax[j - <span class="hljs-number">1</span>])&#123; <br>                            dp[i][j][k] = (dp[i][j][k] + dp[i - <span class="hljs-number">1</span>][p][k - <span class="hljs-number">1</span>]) % MOD;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(j != p)&#123;<br>                            dp[i][j][<span class="hljs-number">1</span>] = (dp[i][j][<span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][p][k]) % MOD;<br>                        &#125;<br>                    &#125; <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">6</span>; j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= rollMax[j - <span class="hljs-number">1</span>]; k++)&#123;<br>                ans = (ans + dp[n][j][k]) % MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-753.破解保险箱</title>
    <link href="/2023/02/06/LC-753-%E7%A0%B4%E8%A7%A3%E4%BF%9D%E9%99%A9%E7%AE%B1/"/>
    <url>/2023/02/06/LC-753-%E7%A0%B4%E8%A7%A3%E4%BF%9D%E9%99%A9%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/cracking-the-safe/">leetcode 困难题</a></p><p>有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位都是范围 [0, k - 1] 中的一个数字。</p><p>保险箱有一种特殊的密码校验方法，你可以随意输入密码序列，保险箱会自动记住 最后 n 位输入 ，如果匹配，则能够打开保险箱。</p><p>例如，正确的密码是 “345” ，并且你输入的是 “012345” ：<br>输入 0 之后，最后 3 位输入是 “0” ，不正确。<br>输入 1 之后，最后 3 位输入是 “01” ，不正确。<br>输入 2 之后，最后 3 位输入是 “012” ，不正确。<br>输入 3 之后，最后 3 位输入是 “123” ，不正确。<br>输入 4 之后，最后 3 位输入是 “234” ，不正确。<br>输入 5 之后，最后 3 位输入是 “345” ，正确，打开保险箱。<br>在只知道密码位数 n 和范围边界 k 的前提下，请你找出并返回确保在输入的 某个时刻 能够打开保险箱的任一 最短 密码序列 。</p><p>示例1：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">2</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">&quot;01100&quot;</span><br>解释：对于每种可能的密码：<br>- <span class="hljs-string">&quot;00&quot;</span> 从第 <span class="hljs-number">4</span> 位开始输入。<br>- <span class="hljs-string">&quot;01&quot;</span> 从第 <span class="hljs-number">1</span> 位开始输入。<br>- <span class="hljs-string">&quot;10&quot;</span> 从第 <span class="hljs-number">3</span> 位开始输入。<br>- <span class="hljs-string">&quot;11&quot;</span> 从第 <span class="hljs-number">2</span> 位开始输入。<br>因此 <span class="hljs-string">&quot;01100&quot;</span> 可以确保打开保险箱。<span class="hljs-string">&quot;01100&quot;</span>、<span class="hljs-string">&quot;10011&quot;</span> 和 <span class="hljs-string">&quot;11001&quot;</span> 也可以确保打开保险箱。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= n &lt;= <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span>&lt;= k &lt;= <span class="hljs-number">10</span><br><span class="hljs-symbol">1 </span>&lt;= kn &lt;= <span class="hljs-number">4096</span><br></code></pre></td></tr></table></figure><h2 id="Hierholzer-算法"><a href="#Hierholzer-算法" class="headerlink" title="Hierholzer 算法"></a>Hierholzer 算法</h2><p>实际上是求以所有 $n - 1$ 位密码组合作为顶点所构成图的 <a href="https://oi-wiki.org/graph/euler/#hierholzer-%E7%AE%97%E6%B3%95">欧拉回路</a> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> numRange;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> mod;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">private</span> Set&lt;Integer&gt; visit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">crackSafe</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        numRange = k;<br>        mod = (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">10</span>, n - <span class="hljs-number">1</span>); <br>        hierholzer(<span class="hljs-number">0</span>); <span class="hljs-comment">// 实际上起点是 n - 1 个 0 , 但是 * 10 后都为 0 , 所以直接取 0 也行</span><br>        <span class="hljs-keyword">return</span> ans.append(<span class="hljs-string">&quot;0&quot;</span>.repeat(n - <span class="hljs-number">1</span>)).toString();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hierholzer</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numRange; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> p * <span class="hljs-number">10</span> + i;<br>            <span class="hljs-keyword">if</span>(!visit.add(e))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            hierholzer(e % mod); <span class="hljs-comment">// 用简单回路替换 i 点      </span><br>            ans.append(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>欧拉图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1819.序列中不同最大公约数的数目</title>
    <link href="/2023/02/06/LC-1819-%E5%BA%8F%E5%88%97%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
    <url>/2023/02/06/LC-1819-%E5%BA%8F%E5%88%97%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/number-of-different-subsequences-gcds/">leetcode 困难题</a></p><p>给你一个由正整数组成的数组 nums 。</p><p>数字序列的 最大公约数 定义为序列中所有整数的共有约数中的最大整数。</p><p>例如，序列 [4,6,16] 的最大公约数是 2 。<br>数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。</p><p>例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。<br>计算并返回 nums 的所有 非空 子序列中 不同 最大公约数的 数目 。</p><p>示例1：</p><p><img src="/../img/Snipaste_2023-02-06_17-16-17.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [6,10,3]<br>输出：5<br>解释：上图显示了所有的非空子序列与各自的最大公约数。<br>不同的最大公约数为<span class="hljs-number"> 6 </span>、10 、3 、2 和<span class="hljs-number"> 1 </span>。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= nums[i] &lt;= <span class="hljs-number">2</span> * <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>由于 $nums.length &lt;&#x3D; 10^5$ ，我们很难通过对数组序列进行操作来得到答案。</p><p>一种思路是因为 $nums[i] &lt;&#x3D; 2 * 10^5$，由于最大的公约数必然小于数组最大元素，所以我们可以尝试枚举所有公约数，判断其是否为数组某个序列的最大公约数。</p><p>一个结论是如果某个序列 $[a_1, a2…a_i]$ 的最大公约数为 $x$ ，那么所有的 $a_i$ 必然均为 $x$ 的某个倍数，所以我们可以尝试枚举 $x$ 的所有倍数，当他们存在于数组并且最大公约数为 $x$ 时，答案加一。</p><p>此时的时间复杂度取决于内层总循环次数，约为 $max + \frac{max}{2} + \frac{max}{3} + … + 1\approx max*log(max)$ 。<a href="https://leetcode.cn/problems/number-of-different-subsequences-gcds/solution/ji-bai-100mei-ju-gcdxun-huan-you-hua-pyt-get7/?orderBy=hot">严谨的时间复杂度参考</a> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countDifferentSubsequenceGCDs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Arrays.stream(nums).max().orElseThrow();<br>        Set&lt;Integer&gt; set = Arrays.stream(nums).boxed().collect(Collectors.toSet());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= max; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">maxGcd</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt;= max; j += i)&#123;<br>                <span class="hljs-keyword">if</span>(!set.contains(j))&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                maxGcd = maxGcd == -<span class="hljs-number">1</span> ? j : gcd(maxGcd, j);<br>                <span class="hljs-keyword">if</span>(maxGcd == i)&#123;<br>                    ans++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a;<br>            a = b;<br>            b = temp % b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>思维题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6346.打家劫舍IV</title>
    <link href="/2023/02/06/LC-6346-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIV/"/>
    <url>/2023/02/06/LC-6346-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIV/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/house-robber-iv/">leetcode 中等题</a></p><p>沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。</p><p>由于相邻的房屋装有相互连通的防盗系统，所以小偷 不会窃取相邻的房屋 。</p><p>小偷的 窃取能力 定义为他在窃取过程中能从单间房屋中窃取的 最大金额 。</p><p>给你一个整数数组 nums 表示每间房屋存放的现金金额。形式上，从左起第 i 间房屋中放有 nums[i] 美元。</p><p>另给你一个整数数组 k ，表示窃贼将会窃取的 最少 房屋数。小偷总能窃取至少 k 间房屋。</p><p>返回小偷的 最小 窃取能力。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,5,9], k = 2<br>输出：5<br>解释：<br>小偷窃取至少<span class="hljs-number"> 2 </span>间房屋，共有<span class="hljs-number"> 3 </span>种方式：<br>- 窃取下标<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 2 </span>处的房屋，窃取能力为 max(nums[0], nums[2]) =<span class="hljs-number"> 5 </span>。<br>- 窃取下标<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 3 </span>处的房屋，窃取能力为 max(nums[0], nums[3]) =<span class="hljs-number"> 9 </span>。<br>- 窃取下标<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 3 </span>处的房屋，窃取能力为 max(nums[1], nums[3]) =<span class="hljs-number"> 9 </span>。<br>因此，返回 min(5, 9, 9) =<span class="hljs-number"> 5 </span>。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= nums[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br><span class="hljs-symbol">1 </span>&lt;= k &lt;= (nums.length + <span class="hljs-number">1</span>)/<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="二分-DP"><a href="#二分-DP" class="headerlink" title="二分 + DP"></a>二分 + DP</h2><blockquote><p>看到「最大化最小值」或者「最小化最大值」就要想到二分答案，这是一个固定的套路。</p></blockquote><p>注意到窃取房屋数和窃取能力满足单调性，所以可以二分窃取能力，取满足条件的最小值（右边界）即可，也就是满足至少偷窃 $k$ 间房屋。</p><p>具体来说，定义 $get(max)$ 返回窃取能力不超过 $max$ 时最多能偷窃的房屋数，如果某个 $max$ 大于等于题目中的 $k$ ，那么显然 $max$ 的右边都满足题意，所以可以继续缩小右边界，反之类似。</p><p>剩下问题就是 $get(max)$ 的实现了，可以通过动态规划解决，定义 $dp[i]$ 表示前 $i$ 个房子窃取能力不超过 $max$ 时的最大房屋数，那么有：</p><ul><li>第 i 个房子不偷，此时 $dp[i] &#x3D; dp[i - 1]$</li><li>第 i 个房子偷，需满足 $nums[i] &lt;&#x3D; max$ ，此时 $dp[i] &#x3D; dp[i - 2] + 1$</li></ul><p>取两者最大值即可<br>$$<br>\begin{align}<br>&amp;dp[i] &#x3D; max(dp[i - 1], dp[i - 2] + 1)　　　　　　　　　<br>\end{align}<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCapability</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">1000000000</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(get(mid, nums) &lt; k)&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> max, <span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n + <span class="hljs-number">1</span>; i++)&#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(nums[i - <span class="hljs-number">2</span>] &lt;= max)&#123;<br>                dp[i] = Math.max(dp[i], dp[i - <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以滚动变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java">...<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMaxHouse</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSteal, <span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, pre1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> nums[i] &lt;= maxSteal ? Math.max(pre1, pre2 + <span class="hljs-number">1</span>) : pre1;<br>            pre2 = pre1;<br>            pre1 = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre1;<br>    &#125;<br>...<br></code></pre></td></tr></table></figure><h2 id="二分-贪心"><a href="#二分-贪心" class="headerlink" title="二分 + 贪心"></a>二分 + 贪心</h2><p>另一种解法是二分 + 贪心，二分的过程同上。</p><p>而对于求窃取能力不超过 $mid$ 时最多能偷窃的房屋数，可以顺序的遍历房屋，如果某个房屋小于 $mid$ 时，贪心的偷取该房子即可。</p><p>直觉上就是正确的，也可以证明：因为 $dp[i - 1] &#x3D; max(dp[i - 2] , dp[ i - 3] + 1)$ ，且显然有 $dp[i] &gt;&#x3D; dp[i - 1]$ ，也就是说 $dp[i - 2] &gt;&#x3D; dp[i - 3]$ ，可以得出 $dp[i - 1] &lt;&#x3D; max(dp[i - 2], dp[i - 2] + 1)$ ，即 $dp[i - 1] &lt;&#x3D; dp[i - 2] + 1$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCapability</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">1000000000</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>), curK = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i += nums[i] &gt; mid ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>)&#123;<br>                curK += nums[i] &lt;= mid ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(curK &lt; k)&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>动态规划</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6345.重排水果</title>
    <link href="/2023/02/06/LC-6345-%E9%87%8D%E6%8E%92%E6%B0%B4%E6%9E%9C/"/>
    <url>/2023/02/06/LC-6345-%E9%87%8D%E6%8E%92%E6%B0%B4%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/rearranging-fruits/">leetcode 困难题</a></p><p>你有两个果篮，每个果篮中有 n 个水果。给你两个下标从 0 开始的整数数组 basket1 和 basket2 ，用以表示两个果篮中每个水果的成本。</p><p>你希望两个果篮相等。为此，可以根据需要多次执行下述操作：</p><p>选中两个下标 i 和 j ，并交换 basket1 中的第 i 个水果和 basket2 中的第 j 个水果。<br>交换的成本是 min(basket1i,basket2j) 。<br>根据果篮中水果的成本进行排序，如果排序后结果完全相同，则认为两个果篮相等。</p><p>返回使两个果篮相等的最小交换成本，如果无法使两个果篮相等，则返回 -1 。</p><p>示例1：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">输入：<span class="hljs-keyword">basket1 </span>= [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], <span class="hljs-keyword">basket2 </span>= [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">1</span><br>解释：交换 <span class="hljs-keyword">basket1 </span>中下标为 <span class="hljs-number">1</span> 的水果和 <span class="hljs-keyword">basket2 </span>中下标为 <span class="hljs-number">0</span> 的水果，交换的成本为 <span class="hljs-number">1</span> 。<br>此时，<span class="hljs-keyword">basket1 </span>= [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] 且 <span class="hljs-keyword">basket2 </span>= [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 。重排两个数组，发现二者相等。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">basket1</span>.length == bakste2.length<br><span class="hljs-attribute">1</span> &lt;= basket1.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-attribute">1</span> &lt;= basket1i,basket2i &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>设两个果篮中的所有的水果种类分别为 $a[1],a[2]…a[i]$ ，这些水果在两个果篮中的数量分别为 $cnt1[1]…cnt1[i]$ 、 $cnt2[1]…cnt2[i]$ 。</p><p>显然对于所有水果种类，均需要满足 $cnt1[i] + cnt2[i] \% 2 &#x3D;&#x3D; 0$，否则说明某种水果总数量为奇数，无论怎么交换，都无法平均的分配到两个果篮中，并且需要交换的水果显然只有 $cnt1[i] !&#x3D; cnt2[i]$ 的。因此我们可以先预处理出这部分水果种类，设其为 $b[1]…b[i]$ ，需要交换的次数显然为 $abs(cnt[1] - cnt[2]) &#x2F; 2$，并且为了使成本最低，我们可以堆化这部分水果，每次弹出最小的成本即可。</p><p>需要注意一种特殊情况，例如 case :</p><blockquote><p>[84,80,43,8,80,88,43,14,100,88]</p><p>[32,32,42,68,68,100,42,84,14,8]</p></blockquote><p>在该用例中，堆中需要交换的水果为</p><blockquote><p>[32, 43, 42, 88, 68, 80]</p></blockquote><p>按照上面的分析，此时会取最小的成本 $32$ ，考虑有没有更低成本的做法，我们可以取果篮中最小成本的水果，也就是 $8$ ，通过该水果作为中介进行两次交换，来将我们需要交换的水果放到目标果篮中，此时成本为 $8 *2 &#x3D; 16$ 。所以当果篮中最小成本水果的成本 * 2 依然小于堆顶的水果成本时，可以利用最小成本水果进行交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] basket1, <span class="hljs-type">int</span>[] basket2)</span> &#123;<br>        Function&lt;<span class="hljs-type">int</span>[], Map&lt;Integer, Integer&gt;&gt; fun = arr -&gt; Arrays.stream(arr).boxed()<br>                .collect(Collectors.groupingBy(Function.identity(), Collectors.summingInt(e -&gt; <span class="hljs-number">1</span>)));;<br>        Map&lt;Integer, Integer&gt; cnt1 = fun.apply(basket1), cnt2 = fun.apply(basket2);<br>        List&lt;Integer&gt; all = Stream.concat(cnt1.keySet().stream(), cnt2.keySet().stream()).distinct().toList();<br>        PriorityQueue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> item : all) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> Math.abs(cnt1.getOrDefault(item, <span class="hljs-number">0</span>) - cnt2.getOrDefault(item, <span class="hljs-number">0</span>));<br>            <span class="hljs-keyword">if</span> ((sub &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>            IntStream.generate(() -&gt; item).limit(sub / <span class="hljs-number">2</span>).forEach(minHeap::offer);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> all.stream().mapToInt(Integer::valueOf).min().orElseThrow() * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> IntStream.range(<span class="hljs-number">0</span>, minHeap.size() / <span class="hljs-number">2</span>).boxed().reduce(<span class="hljs-number">0L</span>,<br>                (ans, e) -&gt; ans + Math.min(min, minHeap.poll()), Long::sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相同的思路，另一种写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] basket1, <span class="hljs-type">int</span>[] basket2)</span> &#123;<br>        Function&lt;<span class="hljs-type">int</span>[], Map&lt;Integer, Integer&gt;&gt; fun = arr -&gt; Arrays.stream(arr).boxed()<br>                .collect(Collectors.groupingBy(Function.identity(), Collectors.summingInt(e -&gt; <span class="hljs-number">1</span>)));;<br>        Map&lt;Integer, Integer&gt; cnt1 = fun.apply(basket1), cnt2 = fun.apply(basket2);<br>        List&lt;Integer&gt; all = Stream.concat(cnt1.keySet().stream(), cnt2.keySet().stream()).distinct().toList();<br>        Function&lt;Integer, Integer&gt; getSize = i -&gt; Math.abs(cnt1.getOrDefault(i, <span class="hljs-number">0</span>) - cnt2.getOrDefault(i, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">if</span> (all.stream().anyMatch(i -&gt; (getSize.apply(i) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> all.stream().mapToInt(Integer::valueOf).min().orElseThrow() * <span class="hljs-number">2</span>;<br>        List&lt;Integer&gt; sort = all.stream().flatMapToInt(i -&gt; IntStream.generate(() -&gt; i).limit(getSize.apply(i) / <span class="hljs-number">2</span>))<br>                .boxed().sorted().toList();<br>        <span class="hljs-keyword">return</span> IntStream.range(<span class="hljs-number">0</span>, sort.size() / <span class="hljs-number">2</span>).boxed().reduce(<span class="hljs-number">0L</span>,<br>                (ans, e) -&gt; ans + Math.min(min, sort.get(e)), Long::sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6305.二进制矩阵中翻转最多一次使路径不连通</title>
    <link href="/2023/02/06/LC-6305-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%BF%BB%E8%BD%AC%E6%9C%80%E5%A4%9A%E4%B8%80%E6%AC%A1%E4%BD%BF%E8%B7%AF%E5%BE%84%E4%B8%8D%E8%BF%9E%E9%80%9A/"/>
    <url>/2023/02/06/LC-6305-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%BF%BB%E8%BD%AC%E6%9C%80%E5%A4%9A%E4%B8%80%E6%AC%A1%E4%BD%BF%E8%B7%AF%E5%BE%84%E4%B8%8D%E8%BF%9E%E9%80%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/">leetcode 中等题</a></p><p>给你一个下标从 0 开始的 m x n 二进制 矩阵 grid 。你可以从一个格子 (row, col) 移动到格子 (row + 1, col) 或者 (row, col + 1) ，前提是前往的格子值为 1 。如果从 (0, 0) 到 (m - 1, n - 1) 没有任何路径，我们称该矩阵是 不连通 的。</p><p>你可以翻转 最多一个 格子的值（也可以不翻转）。你 不能翻转 格子 (0, 0) 和 (m - 1, n - 1) 。</p><p>如果可以使矩阵不连通，请你返回 true ，否则返回 false 。</p><p>注意 ，翻转一个格子的值，可以使它的值从 0 变 1 ，或从 1 变 0 。</p><p>示例1：</p><p><img src="/../img/Snipaste_2023-02-06_17-09-31.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,1,1],[1,0,0],[1,1,1]]</span><br>输出：<span class="hljs-literal">true</span><br>解释：按照上图所示我们翻转蓝色格子里的值，翻转后从 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) 到 (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) 没有路径。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">m</span> == grid.length<br><span class="hljs-attribute">n</span> == grid[i].length<br><span class="hljs-attribute">1</span> &lt;= m, n &lt;= <span class="hljs-number">1000</span><br><span class="hljs-attribute">1</span> &lt;= m * n &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-attribute">grid</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="遍历轮廓"><a href="#遍历轮廓" class="headerlink" title="遍历轮廓"></a>遍历轮廓</h2><p>下轮廓：优先向下走，否则再向右走</p><p>右轮廓：优先向右走，否则再向下走</p><p>一个结论是：如果两个轮廓有交集（除了起点终点），那么翻转交集中的任意一个格子，都可以使矩阵不连通。</p><p>实际代码中，可以在遍历某个轮廓时，直接将该轮廓的所有点翻转，那么假设第二次出发还能到达终点，则无法使矩阵不连通。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPossibleToCutPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span>(!clean(grid, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span>[] index = queue.poll();<br>            <span class="hljs-keyword">if</span>(index[<span class="hljs-number">0</span>] == m - <span class="hljs-number">1</span> &amp;&amp; index[<span class="hljs-number">1</span>] == n - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(index[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> &lt; m &amp;&amp; grid[index[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>][index[<span class="hljs-number">1</span>]] == <span class="hljs-number">1</span>)&#123;<br>                grid[index[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>][index[<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span>;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;index[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>, index[<span class="hljs-number">1</span>]&#125;);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(index[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span> &lt; n &amp;&amp; grid[index[<span class="hljs-number">0</span>]][index[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)&#123;<br>                grid[index[<span class="hljs-number">0</span>]][index[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;index[<span class="hljs-number">0</span>], index[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">clean</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>        <span class="hljs-keyword">if</span>(y == m - <span class="hljs-number">1</span> &amp;&amp; x == n - <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        grid[y][x] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(x + <span class="hljs-number">1</span> &lt; n &amp;&amp; grid[y][x + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)&#123;   <br>            <span class="hljs-keyword">return</span> clean(grid, x + <span class="hljs-number">1</span>, y);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(y + <span class="hljs-number">1</span> &lt; m &amp;&amp; grid[y + <span class="hljs-number">1</span>][x] == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> clean(grid, x, y + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到可以通过一个通用的 $dfs$ 来满足两次遍历的需求，还可以用 $逻辑与$ 来实现优先某个方向的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] grid;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPossibleToCutPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">return</span> !dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) || !dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>        <span class="hljs-keyword">if</span>(y == m - <span class="hljs-number">1</span> &amp;&amp; x == n - <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        grid[y][x] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> (x + <span class="hljs-number">1</span> &lt; n &amp;&amp; grid[y][x + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> &amp;&amp; dfs(x + <span class="hljs-number">1</span>, y)) ||<br>                (y + <span class="hljs-number">1</span> &lt; m &amp;&amp; grid[y + <span class="hljs-number">1</span>][x] == <span class="hljs-number">1</span> &amp;&amp; dfs(x, y + <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6331.两个线段获得的最多奖品</title>
    <link href="/2023/02/05/LC-6331-%E4%B8%A4%E4%B8%AA%E7%BA%BF%E6%AE%B5%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%9A%E5%A5%96%E5%93%81/"/>
    <url>/2023/02/05/LC-6331-%E4%B8%A4%E4%B8%AA%E7%BA%BF%E6%AE%B5%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%9A%E5%A5%96%E5%93%81/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximize-win-from-two-segments/">leetcode 中等题</a></p><p>在 X轴 上有一些奖品。给你一个整数数组 prizePositions ，它按照 非递减 顺序排列，其中 prizePositions[i] 是第 i 件奖品的位置。数轴上一个位置可能会有多件奖品。再给你一个整数 k 。</p><p>你可以选择两个端点为整数的线段。每个线段的长度都必须是 k 。你可以获得位置在任一线段上的所有奖品（包括线段的两个端点）。注意，两个线段可能会有相交。</p><p>比方说 k &#x3D; 2 ，你可以选择线段 [1, 3] 和 [2, 4] ，你可以获得满足 1 &lt;&#x3D; prizePositions[i] &lt;&#x3D; 3 或者 2 &lt;&#x3D; prizePositions[i] &lt;&#x3D; 4 的所有奖品 i 。<br>请你返回在选择两个最优线段的前提下，可以获得的 最多 奖品数目。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：prizePositions = <span class="hljs-comment">[1,1,2,2,3,3,5]</span>, k = 2<br>输出：7<br>解释：这个例子中，你可以选择线段 <span class="hljs-comment">[1, 3]</span> 和 <span class="hljs-comment">[3, 5]</span> ，获得 7 个奖品。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> &lt;= prizePositions.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-attribute">1</span> &lt;= prizePositions[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br><span class="hljs-attribute">0</span> &lt;= k &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br><span class="hljs-attribute">prizePositions</span> 有序非递减。<br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>考虑只需要选择一条线段的情况，此时显然可以用双指针在 $O(N)$ 复杂度内解决，设左右指针分别为 $left、right$ 。</p><p>再考虑第二条线段如何选择，不妨设第一条线段是<strong>右边</strong>的线段。那么为了使奖品最多，第二条线段的右端点必然在 $left$ 的左边，那么我们可以预处理出一个数组 $rightPointMax$ ，其中第 $i + 1$ 位表示右端点在 $i$ 及 $i$ 左边时能取到的最大奖品。</p><p>第一条线段能取到的奖品数量为 $right - left + 1$ ，第二条线段最多能取到的数量为 $rightPointMax[left - 1 + 1]$ ，只需要枚举第一条线段的所有可能性并取 $max(right - left + 1 + rightPointMax[left - 1 + 1])$ 即为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximizeWin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">long</span>[] rightPointMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>; right &lt; n; right++)&#123;<br>            <span class="hljs-keyword">while</span>(arr[right] - arr[left] &gt; k)&#123;<br>                left++;<br>            &#125;<br>            rightPointMax[right + <span class="hljs-number">1</span>] = Math.max(rightPointMax[right], right - left + <span class="hljs-number">1</span>);<br>            ans = Math.max(ans, rightPointMax[left] + right - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>双指针/多指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-2538.最大价值和与最小价值和的差值</title>
    <link href="/2023/02/04/LC-2538-%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC%E5%92%8C%E4%B8%8E%E6%9C%80%E5%B0%8F%E4%BB%B7%E5%80%BC%E5%92%8C%E7%9A%84%E5%B7%AE%E5%80%BC/"/>
    <url>/2023/02/04/LC-2538-%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC%E5%92%8C%E4%B8%8E%E6%9C%80%E5%B0%8F%E4%BB%B7%E5%80%BC%E5%92%8C%E7%9A%84%E5%B7%AE%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/">leetcode 困难题</a></p><p>给你一个 n 个节点的无向无根图，节点编号为 0 到 n - 1 。给你一个整数 n 和一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] &#x3D; [ai, bi] 表示树中节点 ai 和 bi 之间有一条边。</p><p>每个节点都有一个价值。给你一个整数数组 price ，其中 price[i] 是第 i 个节点的价值。</p><p>一条路径的 价值和 是这条路径上所有节点的价值之和。</p><p>你可以选择树中任意一个节点作为根节点 root 。选择 root 为根的 开销 是以 root 为起点的所有路径中，价值和 最大的一条路径与最小的一条路径的差值。</p><p>请你返回所有节点作为根节点的选择中，最大 的 开销 为多少。</p><p>示例1：</p><p><img src="/../img/Snipaste_2023-02-06_17-13-51.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 6, edges = <span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[3,5]</span>]</span>, price = <span class="hljs-comment">[9,8,7,6,10,5]</span><br>输出：24<br>解释：上图展示了以节点 2 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。<br>- 第一条路径节点为 <span class="hljs-comment">[2,1,3,4]</span>：价值为 <span class="hljs-comment">[7,8,6,10]</span> ，价值和为 31 。<br>- 第二条路径节点为 <span class="hljs-comment">[2]</span> ，价值为 <span class="hljs-comment">[7]</span> 。<br>最大路径和与最小路径和的差值为 24 。24 是所有方案中的最大开销。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> &lt;= n &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-attribute">edges</span>.length == n - <span class="hljs-number">1</span><br><span class="hljs-attribute">0</span> &lt;= ai, bi &lt;= n - <span class="hljs-number">1</span><br><span class="hljs-attribute">edges</span> 表示一棵符合题面要求的树。<br><span class="hljs-attribute">price</span>.length == n<br><span class="hljs-attribute">1</span> &lt;= price[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><p>由于价值均为正数，所以最大价值路径必然是越长越好直到遇到叶子节点，反之最小价值路径则越短越好只包含根节点。</p><p>问题转换成去掉一个叶子节点后的最大价值路径（去掉的叶子节点即为所选的根节点）。</p><p>定义 $dfs(node)$ 返回 $[max1, max2]$ ，分别表示以 $node$ 为根节点的 <code>[最大不带叶子节点路径价值，最大带叶子节点路径价值]</code> ，那么 $ans$ 为 <code>max(ans, max(之前最大不带叶子节点路径 + 当前最大带叶子节点路径，之前最大带叶子节点路径 + 当前最大不带叶子节点路径))</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt;[] tree;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] price;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> ans;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxOutput</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span>[] price)</span> &#123;<br>        <span class="hljs-built_in">this</span>.tree = (List&lt;Integer&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        Arrays.setAll(tree, __ -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] e : edges)&#123;<br>            tree[e[<span class="hljs-number">0</span>]].add(e[<span class="hljs-number">1</span>]);<br>            tree[e[<span class="hljs-number">1</span>]].add(e[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.price = price;<br>        dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// [不带叶子节点路径, 带叶子节点路径]</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span>[] dfs(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> father)&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">max1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, max2 = price[node];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p : tree[node])&#123;<br>            <span class="hljs-keyword">if</span>(p == father)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">long</span>[] result = dfs(p, node);<br>            ans = Math.max(ans, Math.max(result[<span class="hljs-number">0</span>] + max2, result[<span class="hljs-number">1</span>] + max1));<br>            max1 = Math.max(max1, result[<span class="hljs-number">0</span>] + price[node]);<br>            max2 = Math.max(max2, result[<span class="hljs-number">1</span>] + price[node]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[]&#123;max1, max2&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>树形DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1632.矩阵转换后的秩</title>
    <link href="/2023/02/03/LC-1632-%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E7%A7%A9/"/>
    <url>/2023/02/03/LC-1632-%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E7%A7%A9/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/rank-transform-of-a-matrix/">leetcode 困难题</a></p><p>给你一个 m x n 的矩阵 matrix ，请你返回一个新的矩阵 answer ，其中 answer[row][col] 是 matrix[row][col] 的秩。</p><p>每个元素的 秩 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：</p><p>秩是从 1 开始的一个整数。<br>如果两个元素 p 和 q 在 同一行 或者 同一列 ，那么：<br>如果 p &lt; q ，那么 rank(p) &lt; rank(q)<br>如果 p &#x3D;&#x3D; q ，那么 rank(p) &#x3D;&#x3D; rank(q)<br>如果 p &gt; q ，那么 rank(p) &gt; rank(q)<br>秩 需要越 小 越好。<br>题目保证按照上面规则 answer 数组是唯一的。</p><p>示例1：</p><p><img src="/../img/Snipaste_2023-02-03_19-04-10.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,4]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,3]</span>]</span><br>解释：<br>matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> 的秩为 1 ，因为它是所在行和列的最小整数。<br>matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> 的秩为 2 ，因为 matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> &gt; matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> 且 matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> 的秩为 1 。<br>matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span> 的秩为 2 ，因为 matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span> &gt; matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> 且 matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> 的秩为 1 。<br>matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span> 的秩为 3 ，因为 matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span> &gt; matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span>， matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span> &gt; matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span> 且 matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> 和 matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span> 的秩都为 2 。<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="/../img/Snipaste_2023-02-03_19-04-55.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[20,-21,14]</span>,<span class="hljs-comment">[-19,4,19]</span>,<span class="hljs-comment">[22,-47,24]</span>,<span class="hljs-comment">[-19,4,19]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[4,2,3]</span>,<span class="hljs-comment">[1,3,4]</span>,<span class="hljs-comment">[5,1,6]</span>,<span class="hljs-comment">[1,3,4]</span>]</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">m == <span class="hljs-built_in">matrix</span>.<span class="hljs-built_in">length</span><br>n == <span class="hljs-built_in">matrix</span>[i].<span class="hljs-built_in">length</span><br><span class="hljs-number">1</span> &lt;= m, n &lt;= <span class="hljs-number">500</span><br>-<span class="hljs-number">10</span>^<span class="hljs-number">9</span> &lt;= <span class="hljs-built_in">matrix</span>[<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="两轮枚举"><a href="#两轮枚举" class="headerlink" title="两轮枚举"></a>两轮枚举</h2><p>首先由于题意要求 <code>秩需要越小越好。</code> ，所以我们可以先按照值大小将元素分组后排序，然后贪心的从小到大遍历这些值进行秩的维护。</p><p>设 $colMax[i]、rowMax[i]$ 分别为第 $i$ 行、列当前最大值的下标，当前遍历到的值为 $cur$ ， $cur$ 对应的点下标为 $cur_1,cur_2…cur_n$。</p><p>我们先遍历一轮 $cur$ 对应的点的集合，将这些点的秩更新为对应行&#x2F;列最大秩加一，并更新 $colMax、rowMax$ 。</p><p>第一轮遍历结束后，若这些相同值对应的任意两点，均不在同行&#x2F;同列，那么这些点的秩就正确了。</p><p>但如果这些点位于同行&#x2F;同列时，就可能会产生错误，举例来说：设某个 $cur$ 对应的第一个点下标为 $[1][2]$ ，该行该列当前最大秩为 $4$ ，将其赋给 $[1][2]$ ，此时满足题意，但假如该值对应的下一个点为 $[1][4]$ ，而因为第四列最大秩已经到了 $7$，所以 $[1][4]$ 的秩为 $7$，那么先前 $[1][2]$ 点的秩就与 $[1][4]$ 点发生了冲突，两点位于同一行，值相同，秩却不同，实际上 $[1][2]$点的秩也应该为 $7$ 。</p><p>所以我们还要进行第二轮遍历，修正由于该情况带来的错误。容易发现这些点的最终秩，都依赖&#x2F;等于对应行列的 $cur_i$ 点的最大秩。所以类似拓扑排序，我们可以从没有任何依赖（入边）的点开始处理，即最大的点，接着是该点的行列上的 $cur_i$ ，因为此时这些点的秩也变成了最大秩，也没有了依赖（入边），如此反复，直到这些点的行列上不存在 $cur_i$ ，再接着处理秩为第二大的点，直到所有点遍历结束即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] matrixRankTransform(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length, m = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 贪心, 从小到大处理</span><br>        Map&lt;Integer, List&lt;<span class="hljs-type">int</span>[]&gt;&gt; valueIndexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                valueIndexMap.computeIfAbsent(matrix[i][j], key -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;())<br>                        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] colMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] rowMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        <span class="hljs-keyword">for</span>(List&lt;<span class="hljs-type">int</span>[]&gt; indexList : valueIndexMap.values())&#123;<br>            Consumer&lt;<span class="hljs-type">int</span>[]&gt; fun = index -&gt; &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">curCol</span> <span class="hljs-operator">=</span> matrix[index[<span class="hljs-number">0</span>]][colMax[index[<span class="hljs-number">0</span>]]] == matrix[index[<span class="hljs-number">0</span>]][index[<span class="hljs-number">1</span>]] &amp;&amp; ans[index[<span class="hljs-number">0</span>]][colMax[index[<span class="hljs-number">0</span>]]] != <span class="hljs-number">0</span> ? ans[index[<span class="hljs-number">0</span>]][colMax[index[<span class="hljs-number">0</span>]]] : ans[index[<span class="hljs-number">0</span>]][colMax[index[<span class="hljs-number">0</span>]]] + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">curRow</span> <span class="hljs-operator">=</span> matrix[rowMax[index[<span class="hljs-number">1</span>]]][index[<span class="hljs-number">1</span>]] == matrix[index[<span class="hljs-number">0</span>]][index[<span class="hljs-number">1</span>]] &amp;&amp; ans[rowMax[index[<span class="hljs-number">1</span>]]][index[<span class="hljs-number">1</span>]] != <span class="hljs-number">0</span> ? ans[rowMax[index[<span class="hljs-number">1</span>]]][index[<span class="hljs-number">1</span>]] : ans[rowMax[index[<span class="hljs-number">1</span>]]][index[<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>;<br>                ans[index[<span class="hljs-number">0</span>]][index[<span class="hljs-number">1</span>]] = Math.max(curCol, curRow);<br>                colMax[index[<span class="hljs-number">0</span>]] = index[<span class="hljs-number">1</span>];<br>                rowMax[index[<span class="hljs-number">1</span>]] = index[<span class="hljs-number">0</span>];<br>            &#125;;<br>            <span class="hljs-comment">// 第一轮, 初始化成当前行列的最大值或最大值加一</span><br>            <span class="hljs-comment">// 此时可能会出现同一行/列的相同值, 它们的秩且不相同的情况</span><br>            indexList.forEach(fun);<br>            Map&lt;Integer, List&lt;<span class="hljs-type">int</span>[]&gt;&gt; groupByCol = indexList.stream().collect(Collectors.groupingBy(index -&gt; index[<span class="hljs-number">0</span>]));<br>            Map&lt;Integer, List&lt;<span class="hljs-type">int</span>[]&gt;&gt; groupByRow = indexList.stream().collect(Collectors.groupingBy(index -&gt; index[<span class="hljs-number">1</span>]));<br>            <span class="hljs-type">int</span>[] visitCol = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-type">int</span>[] visitRow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>            <span class="hljs-comment">// 第二轮, 类似拓扑排序, 从最大的秩的点开始再次处理, 接着是该点同行同列同值的下标, 再接着是较小秩的点</span><br>            Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>            List&lt;<span class="hljs-type">int</span>[]&gt; sortByAns = indexList.stream()<br>                                        .sorted((a, b) -&gt; ans[b[<span class="hljs-number">0</span>]][b[<span class="hljs-number">1</span>]] - ans[a[<span class="hljs-number">0</span>]][a[<span class="hljs-number">1</span>]]).toList();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">queueCnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(queueCnt &lt; indexList.size())&#123;<br>                <span class="hljs-keyword">if</span>(queue.isEmpty())&#123;<br>                    <span class="hljs-keyword">while</span>(queueCnt &lt; indexList.size() &amp;&amp; visitCol[sortByAns.get(queueCnt)[<span class="hljs-number">0</span>]] == <span class="hljs-number">1</span> <br>                                                    &amp;&amp; visitRow[sortByAns.get(queueCnt)[<span class="hljs-number">1</span>]] == <span class="hljs-number">1</span>)&#123;<br>                        queueCnt++;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(queueCnt &gt;= indexList.size())&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-type">int</span>[] a = sortByAns.get(queueCnt++);<br>                    queue.offer(a);<br>                &#125;<br>                <span class="hljs-type">int</span>[] item = queue.poll();<br>                <span class="hljs-keyword">if</span>(visitCol[item[<span class="hljs-number">0</span>]] != <span class="hljs-number">1</span>)&#123;<br>                    groupByCol.get(item[<span class="hljs-number">0</span>]).forEach(index -&gt; &#123;<br>                        fun.accept(index);<br>                        <span class="hljs-keyword">if</span>(visitRow[index[<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>)&#123;<br>                            queue.offer(index);<br>                        &#125;<br>                    &#125;);<br>                    visitCol[item[<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(visitRow[item[<span class="hljs-number">1</span>]] != <span class="hljs-number">1</span>)&#123;<br>                    groupByRow.get(item[<span class="hljs-number">1</span>]).forEach(index -&gt; &#123;<br>                        fun.accept(index);<br>                        <span class="hljs-keyword">if</span>(visitCol[index[<span class="hljs-number">0</span>]] == <span class="hljs-number">0</span>)&#123;<br>                            queue.offer(index);<br>                        &#125;<br>                    &#125;);<br>                    visitRow[item[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>上面解法的代码过于复杂，一种更自然的做法是使用并查集来维护元素间的依赖关系。</p><p>就如上面所说</p><blockquote><p>容易发现这些点的最终秩，都依赖&#x2F;等于对应行列的 $cur_i$ 点的最大秩</p></blockquote><p>所以我们可以将这些相同值的同行&#x2F;同列的点，进行连通，此时就能很容易的维护出一个连通块的秩，为该连通块所有点的秩。</p><p>稍微要注意的是，初始化一个并查集的时间复杂度为 $O(n + m)$ ，如果所有点的值均不相同，时间复杂度约为 $O(n \times m \times (n + m))$ ，所以我们可以只初始化一个并查集，而在对于某个值循环结束时，清空对应点的连通即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] matrixRankTransform(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length, m = matrix[<span class="hljs-number">0</span>].length;<br>        Map&lt;Integer, List&lt;<span class="hljs-type">int</span>[]&gt;&gt; valueIndexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                valueIndexMap.computeIfAbsent(matrix[i][j], key -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;())<br>                        .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] colMaxRank = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] rowMaxRank = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        <span class="hljs-type">UnionFind</span> <span class="hljs-variable">union</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(n + m);<br>        <span class="hljs-keyword">for</span>(List&lt;<span class="hljs-type">int</span>[]&gt; indexList : valueIndexMap.values())&#123;<br>            <span class="hljs-comment">// 连通</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] index : indexList)&#123;<br>                union.union(index[<span class="hljs-number">0</span>], index[<span class="hljs-number">1</span>] + n);<br>            &#125;<br>            <span class="hljs-comment">// 维护秩</span><br>            <span class="hljs-type">int</span>[] rank = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + m];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] index : indexList)&#123;<br>                rank[union.find(index[<span class="hljs-number">0</span>])] = Math.max(rank[union.find(index[<span class="hljs-number">0</span>])], Math.max(colMaxRank[index[<span class="hljs-number">0</span>]], rowMaxRank[index[<span class="hljs-number">1</span>]]));<br>            &#125;<br>            <span class="hljs-comment">// 维护 ans</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] index : indexList)&#123;<br>                ans[index[<span class="hljs-number">0</span>]][index[<span class="hljs-number">1</span>]] = rank[union.find(index[<span class="hljs-number">0</span>])] + <span class="hljs-number">1</span>;<br>                colMaxRank[index[<span class="hljs-number">0</span>]] = ans[index[<span class="hljs-number">0</span>]][index[<span class="hljs-number">1</span>]];<br>                rowMaxRank[index[<span class="hljs-number">1</span>]] = ans[index[<span class="hljs-number">0</span>]][index[<span class="hljs-number">1</span>]];<br>            &#125;<br>            indexList.forEach(index -&gt; &#123;<br>                union.clear(index[<span class="hljs-number">0</span>]);<br>                union.clear(index[<span class="hljs-number">1</span>] + n);<br>            &#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] fa;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        fa = IntStream.range(<span class="hljs-number">0</span>, n).toArray();<br>        size = IntStream.generate(() -&gt; <span class="hljs-number">1</span>).limit(n).toArray();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        a = find(a);<br>        b = find(b);<br>        <span class="hljs-keyword">if</span>(a == b)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(size[a] &lt; size[b])&#123;<br>            a = a ^ b;<br>            b = a ^ b;<br>            a = a ^ b;<br>        &#125;<br>        fa[b] = a;<br>        size[a] += size[b];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>        <span class="hljs-keyword">if</span>(a != fa[a])&#123;<br>            fa[a] = find(fa[a]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> fa[a];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>        fa[a] = a;<br>        size[a] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>复杂模拟</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1815.得到新鲜甜甜圈的最多组数</title>
    <link href="/2023/02/01/LC-1815-%E5%BE%97%E5%88%B0%E6%96%B0%E9%B2%9C%E7%94%9C%E7%94%9C%E5%9C%88%E7%9A%84%E6%9C%80%E5%A4%9A%E7%BB%84%E6%95%B0/"/>
    <url>/2023/02/01/LC-1815-%E5%BE%97%E5%88%B0%E6%96%B0%E9%B2%9C%E7%94%9C%E7%94%9C%E5%9C%88%E7%9A%84%E6%9C%80%E5%A4%9A%E7%BB%84%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximum-number-of-groups-getting-fresh-donuts/">leetcode 困难题</a></p><p>有一个甜甜圈商店，每批次都烤 batchSize 个甜甜圈。这个店铺有个规则，就是在烤一批新的甜甜圈时，之前 所有 甜甜圈都必须已经全部销售完毕。给你一个整数 batchSize 和一个整数数组 groups ，数组中的每个整数都代表一批前来购买甜甜圈的顾客，其中 groups[i] 表示这一批顾客的人数。每一位顾客都恰好只要一个甜甜圈。</p><p>当有一批顾客来到商店时，他们所有人都必须在下一批顾客来之前购买完甜甜圈。如果一批顾客中第一位顾客得到的甜甜圈不是上一组剩下的，那么这一组人都会很开心。</p><p>你可以随意安排每批顾客到来的顺序。请你返回在此前提下，最多 有多少组人会感到开心。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：batchSize = <span class="hljs-number">3</span>, groups = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-number">4</span><br>解释：你可以将这些批次的顾客顺序安排为 [<span class="hljs-number">6,2,4,5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 。那么第 <span class="hljs-number">1，2，4，6</span> 组都会感到开心。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= batchSize &lt;= <span class="hljs-number">9</span><br><span class="hljs-symbol">1 </span>&lt;= groups.length &lt;= <span class="hljs-number">30</span><br><span class="hljs-symbol">1 </span>&lt;= groups[i] &lt;= <span class="hljs-number">109</span><br></code></pre></td></tr></table></figure><h2 id="状态压缩-记忆化搜索"><a href="#状态压缩-记忆化搜索" class="headerlink" title="状态压缩 + 记忆化搜索"></a>状态压缩 + 记忆化搜索</h2><p>设第 $i$ 批顾客的数量对 $batchSize$ 取模后的结果为 $mod_i$，如果 $(mod_0 + mod_1 + … + mod_i) \% batchSize &#x3D; 0$ ，那么该批顾客就是开心的，也就是说其实我们只需要关心每批顾客数量对 $batchSize$ 取模后的结果即可。</p><p>于是我们可以先预处理出 $group[i] \%&#x3D; batchSize$ ，这样一来 $group[i]$ 数量范围缩小到了 $1-9$ ，接着我们再对相同的 $group[i]$ 分为一组进行计数，设计数结果为 $cnt0,cnt1…cnt9$ ，并设 $si &#x3D; cnt_i*i$ （这里的 $i$ 不是 $group$ 下标而是分组后的下标，也就是 $1-9$）。</p><p>设 $f(s0,s1,…s9)$ 为当 $group$ 取模分组后结果为 $s0, s1…s9$ 时能取到的最大开心组数。如上所说</p><blockquote><p>如果 $(mod_0 + mod_1 + … + mod_i) \% batchSize&#x3D;&#x3D; 0$ ，那么该批顾客就是开心的。</p></blockquote><p>由此可以得出，设 <strong>最后一组</strong> 顾客为 $i$，状态转移方程为：</p><p>$$<br>\begin{align}<br>&amp;f(s0…si…s9) &#x3D; f(s0…si - i…s9)　　　　　if　(s0 + s1 + … si - i + s9) \% batchSize !&#x3D; 0 \\<br>&amp;f(s0…si…s9) &#x3D; f(s0…si - i…s9)+ 1　　　if　(s0 + s1 + … si - i + s9) \% batchSize &#x3D;&#x3D; 0 \\<br>\end{align}<br>$$</p><p>剩下问题就是如何表示出 $s0,s1…s9$ 了，一种方法是开九维数组，过于复杂。</p><p>注意到 $1 &lt;&#x3D; groups.length &lt;&#x3D; 30$ ，也就是说 $si$ 均小于 $30$ ，我们可以用 $5$ 个二进制来存储一个 $si$，而 $s0$ 可以不处理，因为只需要将 $mod_0$ 的顾客最先处理，那么他们都是开心的，此时只需要将答案加上 $cnt_0$ 即可。所以我们总共需要 $8 * 5 &#x3D; 40$ 个二进制就可以表示出状态，也就是一个 $long$ 类型。</p><p>具体求解时，可以采用记忆化搜索的方式，答案为当最后一组顾客为 $1…9$ 时所转移出来的最大值再加上 $cnt0$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Long, Integer&gt; memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> batchSize;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxHappyGroups</span><span class="hljs-params">(<span class="hljs-type">int</span> batchSize, <span class="hljs-type">int</span>[] groups)</span> &#123;<br>        <span class="hljs-built_in">this</span>.batchSize = batchSize;<br>        <span class="hljs-type">long</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[batchSize]; <span class="hljs-comment">// long 数组，或者在下面移位时强转 long, 否则移位时会&quot;溢出&quot;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> group : groups) &#123;<br>            cnt[group % batchSize]++;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; batchSize; i++) &#123;<br>            mask |= (cnt[i] &lt;&lt; (<span class="hljs-number">5</span> * (i - <span class="hljs-number">1</span>)));<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(mask) + (<span class="hljs-type">int</span>)cnt[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">long</span> mask)</span> &#123;<br>        <span class="hljs-keyword">if</span> (memo.containsKey(mask)) &#123;<br>            <span class="hljs-keyword">return</span> memo.get(mask);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; batchSize; i++) &#123;<br>            total += ((mask &gt;&gt; (<span class="hljs-number">5</span> * (i - <span class="hljs-number">1</span>))) &amp; (<span class="hljs-number">0b11111</span>)) * i;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; batchSize; i++) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">curCnt</span> <span class="hljs-operator">=</span> ((mask &gt;&gt; (<span class="hljs-number">5</span> * (i - <span class="hljs-number">1</span>))) &amp; (<span class="hljs-number">0b11111</span>));<br>            <span class="hljs-keyword">if</span> (curCnt &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dfs(mask - (<span class="hljs-number">1L</span> &lt;&lt; (<span class="hljs-number">5</span> * (i - <span class="hljs-number">1</span>)))); <span class="hljs-comment">// 注意是 1L，否则移位时会&quot;溢出&quot;</span><br>            <span class="hljs-keyword">if</span> ((total - i) % batchSize == <span class="hljs-number">0</span>) &#123;<br>                pre++;<br>            &#125;<br>            max = Math.max(max, pre);<br>        &#125;<br>        memo.put(mask, max);<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h2><p>另一种解法是 <a href="https://oi-wiki.org/misc/simulated-annealing/">模拟退火</a> ，随机交换两个下标，当代价更优时必定接受，否则以一定概率接受，当起始温度小于终止温度时得到一个最优解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; groupList;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> batchSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> ans;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxHappyGroups</span><span class="hljs-params">(<span class="hljs-type">int</span> batchSize, <span class="hljs-type">int</span>[] groups)</span> &#123;<br>        <span class="hljs-built_in">this</span>.batchSize = batchSize;<br>        groupList = Arrays.stream(groups).boxed().collect(Collectors.toList());<br>        n = groupList.size();<br>        Collections.shuffle(groupList);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">35</span>; i++)&#123;<br>            simulateAnneal();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simulateAnneal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">500000</span>; t &gt; <span class="hljs-number">1e-8</span>; t *= <span class="hljs-number">0.99</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> r.nextInt(Integer.MAX_VALUE) % n, b = r.nextInt(Integer.MAX_VALUE) % n;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> calc();<br>            swap(a, b);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> calc();<br>            <span class="hljs-type">double</span> <span class="hljs-variable">delta</span> <span class="hljs-operator">=</span> start - end;<br>            <span class="hljs-keyword">if</span> (Math.exp(-delta / t) &gt; r.nextDouble()) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            swap(a, b);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span>(pre == <span class="hljs-number">0</span>)&#123;<br>                ret++;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> groupList.get(i);<br>            <span class="hljs-keyword">if</span>(cur &lt; pre)&#123;<br>                pre -= cur;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            cur = (cur - pre) % batchSize;<br>            pre = cur == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : batchSize - cur;<br>        &#125;<br>        ans = Math.max(ans, ret);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a == b) <span class="hljs-keyword">return</span>;<br>        groupList.set(a, groupList.get(a) ^ groupList.get(b));<br>        groupList.set(b, groupList.get(a) ^ groupList.get(b));<br>        groupList.set(a, groupList.get(a) ^ groupList.get(b));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
      <tag>状态压缩</tag>
      
      <tag>模拟退火</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-2552.统计上升四元组</title>
    <link href="/2023/01/31/LC-2552-%E7%BB%9F%E8%AE%A1%E4%B8%8A%E5%8D%87%E5%9B%9B%E5%85%83%E7%BB%84/"/>
    <url>/2023/01/31/LC-2552-%E7%BB%9F%E8%AE%A1%E4%B8%8A%E5%8D%87%E5%9B%9B%E5%85%83%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/count-increasing-quadruplets/">leetcode 困难题</a></p><p>给你一个长度为 n 下标从 0 开始的整数数组 nums ，它包含 1 到 n 的所有数字，请你返回上升四元组的数目。</p><p>如果一个四元组 (i, j, k, l) 满足以下条件，我们称它是上升的：</p><ul><li>0 &lt;&#x3D; i &lt; j &lt; k &lt; l &lt; n 且</li><li>nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。</li></ul><p>示例1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[1,3,2,4,5]</span><br>输出：<span class="hljs-number">2</span><br>解释：<br>- 当 <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span> ，j = <span class="hljs-number">1</span> ，k = <span class="hljs-number">2</span> 且 l = <span class="hljs-number">3</span> 时，有 nums<span class="hljs-selector-attr">[i]</span> &lt; nums<span class="hljs-selector-attr">[k]</span> &lt; nums<span class="hljs-selector-attr">[j]</span> &lt; nums<span class="hljs-selector-attr">[l]</span> 。<br>- 当 <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span> ，j = <span class="hljs-number">1</span> ，k = <span class="hljs-number">2</span> 且 l = <span class="hljs-number">4</span> 时，有 nums<span class="hljs-selector-attr">[i]</span> &lt; nums<span class="hljs-selector-attr">[k]</span> &lt; nums<span class="hljs-selector-attr">[j]</span> &lt; nums<span class="hljs-selector-attr">[l]</span> 。<br>没有其他的四元组，所以我们返回 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">4</span> &lt;<span class="hljs-operator">=</span> nums.length &lt;<span class="hljs-operator">=</span> <span class="hljs-number">4000</span><br><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> <br>nums 中所有数字 互不相同 ，nums 是一个排列。<br></code></pre></td></tr></table></figure><h2 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h2><p>注意到 $nums[i] &lt;&#x3D; nums.length &lt;&#x3D; 4000$ ，也就是说 $O(N^2)$ 算法的运算次数约为 $4000 * 4000 &#x3D; 1.6*10^7$，已经比较高了，并且需要多次 $N^2$ 循环，一不小心就会被卡常。</p><p>需要注意以下两点，否则在 Java 上很可能会 TLE 。 </p><ol><li>固定初始化一个 $[4000][4000]$ 的数组所花费的时间要比直觉上更长，更合理的做法是根据 $nums$ 的长度动态初始化，否则就算不会在某个用例上超时也很大可能会在所有用例的总用时上超时。</li><li>$(j,k)$ 数对的上限约为 $4000*4000$ 的数量级，这部分的空间消耗完全可以避免，没必要预先保存这些数对而是在最后进行枚举，否则可能会 OOM 。</li></ol><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><p>由于是四元组，所以我们先可以枚举出中间两个数 $(j,k)$ 的可能，然后</p><ul><li>设 $less[j][nums[k]]$ 表示下标小于等于 $j$ ，值小于等于 $nums[k]$ 的元素个数。</li><li>设 $large[k][nums[j]]$ 表示下标大于等于 $k$ ，值小于等于 $nums[j]$ 的元素个数</li></ul><p>那么对于该 $(j,k)$ ，可能的四元组个数就为 $less[j - 1][nums[k] - 1] \times large[k + 1][nums[j] + 1]$。</p><p>而对于 $less$ 和 $large$ 数组的维护，一种比较无脑暴力的做法是二维差分，时间复杂度为 $O(N^2)$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countQuadruplets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[][] less = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">3</span>][n + <span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span>[][] large = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">3</span>][n + <span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123; <br>            less[i + <span class="hljs-number">1</span>][nums[i] + <span class="hljs-number">1</span>]++;<br>            less[i + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span> + <span class="hljs-number">1</span>]--;<br>            less[n + <span class="hljs-number">1</span> + <span class="hljs-number">1</span>][nums[i] + <span class="hljs-number">1</span>]--;<br>            less[n + <span class="hljs-number">1</span> + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span> + <span class="hljs-number">1</span>]++;<br><br>            large[<span class="hljs-number">0</span> + <span class="hljs-number">1</span>][<span class="hljs-number">0</span> + <span class="hljs-number">1</span>]++;<br>            large[<span class="hljs-number">0</span> + <span class="hljs-number">1</span>][nums[i] + <span class="hljs-number">1</span> + <span class="hljs-number">1</span>]--;<br>            large[i + <span class="hljs-number">1</span> + <span class="hljs-number">1</span>][<span class="hljs-number">0</span> + <span class="hljs-number">1</span>]--;<br>            large[i + <span class="hljs-number">1</span> + <span class="hljs-number">1</span>][nums[i] + <span class="hljs-number">1</span> + <span class="hljs-number">1</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">3</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n + <span class="hljs-number">3</span>; j++)&#123;<br>                less[i][j] += less[i][j - <span class="hljs-number">1</span>] + less[i - <span class="hljs-number">1</span>][j] - less[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                large[i][j] += large[i][j - <span class="hljs-number">1</span>] + large[i - <span class="hljs-number">1</span>][j] - large[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125; <br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; n; k++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[k] &lt; nums[j])&#123;<br>                    ans += less[j - <span class="hljs-number">1</span> + <span class="hljs-number">1</span>][nums[k] - <span class="hljs-number">1</span> + <span class="hljs-number">1</span>] * large[k + <span class="hljs-number">1</span> + <span class="hljs-number">1</span>][nums[j] + <span class="hljs-number">1</span> + <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p>类似二维差分，也可以使用一维差分来维护 $less$ 和 $large$ ，这种解法不仅逻辑更简单而且也不容易写错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countQuadruplets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[][] less = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[][] large = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123; <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j &gt;= i)&#123;<br>                    less[j][nums[i]]++;<br>                    less[j][n + <span class="hljs-number">1</span>]--; <span class="hljs-comment">// unnecessary</span><br>                &#125;<br>                <span class="hljs-keyword">if</span>(j &lt;= i)&#123;<br>                    large[j][<span class="hljs-number">0</span>]++;<br>                    large[j][nums[i] + <span class="hljs-number">1</span>]--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n + <span class="hljs-number">2</span>; j++)&#123;<br>                less[i][j] += less[i][j - <span class="hljs-number">1</span>];<br>                large[i][j] += large[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125; <br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; n; k++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[k] &lt; nums[j])&#123;<br>                    ans += less[j - <span class="hljs-number">1</span>][nums[k] - <span class="hljs-number">1</span>] * large[k + <span class="hljs-number">1</span>][nums[j] + <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举-x2F-前缀和"><a href="#枚举-x2F-前缀和" class="headerlink" title="枚举&#x2F;前缀和"></a>枚举&#x2F;前缀和</h2><p>另一种解法是利用类似前缀和的思想。</p><ul><li>对于 $large$ 数组的维护，我们可以逆序遍历 $nums$ ，因为对于某个 $large[i][]$ 显然都是在 $large[i + 1][]$ 的基础上进行递增，所以只需要先复制 $large[i + 1]$ 再循环 $nums[i]$ 次即可，可以控制在 $O(N^2)$ 的复杂度内。</li><li>对于 $less$ 数组的维护，我们顺序遍历 $nums$ ，类似于 $large$ ，$less[i][]$ 都是在 $less[i - 1][]$ 的基础上递增，所以我们能够保证当前 $less[i][]$ 的正确性，而对于 $less$ 数组的之前行，由于不会再使用到，所以不维护也没有关系。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countQuadruplets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[][] large = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            large[i] = large[i + <span class="hljs-number">1</span>].clone();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt;= nums[i]; x++)&#123;<br>                large[i][x]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] less = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">1</span>)&#123;<br>                less[j] = less[j - <span class="hljs-number">1</span>].clone();<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[j]; x &lt;= n; x++)&#123;<br>                less[j][x]++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; n; k++)&#123;<br>                <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k] &lt; nums[j])&#123;<br>                    ans += less[j - <span class="hljs-number">1</span>][nums[k] - <span class="hljs-number">1</span>] * large[k + <span class="hljs-number">1</span>][nums[j] + <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="枚举优化"><a href="#枚举优化" class="headerlink" title="枚举优化"></a>枚举优化</h2><p>由于 $less$ 数组只会使用到当前行，类似滚动数组，我们可以将其优化成一维数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java">...<br>        <span class="hljs-type">int</span>[] less = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; n; k++)&#123;<br>                <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k] &lt; nums[j])&#123;<br>                    ans += less[nums[k] - <span class="hljs-number">1</span>] * large[k + <span class="hljs-number">1</span>][nums[j] + <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125; <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[j]; x &lt;= n; x++)&#123;<br>                less[x]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>...<br></code></pre></td></tr></table></figure><p>甚至可以不需要 $less$ 数组，我们利用 $large$ 数组和 $nums$ 是一个排列的特性来间接得出某个下标左边比某个值更小的元素个数。</p><p>对于数组 $(j,k)$，可以先通过 $large[j][nums[k]]$ 得到 $j$ 右边（当然也包括 $j$）大于等于 $nums[k]$ 的元素个数，而 $j$ 右边一共有 $n - j$ 个数， 也就是说 $j$ 右边比 $j$ 小的元素个数为 $n - j - large[j][nums[k]]$，又因为 $nums$ 是一个排列，所以小于 $nums[k]$ 的数一共有 $nums[k] - 1$ 个，那么 $j$ 左边小于 $nums[k]$ 的元素个数就为</p><p>$$<br>\begin{align}<br>nums[k] - 1 - (n - j - large[j][nums[k]])<br>\end{align}<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countQuadruplets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[][] large = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            large[i] = large[i + <span class="hljs-number">1</span>].clone();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt;= nums[i]; x++)&#123;<br>                large[i][x]++;<br>            &#125;<br>        &#125; <br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; n; k++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[k] &lt; nums[j])&#123;<br>                    ans += large[k + <span class="hljs-number">1</span>][nums[j] + <span class="hljs-number">1</span>] * (nums[k] - <span class="hljs-number">1</span> - (n - j - large[j][nums[k]]));<br>                &#125;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>另一种枚举的思路，也是类似前缀和的思想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// https://leetcode.cn/u/arignote/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countQuadruplets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length][nums.length], right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length][nums.length];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>left[j + <span class="hljs-number">1</span>][i] = left[j][i] + (nums[j] &lt; nums[i] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; j &gt; i; j--) &#123;<br>right[i][j - <span class="hljs-number">1</span>] = right[i][j] + (nums[j] &gt; nums[i] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>count += nums[i] &gt; nums[j] ? left[i + <span class="hljs-number">1</span>][j] * right[i][j - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1143.最长公共子序列</title>
    <link href="/2023/01/20/LC-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2023/01/20/LC-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/longest-common-subsequence/">leetcode 中等题</a></p><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;ace&quot;</span> <br>输出：<span class="hljs-number">3</span>  <br>解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1</span> &lt;= text1.<span class="hljs-built_in">length</span>, text2.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">1000</span><br>text1 和 text2 仅由小写英文字符组成。<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>定义 $dp[i][j]$ 表示 $text1(0…i)$ 和 $text2(0…j)$ 的 $LCA$ ，简略的状态转移方程如下：</p><p>$$<br>\begin{align}<br>&amp;dp[i][j] &#x3D; dp[i-1][j-1] + 1　　　　　　　　　　　　　　　　text1[i]&#x3D;&#x3D;text2[j]　　　　 \\<br>&amp;dp[i][j] &#x3D; max(dp[i][j-1], dp[i-1][j])　　　　 　　　　　　　otherwise \\<br>\end{align}<br>$$</p><p>$dp[n][m]$ 为答案，$n$ 、 $m$ 分别为两个字符串的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> text1.length(), m = text2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; m + <span class="hljs-number">1</span>; j++)&#123;<br>                <span class="hljs-keyword">if</span>(text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = Math.max(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="滚动数组优化"><a href="#滚动数组优化" class="headerlink" title="滚动数组优化"></a>滚动数组优化</h2><p>上面解法的空间复杂度为 $O(nm)$，由于每个状态最多往前依赖一行，所以可以使用滚动数组将空间复杂度优化到 $O(min(n, m))$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-comment">// Not implemented, if text1.length() &lt; text2.length(), then swap text1 and text2</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> text1.length(), m = text2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; m + <span class="hljs-number">1</span>; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">curi</span> <span class="hljs-operator">=</span> i &amp; <span class="hljs-number">1</span>, prei = curi ^ <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                    dp[curi][j] = dp[prei][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[curi][j] = Math.max(dp[curi][j - <span class="hljs-number">1</span>], dp[prei][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n &amp; <span class="hljs-number">1</span>][m];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-2536.子矩阵元素加1</title>
    <link href="/2023/01/17/LC-2536-%E5%AD%90%E7%9F%A9%E9%98%B5%E5%85%83%E7%B4%A0%E5%8A%A01/"/>
    <url>/2023/01/17/LC-2536-%E5%AD%90%E7%9F%A9%E9%98%B5%E5%85%83%E7%B4%A0%E5%8A%A01/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/increment-submatrices-by-one/">leetcode 中等题</a></p><p>给你一个正整数 n ，表示最初有一个 n x n 、下标从 0 开始的整数矩阵 mat ，矩阵中填满了 0 。</p><p>另给你一个二维整数数组 query 。针对每个查询 query[i] &#x3D; [row1i, col1i, row2i, col2i] ，请你执行下述操作：</p><p>找出 左上角 为 (row1i, col1i) 且 右下角 为 (row2i, col2i) 的子矩阵，将子矩阵中的 每个元素 加 1 。也就是给所有满足 row1i &lt;&#x3D; x &lt;&#x3D; row2i 和 col1i &lt;&#x3D; y &lt;&#x3D; col2i 的 mat[x][y] 加 1 。<br>返回执行完所有操作后得到的矩阵 mat 。</p><p><img src="/../img/Snipaste_2023-01-17_01-55-33.png"></p><p>示例1：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span>, queries = <span class="hljs-string">[[1,1,2,2],[0,0,1,1]]</span><br>输出：<span class="hljs-string">[[1,1,0],[1,2,1],[0,1,1]]</span><br>解释：上图所展示的分别是：初始矩阵、执行完第一个操作后的矩阵、执行完第二个操作后的矩阵。<br>- 第一个操作：将左上角为 (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) 且右下角为 (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) 的子矩阵中的每个元素加 <span class="hljs-number">1</span> 。 <br>- 第二个操作：将左上角为 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) 且右下角为 (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) 的子矩阵中的每个元素加 <span class="hljs-number">1</span> 。 <br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= n &lt;= <span class="hljs-number">500</span><br><span class="hljs-symbol">1 </span>&lt;= queries.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-symbol">0 </span>&lt;= row1i &lt;= row2i &lt; n<br><span class="hljs-symbol">0 </span>&lt;= col1i &lt;= col2i &lt; n<br></code></pre></td></tr></table></figure><h2 id="多次一维差分"><a href="#多次一维差分" class="headerlink" title="多次一维差分"></a>多次一维差分</h2><p>暴力解法的时间复杂度为 $O(n^2 \times queries.length)$ ， 上限为 $500 \times 500 \times 10^4 \approx 10 ^ 9$，显然会 TLE 。</p><p>一种做法是通过多次的一维 <a href="https://oi-wiki.org/basic/prefix-sum/#%E5%B7%AE%E5%88%86">差分</a> 来加速对矩阵某行的加一，此时的时间复杂度为 $O(n \times queries.length + n^2)$ ，上限为 $500 \times 10 ^4 \approx 10^6$ ，符合要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] rangeAddQueries(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] item : queries)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> item[<span class="hljs-number">0</span>]; i &lt;= item[<span class="hljs-number">2</span>]; i++)&#123;<br>                a[i][item[<span class="hljs-number">1</span>]]++;<br>                <span class="hljs-keyword">if</span>(item[<span class="hljs-number">3</span>] + <span class="hljs-number">1</span> &lt; n)&#123;<br>                    a[i][item[<span class="hljs-number">3</span>] + <span class="hljs-number">1</span>]--;<br>                &#125; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                a[i][j] += a[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><p>一种更优的做法是 <a href="https://www.acwing.com/blog/content/5890/">二维差分</a>。</p><p>为了方便，初始化差分数组大小为 $[n + 2][n + 2]$，其中一次加 $1$ 是为了避免特判差分修正时的下标溢出；另一次加 $1$ 是为了避免特判做 <a href="https://oi-wiki.org/basic/prefix-sum/#%E4%BA%8C%E7%BB%B4%E5%A4%9A%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">二维前缀和</a> 时下标为负数的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] rangeAddQueries(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span>[][] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] item : queries)&#123;<br>            a[item[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>][item[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>]++;<br>            a[item[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>][item[<span class="hljs-number">3</span>] + <span class="hljs-number">2</span>]--;<br>            a[item[<span class="hljs-number">2</span>] + <span class="hljs-number">2</span>][item[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>]--;<br>            a[item[<span class="hljs-number">2</span>] + <span class="hljs-number">2</span>][item[<span class="hljs-number">3</span>] + <span class="hljs-number">2</span>]++;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>                a[i][j] += a[i - <span class="hljs-number">1</span>][j] + a[i][j - <span class="hljs-number">1</span>] - a[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                ans[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] = a[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1803.统计异或值在范围内的数对有多少</title>
    <link href="/2023/01/12/LC-1803-%E7%BB%9F%E8%AE%A1%E5%BC%82%E6%88%96%E5%80%BC%E5%9C%A8%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E6%95%B0%E5%AF%B9%E6%9C%89%E5%A4%9A%E5%B0%91/"/>
    <url>/2023/01/12/LC-1803-%E7%BB%9F%E8%AE%A1%E5%BC%82%E6%88%96%E5%80%BC%E5%9C%A8%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E6%95%B0%E5%AF%B9%E6%9C%89%E5%A4%9A%E5%B0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/">leetcode 困难题</a></p><p>给你一个整数数组 nums （下标 从 0 开始 计数）以及两个整数：low 和 high ，请返回 漂亮数对 的数目。</p><p>漂亮数对 是一个形如 (i, j) 的数对，其中 0 &lt;&#x3D; i &lt; j &lt; nums.length 且 low &lt;&#x3D; (nums[i] XOR nums[j]) &lt;&#x3D; high 。</p><p>示例1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[1,4,2,7]</span>, low = <span class="hljs-number">2</span>, high = <span class="hljs-number">6</span><br>输出：<span class="hljs-number">6</span><br>解释：所有漂亮数对 (<span class="hljs-selector-tag">i</span>, j) 列出如下：<br>    - (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>): nums<span class="hljs-selector-attr">[0]</span> XOR nums<span class="hljs-selector-attr">[1]</span> = <span class="hljs-number">5</span> <br>    - (<span class="hljs-number">0</span>, <span class="hljs-number">2</span>): nums<span class="hljs-selector-attr">[0]</span> XOR nums<span class="hljs-selector-attr">[2]</span> = <span class="hljs-number">3</span><br>    - (<span class="hljs-number">0</span>, <span class="hljs-number">3</span>): nums<span class="hljs-selector-attr">[0]</span> XOR nums<span class="hljs-selector-attr">[3]</span> = <span class="hljs-number">6</span><br>    - (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>): nums<span class="hljs-selector-attr">[1]</span> XOR nums<span class="hljs-selector-attr">[2]</span> = <span class="hljs-number">6</span><br>    - (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>): nums<span class="hljs-selector-attr">[1]</span> XOR nums<span class="hljs-selector-attr">[3]</span> = <span class="hljs-number">3</span><br>    - (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>): nums<span class="hljs-selector-attr">[2]</span> XOR nums<span class="hljs-selector-attr">[3]</span> = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">2</span> * <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span>&lt;= nums[i] &lt;= <span class="hljs-number">2</span> * <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span>&lt;= low &lt;= high &lt;= <span class="hljs-number">2</span> * <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="01字典树"><a href="#01字典树" class="headerlink" title="01字典树"></a>01字典树</h2><p>题目要求的是异或值在 $[low, high]$ 区间的数对数量，设 $f(x)$ 表示异或值在 $[0, x]$ 区间的数对数量，那么通过容斥原理原问题可以转换成求 $f(high) - f(low - 1)$ 。</p><p>“对于数组异或计数问题，我们通常可以使用01字典树来解决”</p><p>01字典树的定义类似字典树，不同的是01字典树的子节点只存在 $0$、$1$ 结点两种可能，分别代表二进制位的 $0$、$1$，并按照从高位到低位的顺序存储一个数的二进制，即根节点存储最高位的二进制，且通过一个变量 $cnt$ 存储以当前二进制为前缀的数的个数。</p><p>由于数据范围为 $[1, 2 * 10^4]$ ，所以我们只需要存储一个数的 $[0, 14]$ 位二进制即可，因为 $2^{15} - 1 &gt; 2*10^4$ 。</p><p>先设 $search(num, x)$ 表示当前树中与 $num$ 的异或值小于等于 $x$ 的数的数量。那么对于 $f(x)$，只需要顺序遍历数组，累加当前元素的 $search(nums[i], x)$ 并将当前元素加入到01字典树中就能得到结果。</p><p>对于任意一个数 $x &lt; y$ ，都存在一个数 $k$ ，使得他们的二进制表示中的最高位到 $k + 1$ 位都相同，而第 $k$ 位却为小于的关系。</p><p>对于 $search(num, x)$ 的具体实现如下：设结果为 $ret$，我们从根节点开始遍历字典树，设当前遍历到的树节点为 $p$，同时从最高位开始遍历 $num$ 和 $x$ ，设当前遍历到第 $i$ 位，且 $num$ 的第 $i$ 位为 $cur$：</p><ul><li>如果 $x$ 的第 $i$ 位为 $1$ ，直接将 $p.node[cur].cnt$ 累加到 $ret$ 中，这是因为 $cur \oplus cur &#x3D; 0$，而 $x$ 的第 $i$ 位又为 $1$，所以 $cur \oplus cur &#x3D; 0$ 这条路径后的节点不管是什么，显然都小于 $x$ ，也就是说 $i$ 即为上面所说的 $k$；然后再将 $p$ 指向 $p.node[cur \oplus 1]$，这是因为 $cur \oplus (cur \oplus 1) &#x3D; 1$，即异或值的当前二进制位与 $x$ 相等，尝试搜索在更低位小于 $x$ 的可能，也就是当前 $k$ 为更小的可能。 </li><li>类似的，如果 $x$ 的第 $i$ 位为 $0$ ，那么只需要将 $p$ 指向 $p.node[cur]$ 即可，因为 $cur \oplus cur &#x3D; 0$ 。</li></ul><p>遍历结束后，还需要将 $ret$ 加上 $p.cnt$ ，因为是闭区间，数对的异或值可以等于 $x$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-keyword">return</span> f(nums, high) - f(nums, low - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">trie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            ret += trie.search(nums[i], x);<br>            trie.add(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>&#123;<br>    Trie[] node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> cnt;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">14</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (p.node[cur] == <span class="hljs-literal">null</span>) &#123;<br>                p.node[cur] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            p.node[cur].cnt++;<br>            p = p.node[cur];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">14</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(((x &gt;&gt; i) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span> (p.node[cur] != <span class="hljs-literal">null</span>) &#123;<br>                    ret += p.node[cur].cnt;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (p.node[cur ^ <span class="hljs-number">1</span>] == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> ret;<br>                &#125;<br>                p = p.node[cur ^ <span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (p.node[cur] == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> ret;<br>                &#125;<br>                p = p.node[cur];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret + p.cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字典树</tag>
      
      <tag>容斥原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-2532.过桥的时间</title>
    <link href="/2023/01/11/LC-2532-%E8%BF%87%E6%A1%A5%E7%9A%84%E6%97%B6%E9%97%B4/"/>
    <url>/2023/01/11/LC-2532-%E8%BF%87%E6%A1%A5%E7%9A%84%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/time-to-cross-a-bridge/">leetcode 困难题</a></p><p>共有 k 位工人计划将 n 个箱子从旧仓库移动到新仓库。给你两个整数 n 和 k，以及一个二维整数数组 time ，数组的大小为 k x 4 ，其中 time[i] &#x3D; [leftToRighti, pickOldi, rightToLefti, putNewi] 。</p><p>一条河将两座仓库分隔，只能通过一座桥通行。旧仓库位于河的右岸，新仓库在河的左岸。开始时，所有 k 位工人都在桥的左侧等待。为了移动这些箱子，第 i 位工人（下标从 0 开始）可以：</p><ul><li>从左岸（新仓库）跨过桥到右岸（旧仓库），用时 leftToRighti 分钟。</li><li>从旧仓库选择一个箱子，并返回到桥边，用时 pickOldi 分钟。不同工人可以同时搬起所选的箱子。</li><li>从右岸（旧仓库）跨过桥到左岸（新仓库），用时 rightToLefti 分钟。</li><li>将箱子放入新仓库，并返回到桥边，用时 putNewi 分钟。不同工人可以同时放下所选的箱子。</li></ul><p>如果满足下面任一条件，则认为工人 i 的 效率低于 工人 j ：</p><ul><li>leftToRighti + rightToLefti &gt; leftToRightj + rightToLeftj</li><li>leftToRighti + rightToLefti &#x3D;&#x3D; leftToRightj + rightToLeftj 且 i &gt; j</li></ul><p>工人通过桥时需要遵循以下规则：</p><ul><li>如果工人 x 到达桥边时，工人 y 正在过桥，那么工人 x 需要在桥边等待。</li><li>如果没有正在过桥的工人，那么在桥右边等待的工人可以先过桥。如果同时有多个工人在右边等待，那么 效率最低 的工人会先过桥。</li><li>如果没有正在过桥的工人，且桥右边也没有在等待的工人，同时旧仓库还剩下至少一个箱子需要搬运，此时在桥左边的工人可以过桥。如果同时有多个工人在左边等待，那么 效率最低 的工人会先过桥。</li></ul><p>所有 n 个盒子都需要放入新仓库，请你返回最后一个搬运箱子的工人 到达河左岸 的时间。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]<br>输出：50<br>解释：<br>从<span class="hljs-number"> 0 </span>到<span class="hljs-number"> 10 </span>：工人<span class="hljs-number"> 1 </span>从左岸过桥到达右岸。<br>从<span class="hljs-number"> 10 </span>到<span class="hljs-number"> 20 </span>：工人<span class="hljs-number"> 1 </span>从旧仓库搬起一个箱子。<br>从<span class="hljs-number"> 10 </span>到<span class="hljs-number"> 11 </span>：工人<span class="hljs-number"> 0 </span>从左岸过桥到达右岸。<br>从<span class="hljs-number"> 11 </span>到<span class="hljs-number"> 20 </span>：工人<span class="hljs-number"> 0 </span>从旧仓库搬起一个箱子。<br>从<span class="hljs-number"> 20 </span>到<span class="hljs-number"> 30 </span>：工人<span class="hljs-number"> 1 </span>从右岸过桥到达左岸。<br>从<span class="hljs-number"> 30 </span>到<span class="hljs-number"> 40 </span>：工人<span class="hljs-number"> 1 </span>将箱子放入新仓库。<br>从<span class="hljs-number"> 30 </span>到<span class="hljs-number"> 31 </span>：工人<span class="hljs-number"> 0 </span>从右岸过桥到达左岸。<br>从<span class="hljs-number"> 31 </span>到<span class="hljs-number"> 39 </span>：工人<span class="hljs-number"> 0 </span>将箱子放入新仓库。<br>从<span class="hljs-number"> 39 </span>到<span class="hljs-number"> 40 </span>：工人<span class="hljs-number"> 0 </span>从左岸过桥到达右岸。<br>从<span class="hljs-number"> 40 </span>到<span class="hljs-number"> 49 </span>：工人<span class="hljs-number"> 0 </span>从旧仓库搬起一个箱子。<br>从<span class="hljs-number"> 49 </span>到<span class="hljs-number"> 50 </span>：工人<span class="hljs-number"> 0 </span>从右岸过桥到达左岸。<br>从<span class="hljs-number"> 50 </span>到<span class="hljs-number"> 58 </span>：工人<span class="hljs-number"> 0 </span>将箱子放入新仓库。<br>整个过程在<span class="hljs-number"> 58 </span>分钟后结束。因为问题关注的是最后一个工人到达左岸的时间，所以返回<span class="hljs-number"> 50 </span>。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span> &lt;= n, k &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.length</span> == k<br><span class="hljs-selector-tag">time</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.length</span> == <span class="hljs-number">4</span><br><span class="hljs-number">1</span> &lt;= leftToRighti, pickOldi, rightToLefti, putNewi &lt;= <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>通过四个堆进行模拟，分别是：</p><ul><li>$leftBridge$ 左边等桥的工人序号，堆顶为效率最小的工人。</li><li>$rightBridge$ 右边等桥的工人序号，堆顶为效率最小的工人。</li><li>$leftPuttingNew$ 左边正在搬箱子的工人，$int[0]$ 为该工人搬运当前箱子完成的时间，$int[1]$ 为工人序号，堆顶为搬运完成时间最早的工人。</li><li>$rightPickingOld$ 右边正在搬箱子的工人，$int[0]$ 为该工人搬运当前箱子完成的时间，$int[1]$ 为工人序号，堆顶为搬运完成时间最早的工人。</li></ul><p>初始化当前时间为 $0$，模拟工人搬运过程，由于关注的是最后一个搬运箱子的工人到达左岸的时间，所以中止条件为箱子搬完且右岸不存在任何工人。</p><p>按照题意，每次循环时，如果右边等桥的人非空，右边等桥的堆顶工人出堆过桥，更新当前时间为过桥后的时间，并将工人放入左边搬运箱子的堆中；否则如果左边等桥的人非空且存在箱子未搬运，就将左边等桥的堆顶工人出堆过桥，更新当前时间为过桥后的时间，并将工人放入右边搬运箱子的堆中，箱子数量减一；如果以上两个条件均不满足，则说明当前时间过小，工人未搬完箱子，更新时间为左右岸搬完箱子的最小时间即可。</p><p>显然在上面的三个判断之前，还需要判断左右岸正在搬箱子的工人，如果已经搬完箱子了，就将其放入等桥的队列中。</p><p>循环结束时，当前时间为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCrossingTime</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[][] time)</span> &#123;<br>        Comparator&lt;Integer&gt; cmp = (a, b) -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (time[b][<span class="hljs-number">0</span>] + time[b][<span class="hljs-number">2</span>]) - (time[a][<span class="hljs-number">0</span>] + time[a][<span class="hljs-number">2</span>]);<br>            <span class="hljs-keyword">return</span> d != <span class="hljs-number">0</span> ? d : b - a;<br>        &#125;;<br>        PriorityQueue&lt;Integer&gt; leftBridge = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(cmp);<br>        PriorityQueue&lt;Integer&gt; rightBridge = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(cmp);<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; leftPuttingNew = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(a -&gt; a[<span class="hljs-number">0</span>]));<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; rightPickingOld = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(a -&gt; a[<span class="hljs-number">0</span>]));<br>        leftBridge.addAll(IntStream.range(<span class="hljs-number">0</span>, k).boxed().toList());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n + rightPickingOld.size() + rightBridge.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (!rightPickingOld.isEmpty() &amp;&amp; rightPickingOld.peek()[<span class="hljs-number">0</span>] &lt;= curTime) &#123;<br>                rightBridge.offer(rightPickingOld.poll()[<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!leftPuttingNew.isEmpty() &amp;&amp; leftPuttingNew.peek()[<span class="hljs-number">0</span>] &lt;= curTime) &#123;<br>                leftBridge.offer(leftPuttingNew.poll()[<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!rightBridge.isEmpty()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> Objects.requireNonNull(rightBridge.poll());<br>                curTime += time[worker][<span class="hljs-number">2</span>];<br>                leftPuttingNew.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;curTime + time[worker][<span class="hljs-number">3</span>], worker&#125;);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span> &amp;&amp; !leftBridge.isEmpty()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> Objects.requireNonNull(leftBridge.poll());<br>                curTime += time[worker][<span class="hljs-number">0</span>];<br>                rightPickingOld.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;curTime + time[worker][<span class="hljs-number">1</span>], worker&#125;);<br>                n--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                curTime = Math.min(<br>                        rightPickingOld.isEmpty() ? Integer.MAX_VALUE : rightPickingOld.peek()[<span class="hljs-number">0</span>], <br>                        leftPuttingNew.isEmpty() ? Integer.MAX_VALUE : leftPuttingNew.peek()[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> curTime;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>复杂模拟</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1658.将x减到0的最小操作数</title>
    <link href="/2023/01/08/LC-1658-%E5%B0%86x%E5%87%8F%E5%88%B00%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/"/>
    <url>/2023/01/08/LC-1658-%E5%B0%86x%E5%87%8F%E5%88%B00%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/">leetcode 中等题</a></p><p>给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。</p><p>如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。</p><p>示例1：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span>]<span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br>输出：<span class="hljs-number">2</span><br>解释：最佳解决方案是移除后两个元素，将 <span class="hljs-keyword">x</span> 减到 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= nums[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span>&lt;= x &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="双指针-前缀和"><a href="#双指针-前缀和" class="headerlink" title="双指针 + 前缀和"></a>双指针 + 前缀和</h2><p>首先由于每次都是从最左边或最右边选择一个元素，那么 $x$ 必然由数组的一个前缀、后缀所组成。</p><p>因此原题目可以转化成求元素和为 $sum - x$ 的子数组，其中 $sum$ 为数组总和，此时的操作次数显然为数组长度减去子数组长度。</p><p>具体可以使用双指针 + 前缀和的方式进行求解。为了方便，初始时将 $x$ 转换成 $sum - x$，左右指针均指向 $0$，右指针每次向右移动一位，并将当前指向元素累加到前缀和 $curSum$ 中，而每当 $curSum$ 大于 $x$ 时，向右移动左指针并从前缀和中减去当前指向元素，直到 $curSum &lt;&#x3D; x$ ，此时再尝试更新 $ans$ 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// x = sum - x</span><br>        x = -x;<br>        x = Arrays.stream(nums).reduce(x, Integer::sum);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> n + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, curSum = <span class="hljs-number">0</span>; right &lt; n; right++)&#123;<br>            curSum += nums[right];<br>            <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; curSum &gt; x)&#123;<br>                curSum -= nums[left++];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(curSum == x)&#123;<br>                ans = Math.min(ans, n - (right - left + <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == n + <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : ans;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>类似的做法还可以使用哈希表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// x = sum - x</span><br>        x = -x;<br>        x = Arrays.stream(nums).reduce(x, Integer::sum);<br>        Map&lt;Integer, Integer&gt; sumMapIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        sumMapIndex.put(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> n + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, preSum = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            preSum += nums[i];<br>            sumMapIndex.put(preSum, i);<br>            <span class="hljs-keyword">if</span>(sumMapIndex.containsKey(preSum - x))&#123;<br>                ans = Math.min(ans, n - (i - sumMapIndex.get(preSum - x)));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == n + <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : ans;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针/多指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1802.有界数组中指定下标处的最大值</title>
    <link href="/2023/01/07/LC-1802-%E6%9C%89%E7%95%8C%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E4%B8%8B%E6%A0%87%E5%A4%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2023/01/07/LC-1802-%E6%9C%89%E7%95%8C%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E4%B8%8B%E6%A0%87%E5%A4%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/">leetcode 中等题</a></p><p>给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：</p><ul><li>nums.length &#x3D;&#x3D; n</li><li>nums[i] 是 正整数 ，其中 0 &lt;&#x3D; i &lt; n</li><li>abs(nums[i] - nums[i+1]) &lt;&#x3D; 1 ，其中 0 &lt;&#x3D; i &lt; n-1</li><li>nums 中所有元素之和不超过 maxSum</li><li>nums[index] 的值被 最大化</li></ul><p>返回你所构造的数组中的 nums[index] 。</p><p>注意：abs(x) 等于 x 的前提是 x &gt;&#x3D; 0 ；否则，abs(x) 等于 -x 。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：n = <span class="hljs-number">4</span>, index = <span class="hljs-number">2</span>,  maxSum = <span class="hljs-number">6</span><br>输出：<span class="hljs-number">2</span><br>解释：数组 [<span class="hljs-number">1,1,2,1</span>] 和 [<span class="hljs-number">1,2,2,1</span>] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= n &lt;= maxSum &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br><span class="hljs-symbol">0 </span>&lt;= index &lt; n<br></code></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>首先根据题目描述，为了使 $index$ 处元素值尽量大，显然 $index$ 处的两侧元素必然是从 $nums[index]-1$ 递减到 $1$ 的，并且如果某一侧递减到 $1$ 后还存在剩余位置，就用 $1$ 补齐。</p><p>由此可以进行数组的元素总和的计算，设 $index$ 处元素值为 $mid$，某一侧的元素数量为 $cnt$</p><ul><li>当 $cnt &gt; mid$ 时，该侧的元素和为 $\frac{mid \times (1+mid) }{2} + (cnt - mid)$，其中前者为 $1$ 到 $mid$ 的等差数列和，后者为需要填充 $1$ 的数量。</li><li>当 $cnt &lt;&#x3D; mid$ 时，该侧的元素和就为 $\frac{cnt \times (mid - cnt + 1 +mid) }{2}$，即从 $mid - cnt + 1$ 到 $mid$ 的等差数列和。</li></ul><p>由于题目 $maxSum$ 范围为 $10^9$，所以 $O(maxSum)$ 的遍历会 TLE。又因为随着 $mid$ 的增大，数组的总和也会增大，所以可以使用二分查找右边界的方式来找到最后一个满足小于等于 $maxSum$ 的值，此时的时间复杂度为 $O(log(maxSum))$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> maxSum)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = maxSum + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(getSum(mid, index + <span class="hljs-number">1</span>) + getSum(mid - <span class="hljs-number">1</span>, n - index - <span class="hljs-number">1</span>) &lt;= maxSum)&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">long</span> mid, <span class="hljs-type">long</span> cnt)</span>&#123;<br>        <span class="hljs-keyword">if</span>(cnt &gt; mid)&#123;<br>            <span class="hljs-keyword">return</span> (mid * (<span class="hljs-number">1</span> + mid)) / <span class="hljs-number">2</span> + (cnt - mid);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (cnt * (mid - cnt + <span class="hljs-number">1</span> + mid)) / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1799.N次操作后的最大分数和</title>
    <link href="/2022/12/22/LC-1799-N%E6%AC%A1%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0%E5%92%8C/"/>
    <url>/2022/12/22/LC-1799-N%E6%AC%A1%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximize-score-after-n-operations/">leetcode 困难题</a></p><p>给你 nums ，它是一个大小为 2 * n 的正整数数组。你必须对这个数组执行 n 次操作。</p><p>在第 i 次操作时（操作编号从 1 开始），你需要：</p><p>选择两个元素 x 和 y 。<br>获得分数 i * gcd(x, y) 。<br>将 x 和 y 从 nums 中删除。<br>请你返回 n 次操作后你能获得的分数和最大为多少。</p><p>函数 gcd(x, y) 是 x 和 y 的最大公约数。</p><p>示例1：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]<br>输出：<span class="hljs-number">11</span><br>解释：最优操作是：<br>(<span class="hljs-number">1</span> * <span class="hljs-built_in">gcd</span>(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)) + (<span class="hljs-number">2</span> * <span class="hljs-built_in">gcd</span>(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>)) = <span class="hljs-number">3</span> + <span class="hljs-number">8</span> = <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> &lt;= n &lt;= <span class="hljs-number">7</span><br><span class="hljs-attribute">nums</span>.length == <span class="hljs-number">2</span> * n<br><span class="hljs-attribute">1</span> &lt;= nums[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="状态压缩-动态规划"><a href="#状态压缩-动态规划" class="headerlink" title="状态压缩 + 动态规划"></a>状态压缩 + 动态规划</h2><p>由于 $1 &lt;&#x3D; n &lt;&#x3D; 7$ ，使用一个整数 $state$ 表示数组中元素被选取状态, 若从右往左第 $i$ 位为 $1$ 表示 $nums[i]$ 已经被选取，初始为 $0$ 未被选取。</p><p>定义 $dp[i]$ 表示当 $state$ 为 $i$ 时剩余元素能获取到的最大分数，那么 $dp[0]$ 为答案。简略的状态转移方程如下：<br>$$<br>\begin{align}<br>&amp;dp(i) &#x3D; max\{dp(i \oplus 2^a \oplus 2 ^b ) + \frac{zeroCount}{2} \times gcd(nums[a],nums[b])\}　　 \\<br>\end{align}<br>$$<br>其中 $a$, $b$ 为 $i$ 状态下未被选取的下标组合，$zeroCount$ 为未被选取的个数，即 $0$ 的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxScore</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, init = (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">2</span>, n) - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] cacheGcd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                cacheGcd[i][j] = gcd(nums[i], nums[j]);       <br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// dp[i] 表示 i 状态下可以获得的最大分数. 二进制下 0 表示未删除</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[init + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> init; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            List&lt;Integer&gt; zeroIndex = getZeroIndex(i, n);<br>            <span class="hljs-keyword">if</span>((zeroIndex.size() &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 两两配对</span><br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">zeroCount</span> <span class="hljs-operator">=</span> zeroIndex.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; zeroCount; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> zeroIndex.get(j);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; zeroCount; k++)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> zeroIndex.get(k); <br>                    dp[i] = Math.max(dp[i], dp[i ^ (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">2</span>, a) ^ (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">2</span>, b)] + zeroCount / <span class="hljs-number">2</span> * cacheGcd[a][b]);<br>                &#125;    <br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">getZeroIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span>&#123;<br>        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;<br>                ret.add(index);<br>            &#125;<br>            index++;<br>            i &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(index &lt; n) ret.add(index++);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="状态压缩-记忆化搜索"><a href="#状态压缩-记忆化搜索" class="headerlink" title="状态压缩 + 记忆化搜索"></a>状态压缩 + 记忆化搜索</h2><p>类似的记忆化搜索解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] cacheGcd;<br>    <span class="hljs-type">int</span>[] dp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxScore</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, init = (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">2</span>, n) - <span class="hljs-number">1</span>;<br>        cacheGcd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                cacheGcd[i][j] = gcd(nums[i], nums[j]);       <br>            &#125;<br>        &#125;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[init + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, nums); <span class="hljs-comment">// i.e. dp[0]</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> state, <span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-keyword">if</span>(dp[state] &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> dp[state];<br>        &#125;<br>        List&lt;Integer&gt; zeroIndex = getZeroIndex(state, nums.length);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curStatePoint</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; zeroIndex.size(); j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> zeroIndex.get(j);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; zeroIndex.size(); k++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> zeroIndex.get(k); <br>                curStatePoint = Math.max(curStatePoint, dfs(state ^ (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">2</span>, a) ^ (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">2</span>, b), nums) + zeroIndex.size() / <span class="hljs-number">2</span> * cacheGcd[a][b]);<br>            &#125;<br>        &#125;<br>        dp[state] = curStatePoint;<br>        <span class="hljs-keyword">return</span> curStatePoint;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">getZeroIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span>&#123;<br>        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;<br>                ret.add(index);<br>            &#125;<br>            index++;<br>            i &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(index &lt; n) ret.add(index++);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, nums); <span class="hljs-comment">// i.e. dp[0]</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> state, <span class="hljs-type">int</span> round, <span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-keyword">if</span>(dp[state] &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> dp[state];<br>        &#125;<br>        List&lt;Integer&gt; zeroIndex = getZeroIndex(state, nums.length);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curStatePoint</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; zeroIndex.size(); j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> zeroIndex.get(j);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; zeroIndex.size(); k++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> zeroIndex.get(k); <br>                curStatePoint = Math.max(curStatePoint, dfs(state ^ (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">2</span>, a) ^ (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">2</span>, b), round + <span class="hljs-number">1</span>, nums) + round * cacheGcd[a][b]);<br>            &#125;<br>        &#125;<br>        dp[state] = curStatePoint;<br>        <span class="hljs-keyword">return</span> curStatePoint;<br>    &#125;<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1760.袋子里最少数目的球</title>
    <link href="/2022/12/20/LC-1760-%E8%A2%8B%E5%AD%90%E9%87%8C%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E7%90%83/"/>
    <url>/2022/12/20/LC-1760-%E8%A2%8B%E5%AD%90%E9%87%8C%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E7%90%83/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/">leetcode 中等题</a></p><p>给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。</p><p>你可以进行如下操作至多 maxOperations 次：</p><ul><li>选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。<ul><li>比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。<br>你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。</li></ul></li></ul><p>请你返回进行上述操作后的最小开销。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [9], maxOperations = 2<br>输出：3<br>解释：<br>- 将装有<span class="hljs-number"> 9 </span>个球的袋子分成装有<span class="hljs-number"> 6 </span>个和<span class="hljs-number"> 3 </span>个球的袋子。[9] -&gt; [6,3] 。<br>- 将装有<span class="hljs-number"> 6 </span>个球的袋子分成装有<span class="hljs-number"> 3 </span>个和<span class="hljs-number"> 3 </span>个球的袋子。[6,3] -&gt; [3,3,3] 。<br>装有最多球的袋子里装有<span class="hljs-number"> 3 </span>个球，所以开销为<span class="hljs-number"> 3 </span>并返回<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= maxOperations, nums[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>转化成最大化操作次数时最小开销问题。</p><p>对于某个袋子 $nums[i]$，目标开销 $x$，需要的操作次数为 $\lfloor\frac{nums[i] - 1}{x}\rfloor$ 。</p><p>由于操作次数和开销满足单调性（类似的，普通的二分查找也是因为数组下标和元素满足单调性），随着开销的减少操作次数增加，所以可以通过二分查找计算开销的左边界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumSize</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> maxOperations)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = Arrays.stream(nums).max().orElseThrow(); <span class="hljs-comment">// 当然这里 1 表示袋子里最少有1个球</span><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> item : nums)&#123;<br>                op += (item - <span class="hljs-number">1</span>) / mid;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(op &gt; maxOperations)&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1703.得到连续K个1的最少相邻交换次数</title>
    <link href="/2022/12/19/LC-1703-%E5%BE%97%E5%88%B0%E8%BF%9E%E7%BB%ADK%E4%B8%AA1%E7%9A%84%E6%9C%80%E5%B0%91%E7%9B%B8%E9%82%BB%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/12/19/LC-1703-%E5%BE%97%E5%88%B0%E8%BF%9E%E7%BB%ADK%E4%B8%AA1%E7%9A%84%E6%9C%80%E5%B0%91%E7%9B%B8%E9%82%BB%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/minimum-adjacent-swaps-for-k-consecutive-ones/">leetcode 困难题</a></p><p>给你一个整数数组 nums 和一个整数 k 。 nums 仅包含 0 和 1 。每一次移动，你可以选择 相邻 两个数字并将它们交换。</p><p>请你返回使 nums 中包含 k 个 连续 1 的 最少 交换次数。</p><p>示例1：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,0,0,1,0,1]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br>解释：在第一次操作时，nums 可以变成 <span class="hljs-string">[1,0,0,0,1,1]</span> 得到连续两个 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> nums.length &lt;<span class="hljs-operator">=</span> <span class="hljs-number">105</span><br>nums[i] 要么是 <span class="hljs-number">0</span> ，要么是 <span class="hljs-number">1</span> 。<br><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> k &lt;<span class="hljs-operator">=</span> sum(nums)<br></code></pre></td></tr></table></figure><h2 id="TODO-分析"><a href="#TODO-分析" class="headerlink" title="TODO-分析"></a>TODO-分析</h2><p><a href="https://www.acwing.com/solution/content/835/">AcWing104.货仓选址</a></p><p><a href="https://codeantenna.com/a/yldVZPGnUl">AcWing104.货仓选址</a></p><p><a href="https://zh.m.wikipedia.org/zh-hans/%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F">绝对值不等式-wiki</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minMoves</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        List&lt;Integer&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">1</span>)&#123;<br>                p.add(i - p.size()); <span class="hljs-comment">// p = q_i - i</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[p.size() + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= p.size(); i++)&#123;<br>            s[i] = s[i - <span class="hljs-number">1</span>] + p.get(i - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= p.size() - k; i++)&#123;<br>            ans = Math.min(ans, s[i] + s[i + k] - (<span class="hljs-number">2</span> * s[i + k / <span class="hljs-number">2</span>]) - (p.get(i + k / <span class="hljs-number">2</span>) * (k % <span class="hljs-number">2</span>)));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>前缀和</tag>
      
      <tag>数学</tag>
      
      <tag>思维题</tag>
      
      <tag>TODO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6268.查询树中环的长度</title>
    <link href="/2022/12/19/LC-6268-%E6%9F%A5%E8%AF%A2%E6%A0%91%E4%B8%AD%E7%8E%AF%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
    <url>/2022/12/19/LC-6268-%E6%9F%A5%E8%AF%A2%E6%A0%91%E4%B8%AD%E7%8E%AF%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/cycle-length-queries-in-a-tree/">leetcode 困难题</a></p><p>给你一个整数 n ，表示你有一棵含有 2n - 1 个节点的 完全二叉树 。根节点的编号是 1 ，树中编号在[1, 2n - 1 - 1] 之间，编号为 val 的节点都有两个子节点，满足：</p><ul><li>左子节点的编号为 2 * val</li><li>右子节点的编号为 2 * val + 1</li></ul><p>给你一个长度为 m 的查询数组 queries ，它是一个二维整数数组，其中 queries[i] &#x3D; [ai, bi] 。对于每个查询，求出以下问题的解：</p><ol><li>在节点编号为 ai 和 bi 之间添加一条边。</li><li>求出图中环的长度。</li><li>删除节点编号为 ai 和 bi 之间新添加的边。</li></ol><p>注意：</p><ul><li>环 是开始和结束于同一节点的一条路径，路径中每条边都只会被访问一次。</li><li>环的长度是环中边的数目。</li><li>在树中添加额外的边后，两个点之间可能会有多条边。</li></ul><p>请你返回一个长度为 m 的数组 answer ，其中 answer[i] 是第 i 个查询的结果。</p><p>示例1：</p><p><img src="/../img/Snipaste_2022-12-19_22-46-15.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 3, queries = [[5,3],[4,7],[2,3]]<br>输出：[4,5,3]<br>解释：上图是一棵有<span class="hljs-number"> 23 </span>-<span class="hljs-number"> 1 </span>个节点的树。红色节点表示添加额外边后形成环的节点。<br>- 在节点<span class="hljs-number"> 3 </span>和节点<span class="hljs-number"> 5 </span>之间添加边后，环为 [5,2,1,3] ，所以第一个查询的结果是<span class="hljs-number"> 4 </span>。删掉添加的边后处理下一个查询。<br>- 在节点<span class="hljs-number"> 4 </span>和节点<span class="hljs-number"> 7 </span>之间添加边后，环为 [4,2,1,3,7] ，所以第二个查询的结果是<span class="hljs-number"> 5 </span>。删掉添加的边后处理下一个查询。<br>- 在节点<span class="hljs-number"> 2 </span>和节点<span class="hljs-number"> 3 </span>之间添加边后，环为 [2,1,3] ，所以第三个查询的结果是<span class="hljs-number"> 3 </span>。删掉添加的边。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span> &lt;= n &lt;= <span class="hljs-number">30</span><br><span class="hljs-attribute">m</span> == queries.length<br><span class="hljs-attribute">1</span> &lt;= m &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-attribute">queries</span>[i].length == <span class="hljs-number">2</span><br><span class="hljs-attribute">1</span> &lt;= ai, bi &lt;= <span class="hljs-number">2</span>n - <span class="hljs-number">1</span><br><span class="hljs-attribute">ai</span> != bi<br></code></pre></td></tr></table></figure><h2 id="最近公共祖先（LCA）"><a href="#最近公共祖先（LCA）" class="headerlink" title="最近公共祖先（LCA）"></a>最近公共祖先（LCA）</h2><p>实际为<a href="https://oi-wiki.org/graph/lca/">最近公共祖先问题</a>，环的长度显然为结点 $a$ 和 $b$ 分别到 $LCA$ 的距离之和再加上 $1$。</p><p>求 $LCA$ 的一种朴素解法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] cycleLengthQueries(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> queries.length;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> queries[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> queries[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(a != b)&#123;<br>                <span class="hljs-keyword">if</span>(a &gt; b)&#123;<br>                    a /= <span class="hljs-number">2</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    b /= <span class="hljs-number">2</span>;<br>                &#125;<br>                cur++;<br>            &#125;<br>            ans[i] = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="转二进制"><a href="#转二进制" class="headerlink" title="转二进制"></a>转二进制</h2><p>由于是满二叉树，并且结点编号符合题目中的规则，所以某个结点值的二进制值为从根节点到该结点的路径，其中 $0$ 表示左结点， $1$ 表示右结点或者根结点。例如 $5$ 为 $101$：$根结点-&gt;左结点-&gt;右结点$。</p><p>设某个结点 $x$ 到根结点的距离为 $d_x$，可以得到 $ans_i &#x3D; d_{a_i} + d_{b_i} - (2 \times d_{LCA}) + 1$ ，其中 $d_{a_i}$ 和 $d_{b_i}$ 分别为两个结点的二进制值长度，而 $d_{LCA}$ 显然为两个结点的二进制值从根节点开始到第一个不同的二进制位的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] cycleLengthQueries(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> queries.length;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.toBinaryString(queries[i][<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.toBinaryString(queries[i][<span class="hljs-number">1</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (; j &lt; a.length() &amp;&amp; j &lt; b.length(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (a.charAt(j) != b.charAt(j))<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            ans[i] = a.length() + b.length() - <span class="hljs-number">2</span> * j + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6267.添加边使所有节点度数都为偶数</title>
    <link href="/2022/12/19/LC-6267-%E6%B7%BB%E5%8A%A0%E8%BE%B9%E4%BD%BF%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E5%BA%A6%E6%95%B0%E9%83%BD%E4%B8%BA%E5%81%B6%E6%95%B0/"/>
    <url>/2022/12/19/LC-6267-%E6%B7%BB%E5%8A%A0%E8%BE%B9%E4%BD%BF%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E5%BA%A6%E6%95%B0%E9%83%BD%E4%B8%BA%E5%81%B6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/add-edges-to-make-degrees-of-all-nodes-even/submissions/">leetcode 困难题</a></p><p>给你一个有 n 个节点的 无向 图，节点编号为 1 到 n 。再给你整数 n 和一个二维整数数组 edges ，其中 edges[i] &#x3D; [ai, bi] 表示节点 ai 和 bi 之间有一条边。图不一定连通。</p><p>你可以给图中添加 至多 两条额外的边（也可以一条边都不添加），使得图中没有重边也没有自环。</p><p>如果添加额外的边后，可以使得图中所有点的度数都是偶数，返回 true ，否则返回 false 。</p><p>点的度数是连接一个点的边的数目。</p><p>示例1：<br><img src="/../img/Snipaste_2022-12-19_19-25-07.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 5, edges = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[4,2]</span>,<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[2,5]</span>]</span><br>输出：true<br>解释：上图展示了添加一条边的合法方案。<br>最终图中每个节点都连接偶数条边。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-number">3</span> &lt;= n &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-number">2</span> &lt;= <span class="hljs-built_in">edges</span>.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-built_in">edges</span>[i].<span class="hljs-built_in">length</span> == <span class="hljs-number">2</span><br><span class="hljs-number">1</span> &lt;= ai, bi &lt;= n<br>ai != bi<br>图中不会有重边<br></code></pre></td></tr></table></figure><h2 id="分类讨论"><a href="#分类讨论" class="headerlink" title="分类讨论"></a>分类讨论</h2><p>由于最多只能加两条边，显然如果度数为奇数的边数大于4时，返回 $false$。 </p><p>讨论小于等于4的情况：</p><ul><li>0：直接返回 $true$ 即可。</li><li>1：由于不能存在自环，无法满足题意，直接返回 $false$ 。</li><li>2：设两点分别为 $a$ 、$b$ ，如果 $a$ 、$b$ 之间不存在边，添加一条边即可；否则需要存在一个公共点，该公共点与 $a$ 、$b$ 均不存在边。</li><li>3: 与1的情况类似，直接返回 $false$ 。</li><li>4: 由于只能添加两条边，所以只能尝试添加两条边分别连接四个点，如果合法返回 $true$ 。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPossible</span><span class="hljs-params">(<span class="hljs-type">int</span> n, List&lt;List&lt;Integer&gt;&gt; edges)</span> &#123;<br>        Set&lt;Integer&gt;[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>[n + <span class="hljs-number">1</span>];<br>        Arrays.setAll(g, i -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;()); g[<span class="hljs-number">0</span>] = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span>(List&lt;Integer&gt; e : edges)&#123;<br>            g[e.get(<span class="hljs-number">0</span>)].add(e.get(<span class="hljs-number">1</span>));<br>            g[e.get(<span class="hljs-number">1</span>)].add(e.get(<span class="hljs-number">0</span>));<br>        &#125;<br>        List&lt;Integer&gt; p = IntStream.range(<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>).boxed()<br>                                .filter(i -&gt; g[i] != <span class="hljs-literal">null</span> &amp;&amp; (g[i].size() &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>                                .collect(Collectors.toList());<br>        <span class="hljs-keyword">if</span>(p.size() == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-comment">// 两点相连 或者 连一个公共点</span><br>            <span class="hljs-keyword">for</span>(Set&lt;Integer&gt; point : g)&#123;<br>                <span class="hljs-keyword">if</span>(point != <span class="hljs-literal">null</span> &amp;&amp; <br>                    !point.contains(p.get(<span class="hljs-number">0</span>)) &amp;&amp; !point.contains(p.get(<span class="hljs-number">1</span>)))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p.size() == <span class="hljs-number">4</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> p.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> p.get(<span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> p.get(<span class="hljs-number">2</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> p.get(<span class="hljs-number">3</span>);<br>            <span class="hljs-comment">// ab cd, ac bd, ad bc</span><br>            <span class="hljs-keyword">return</span> (!g[a].contains(b) &amp;&amp; !g[c].contains(d))<br>                || (!g[a].contains(c) &amp;&amp; !g[b].contains(d))<br>                || (!g[a].contains(d) &amp;&amp; !g[b].contains(c));<br>        &#125;<br>        <span class="hljs-keyword">return</span> p.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>短但可读性差<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPossible</span><span class="hljs-params">(<span class="hljs-type">int</span> n, List&lt;List&lt;Integer&gt;&gt; edges)</span> &#123;<br>        Set&lt;Integer&gt;[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>[n + <span class="hljs-number">1</span>];<br>        Arrays.setAll(g, i -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;()); g[<span class="hljs-number">0</span>] = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span>(List&lt;Integer&gt; e : edges)&#123;<br>            g[e.get(<span class="hljs-number">0</span>)].add(e.get(<span class="hljs-number">1</span>));<br>            g[e.get(<span class="hljs-number">1</span>)].add(e.get(<span class="hljs-number">0</span>));<br>        &#125;<br>        List&lt;Integer&gt; p = IntStream.range(<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>).boxed()<br>                .filter(i -&gt; g[i] != <span class="hljs-literal">null</span> &amp;&amp; (g[i].size() &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>                .collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> p.isEmpty()<br>                || p.size() == <span class="hljs-number">2</span> &amp;&amp; Arrays.stream(g).anyMatch(point -&gt; point != <span class="hljs-literal">null</span> &amp;&amp; !point.contains(p.get(<span class="hljs-number">0</span>)) &amp;&amp; !point.contains(p.get(<span class="hljs-number">1</span>)))<br>                || p.size() == <span class="hljs-number">4</span> &amp;&amp; <br>                    ((!g[p.get(<span class="hljs-number">0</span>)].contains(p.get(<span class="hljs-number">1</span>)) &amp;&amp; !g[p.get(<span class="hljs-number">2</span>)].contains(p.get(<span class="hljs-number">3</span>)))<br>                    || (!g[p.get(<span class="hljs-number">0</span>)].contains(p.get(<span class="hljs-number">2</span>)) &amp;&amp; !g[p.get(<span class="hljs-number">1</span>)].contains(p.get(<span class="hljs-number">3</span>)))<br>                    || (!g[p.get(<span class="hljs-number">0</span>)].contains(p.get(<span class="hljs-number">3</span>)) &amp;&amp; !g[p.get(<span class="hljs-number">1</span>)].contains(p.get(<span class="hljs-number">2</span>))));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>分类讨论</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-2507.使用质因数之和替换后可以取到的最小值</title>
    <link href="/2022/12/19/LC-2507-%E4%BD%BF%E7%94%A8%E8%B4%A8%E5%9B%A0%E6%95%B0%E4%B9%8B%E5%92%8C%E6%9B%BF%E6%8D%A2%E5%90%8E%E5%8F%AF%E4%BB%A5%E5%8F%96%E5%88%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <url>/2022/12/19/LC-2507-%E4%BD%BF%E7%94%A8%E8%B4%A8%E5%9B%A0%E6%95%B0%E4%B9%8B%E5%92%8C%E6%9B%BF%E6%8D%A2%E5%90%8E%E5%8F%AF%E4%BB%A5%E5%8F%96%E5%88%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/smallest-value-after-replacing-with-sum-of-prime-factors/">leetcode 中等题</a></p><p>给你一个正整数 n 。</p><p>请你将 n 的值替换为 n 的 质因数 之和，重复这一过程。</p><p>注意，如果 n 能够被某个质因数多次整除，则在求和时，应当包含这个质因数同样次数。<br>返回 n 可以取到的最小值。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 15<br>输出：5<br>解释：最开始，n =<span class="hljs-number"> 15 </span>。<br>15 =<span class="hljs-number"> 3 </span>*<span class="hljs-number"> 5 </span>，所以 n 替换为<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 8 </span>。<br>8 =<span class="hljs-number"> 2 </span>*<span class="hljs-number"> 2 </span>*<span class="hljs-number"> 2 </span>，所以 n 替换为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 6 </span>。<br>6 =<span class="hljs-number"> 2 </span>*<span class="hljs-number"> 3 </span>，所以 n 替换为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>。<br>5 是 n 可以取到的最小值。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>&lt;= n &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>按照题意模拟，分解质因数参考<a href="https://oi-wiki.org/math/number-theory/pollard-rho/">oi-wiki</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">smallestValue</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> n;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i * i &lt;= n; i++)&#123;<br>                <span class="hljs-keyword">while</span>(n % i == <span class="hljs-number">0</span>)&#123;<br>                    n /= i;<br>                    cur += i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(n != <span class="hljs-number">1</span>)&#123;<br>                cur += n;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur == pre)&#123;<br>                <span class="hljs-keyword">return</span> cur;<br>            &#125;<br>            n = cur;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="TODO-分解质因数的其他做法"><a href="#TODO-分解质因数的其他做法" class="headerlink" title="TODO-分解质因数的其他做法"></a>TODO-分解质因数的其他做法</h2>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>TODO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1697.检查边长度限制的路径是否存在</title>
    <link href="/2022/12/14/LC-1697-%E6%A3%80%E6%9F%A5%E8%BE%B9%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%AF%E5%BE%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/"/>
    <url>/2022/12/14/LC-1697-%E6%A3%80%E6%9F%A5%E8%BE%B9%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%AF%E5%BE%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/">leetcode 困难题</a></p><p>给你一个 n 个点组成的无向图边集 edgeList ，其中 edgeList[i] &#x3D; [ui, vi, disi] 表示点 ui 和点 vi 之间有一条长度为 disi 的边。请注意，两个点之间可能有 超过一条边 。</p><p>给你一个查询数组queries ，其中 queries[j] &#x3D; [pj, qj, limitj] ，你的任务是对于每个查询 queries[j] ，判断是否存在从 pj 到 qj 的路径，且这条路径上的每一条边都 严格小于 limitj 。</p><p>请你返回一个 布尔数组 answer ，其中 answer.length &#x3D;&#x3D; queries.length ，当 queries[j] 的查询结果为 true 时， answer 第 j 个值为 true ，否则为 false 。</p><p>示例1：</p><p><img src="/../img/Snipaste_2022-12-14_18-12-10.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span>, edgeList = <span class="hljs-string">[[0,1,2],[1,2,4],[2,0,8],[1,0,16]]</span>, queries = <span class="hljs-string">[[0,1,2],[0,2,5]]</span><br>输出：[<span class="hljs-literal">false</span>,<span class="hljs-literal">true</span>]<br>解释：上图为给定的输入数据。注意到 <span class="hljs-number">0</span> 和 <span class="hljs-number">1</span> 之间有两条重边，分别为 <span class="hljs-number">2</span> 和 <span class="hljs-number">16</span> 。<br>对于第一个查询，<span class="hljs-number">0</span> 和 <span class="hljs-number">1</span> 之间没有小于 <span class="hljs-number">2</span> 的边，所以我们返回 <span class="hljs-literal">false</span> 。<br>对于第二个查询，有一条路径（<span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span>）两条边都小于 <span class="hljs-number">5</span> ，所以这个查询我们返回 <span class="hljs-literal">true</span> 。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">2</span> &lt;= n &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-number">1</span> &lt;= edgeList<span class="hljs-selector-class">.length</span>, queries<span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br>edgeList<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.length</span> == <span class="hljs-number">3</span><br>queries<span class="hljs-selector-attr">[j]</span><span class="hljs-selector-class">.length</span> == <span class="hljs-number">3</span><br><span class="hljs-number">0</span> &lt;= ui, vi, pj, qj &lt;= n - <span class="hljs-number">1</span><br>ui != vi<br>pj != qj<br><span class="hljs-number">1</span> &lt;= disi, limitj &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br>两个点之间可能有多条边。<br></code></pre></td></tr></table></figure><h2 id="并查集-离线询问"><a href="#并查集-离线询问" class="headerlink" title="并查集 + 离线询问"></a>并查集 + 离线询问</h2><p>该题解法类似<a href="https://wecgwm.github.io/2022/12/14/LC-2503-%E7%9F%A9%E9%98%B5%E6%9F%A5%E8%AF%A2%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/">LC-2503-矩阵查询可获得的最大分数</a>。</p><p>对询问和边权进行排序后进行离线询问，利用并查集维护两点是否连通。</p><p>具体来说，对于每个询问，只需要将所有权值小于询问值的边上的点进行连通，然后再判断询问的点是否连通即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] fa;<br>    <span class="hljs-type">int</span>[] size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span>[] distanceLimitedPathsExist(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edgeList, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> edgeList.length, qn = queries.length;<br>        <span class="hljs-comment">// 并查集</span><br>        fa = IntStream.range(<span class="hljs-number">0</span>, n).toArray();<br>        size = IntStream.generate(() -&gt; <span class="hljs-number">1</span>).limit(n).toArray();<br>        <span class="hljs-comment">// 边排序, 方便离线</span><br>        Arrays.sort(edgeList, (a, b) -&gt; a[<span class="hljs-number">2</span>] - b[<span class="hljs-number">2</span>]);<br>        <span class="hljs-comment">// 查询排序</span><br>        <span class="hljs-type">int</span>[] qSort = IntStream.range(<span class="hljs-number">0</span>, qn).boxed().sorted((a, b) -&gt; queries[a][<span class="hljs-number">2</span>] - queries[b][<span class="hljs-number">2</span>]).mapToInt(Integer::valueOf).toArray();<br>        <span class="hljs-comment">// 边指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[qn];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index : qSort)&#123;<br>            <span class="hljs-type">int</span>[] q = queries[index];<br>            <span class="hljs-keyword">while</span>(j &lt; m &amp;&amp; edgeList[j][<span class="hljs-number">2</span>] &lt; q[<span class="hljs-number">2</span>])&#123;<br>                <span class="hljs-type">int</span>[] e = edgeList[j];<br>                union(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>]);<br>                j++;<br>            &#125;<br>            ans[index] = find(q[<span class="hljs-number">0</span>]) == find(q[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>        x = find(x);<br>        y = find(y);<br>        <span class="hljs-keyword">if</span>(x == y)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(size[x] &lt; size[y])&#123;<br>            x = x ^ y;<br>            y = x ^ y;<br>            x = x ^ y;<br>        &#125;<br>        fa[y] = x;<br>        size[x] += size[y];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>        <span class="hljs-keyword">if</span>(fa[x] != x)&#123;<br>            fa[x] = find(fa[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> fa[x];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>离线询问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-2503.矩阵查询可获得的最大分数</title>
    <link href="/2022/12/14/LC-2503-%E7%9F%A9%E9%98%B5%E6%9F%A5%E8%AF%A2%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/"/>
    <url>/2022/12/14/LC-2503-%E7%9F%A9%E9%98%B5%E6%9F%A5%E8%AF%A2%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/">leetcode 困难题</a></p><p>给你一个大小为 m x n 的整数矩阵 grid 和一个大小为 k 的数组 queries 。</p><p>找出一个大小为 k 的数组 answer ，且满足对于每个整数 queres[i] ，你从矩阵 左上角 单元格开始，重复以下过程：</p><p>如果 queries[i] 严格 大于你当前所处位置单元格，如果该单元格是第一次访问，则获得 1 分，并且你可以移动到所有 4 个方向（上、下、左、右）上任一 相邻 单元格。<br>否则，你不能获得任何分，并且结束这一过程。<br>在过程结束后，answer[i] 是你可以获得的最大分数。注意，对于每个查询，你可以访问同一个单元格 多次 。</p><p>返回结果数组 answer 。</p><p>示例1：</p><p><img src="/../img/Snipaste_2022-12-14_18-10-25.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：grid = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[2,5,7]</span>,<span class="hljs-comment">[3,5,1]</span>]</span>, queries = <span class="hljs-comment">[5,6,2]</span><br>输出：<span class="hljs-comment">[5,8,1]</span><br>解释：上图展示了每个查询中访问并获得分数的单元格。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">m</span> == grid.length<br><span class="hljs-attribute">n</span> == grid[i].length<br><span class="hljs-attribute">2</span> &lt;= m, n &lt;= <span class="hljs-number">1000</span><br><span class="hljs-attribute">4</span> &lt;= m * n &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-attribute">k</span> == queries.length<br><span class="hljs-attribute">1</span> &lt;= k &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-attribute">1</span> &lt;= grid[i][j], queries[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="优先队列-离线询问"><a href="#优先队列-离线询问" class="headerlink" title="优先队列 + 离线询问"></a>优先队列 + 离线询问</h2><p>由于每次询问的起点一样，显然可以得到如果 $queries[i] &lt;&#x3D; queries[j]$ ，那么前者能移动到的点必然是后者的一个子集，很容易想到从小到大进行询问。</p><p>我们可以先对询问进行排序，从小到大遍历 $queries$ 以进行<strong>离线查询</strong>。<a href="https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/solution/jian-cha-bian-chang-du-xian-zhi-de-lu-ji-c756/">离线查询</a>的含义为题目一次性给出了所有询问，但是我们不按照题目顺序而是以某种特定顺序进行处理。例如在该解法中，我们无法按照给出的顺序进行处理，必须按照从小到大的顺序处理询问。</p><p>具体询问过程为：通过最小堆维护当前能移动到的最小点，如果小于当前询问值，则分数加一，否则的话说明不存在任何能够移动到的新点，所以进行下次询问，如前面所说，后面询问能移动到的点肯定包含了之前询问的点，所以我们只需要在之前询问的基础上尝试移动即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span>[] fa;<br>    <span class="hljs-type">int</span>[] size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxPoints(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span>[] queries) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length, m = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 询问排序</span><br>        <span class="hljs-type">int</span>[] qIndexSort = IntStream.range(<span class="hljs-number">0</span>, queries.length).boxed()<br>                                .sorted((a, b) -&gt; queries[a] - queries[b])<br>                                .mapToInt(Integer::valueOf)<br>                                .toArray();<br>        <span class="hljs-comment">// 离线询问</span><br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queries.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; min = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        min.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// visit</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index : qIndexSort)&#123;<br>            <span class="hljs-keyword">while</span>(!min.isEmpty() &amp;&amp; min.peek()[<span class="hljs-number">0</span>] &lt; queries[index])&#123;<br>                <span class="hljs-type">int</span>[] top = min.poll();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> top[<span class="hljs-number">1</span>], b = top[<span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] item : help)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">newA</span> <span class="hljs-operator">=</span> a + item[<span class="hljs-number">0</span>], newB = b + item[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>(check(newA, newB, n, m) &amp;&amp; grid[newA][newB] &gt; <span class="hljs-number">0</span>)&#123;<br>                        min.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;grid[newA][newB], newA, newB&#125;);<br>                        grid[newA][newB] = <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<br>                count++;<br>            &#125;<br>            ans[index] = count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并查集-离线询问"><a href="#并查集-离线询问" class="headerlink" title="并查集 + 离线询问"></a>并查集 + 离线询问</h2><p>另一种思路是使用<a href="https://oi-wiki.org/ds/dsu/">并查集</a>，初始化为矩阵中每个元素独立存在，然后类似前一种解法先将矩阵元素、询问分别排序后进行离线询问。</p><p> 定义指针 $j$ ，初始时指向矩阵中最小的元素，然后从小到大遍历询问，如果 $gSort[j]$ 以及 $4$ 个方向上的元素满足当前询问值，则将其与 $gSort[j]$ 连通，并使 $j + 1$ ，显然每轮询问结果为 $size[find(0)]$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span>[] fa;<br>    <span class="hljs-type">int</span>[] size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxPoints(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span>[] queries) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length, m = grid[<span class="hljs-number">0</span>].length, mn = n * m;<br>        fa = IntStream.range(<span class="hljs-number">0</span>, mn).toArray();<br>        size = IntStream.generate(() -&gt; <span class="hljs-number">1</span>).limit(mn).toArray();<br>        <span class="hljs-comment">// 矩阵元素排序，第二维用来记录原始坐标</span><br>        <span class="hljs-type">int</span>[][] gSort = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[mn][<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                gSort[i * m + j] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;grid[i][j], i, j&#125;;<br>            &#125;<br>        &#125;<br>        Arrays.sort(gSort, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 询问排序</span><br>        <span class="hljs-type">int</span>[] qIndexSort = IntStream.range(<span class="hljs-number">0</span>, queries.length).boxed()<br>                                .sorted((a, b) -&gt; queries[a] - queries[b])<br>                                .mapToInt(Integer::valueOf)<br>                                .toArray();<br>        <span class="hljs-comment">// 矩阵遍历指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queries.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index : qIndexSort)&#123;<br>            <span class="hljs-keyword">while</span>(j &lt; mn &amp;&amp; gSort[j][<span class="hljs-number">0</span>] &lt; queries[index])&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> gSort[j][<span class="hljs-number">1</span>], b = gSort[j][<span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] item : help)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">newA</span> <span class="hljs-operator">=</span> a + item[<span class="hljs-number">0</span>], newB = b + item[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>(check(newA, newB, n, m) &amp;&amp; grid[newA][newB] &lt; queries[index])&#123;<br>                        union(a * m + b, newA * m + newB);<br>                    &#125;<br>                &#125;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt; queries[index])&#123;<br>               ans[index] = size[find(<span class="hljs-number">0</span>)];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>        x = find(x);<br>        y = find(y);<br>        <span class="hljs-keyword">if</span>(x == y)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(size[x] &lt; size[y])&#123;<br>            x = x ^ y;<br>            y = x ^ y;<br>            x = x ^ y;<br>        &#125;<br>        fa[y] = x;<br>        size[x] += size[y];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>        <span class="hljs-keyword">if</span>(fa[x] != x)&#123;<br>            fa[x] = find(fa[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> fa[x];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>离线询问</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-2499.让数组不相等的最小总代价</title>
    <link href="/2022/12/14/LC-2499-%E8%AE%A9%E6%95%B0%E7%BB%84%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E6%80%BB%E4%BB%A3%E4%BB%B7/"/>
    <url>/2022/12/14/LC-2499-%E8%AE%A9%E6%95%B0%E7%BB%84%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E6%80%BB%E4%BB%A3%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/minimum-total-cost-to-make-arrays-unequal/">leetcode 困难题</a></p><p>给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，两者长度都为 n 。</p><p>每次操作中，你可以选择交换 nums1 中任意两个下标处的值。操作的 开销 为两个下标的 和 。</p><p>你的目标是对于所有的 0 &lt;&#x3D; i &lt;&#x3D; n - 1 ，都满足 nums1[i] !&#x3D; nums2[i] ，你可以进行 任意次 操作，请你返回达到这个目标的 最小 总代价。</p><p>请你返回让 nums1 和 nums2 满足上述条件的 最小总代价 ，如果无法达成目标，返回 -1 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]<br>输出：10<br>解释：<br>实现目标的其中一种方法为：<br>- 交换下标为<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 3 </span>的两个值，代价为<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>。现在 nums1 = [4,2,3,1,5] 。<br>- 交换下标为<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 2 </span>的两个值，代价为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 3 </span>。现在 nums1 = [4,3,2,1,5] 。<br>- 交换下标为<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 4 </span>的两个值，代价为<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>。现在 nums1 = [5,3,2,1,4] 。<br>最后，对于每个下标 i ，都有 nums1[i] != nums2[i] 。总代价为<span class="hljs-number"> 10 </span>。<br>还有别的交换值的方法，但是无法得到代价和小于<span class="hljs-number"> 10 </span>的方案。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">n == nums1<span class="hljs-selector-class">.length</span> == nums2<span class="hljs-selector-class">.length</span><br><span class="hljs-number">1</span> &lt;= n &lt;= <span class="hljs-number">105</span><br><span class="hljs-number">1</span> &lt;= nums1<span class="hljs-selector-attr">[i]</span>, nums2<span class="hljs-selector-attr">[i]</span> &lt;= n<br></code></pre></td></tr></table></figure><h2 id="分类讨论-贪心"><a href="#分类讨论-贪心" class="headerlink" title="分类讨论 + 贪心"></a>分类讨论 + 贪心</h2><p>定义所有 $num1[i] &#x3D;&#x3D; num2[i]$ 的总次数为 $count$，众数为 $most$，众数相等的次数为 $mostCount$</p><p>分类讨论：</p><ul><li>如果 $mostCount * 2 &lt;&#x3D; count$，则所有交换可以在这些已经相等的元素之间进行，答案为这些相等的元素下标之和</li><li>如果 $mostCount * 2 &gt; count$，则交换无法只在这些相等的元素之间进行，需要与其他原本就不相等的元素进行交换，由于要使代价最小，要尽量使用下标较小的元素，并且该下标的元素不能等于 $most$，每次使用会让 $count + 1$，直至满足 $mostCount * 2 &lt;&#x3D; count$。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTotalCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, most = <span class="hljs-number">0</span>, n = nums1.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums1[i] == nums2[i])&#123;<br>                count++;<br>                cnt[nums1[i]]++;<br>                ans += i;<br>                most = cnt[nums1[i]] &gt; cnt[most] ? nums1[i] : most;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n &amp;&amp; cnt[most] * <span class="hljs-number">2</span> &gt; count; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums1[i] != nums2[i] &amp;&amp; nums1[i] != most &amp;&amp; nums2[i] != most)&#123;<br>                count++;<br>                ans += i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt[most] * <span class="hljs-number">2</span> &lt;= count ? ans : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>思维题</tag>
      
      <tag>分类讨论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6262.图中最大星和</title>
    <link href="/2022/12/11/LC-6262-%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E6%98%9F%E5%92%8C/"/>
    <url>/2022/12/11/LC-6262-%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E6%98%9F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximum-star-sum-of-a-graph/">leetcode 中等题</a></p><p>给你一个 n 个点的无向图，节点从 0 到 n - 1 编号。给你一个长度为 n 下标从 0 开始的整数数组 vals ，其中 vals[i] 表示第 i 个节点的值。</p><p>同时给你一个二维整数数组 edges ，其中 edges[i] &#x3D; [ai, bi] 表示节点 ai 和 bi 之间有一条双向边。</p><p>星图 是给定图中的一个子图，它包含一个中心节点和 0 个或更多个邻居。换言之，星图是给定图中一个边的子集，且这些边都有一个公共节点。</p><p>下图分别展示了有 3 个和 4 个邻居的星图，蓝色节点为中心节点。</p><p><img src="/../img/Snipaste_2022-12-12_16-27-39.png"></p><p>星和 定义为星图中所有节点值的和。</p><p>给你一个整数 k ，请你返回 至多 包含 k 条边的星图中的 最大星和 。</p><p>示例1：</p><p><img src="/../img/Snipaste_2022-12-12_16-28-24.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：vals = <span class="hljs-comment">[1,2,3,4,10,-10,-20]</span>, edges = <span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[3,5]</span>,<span class="hljs-comment">[3,6]</span>]</span>, k = 2<br>输出：16<br>解释：上图展示了输入示例。<br>最大星和对应的星图在上图中用蓝色标出。中心节点是 3 ，星图中还包含邻居 1 和 4 。<br>无法得到一个和大于 16 且边数不超过 2 的星图。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">n</span> == vals.length<br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br>-<span class="hljs-number">10</span>^<span class="hljs-number">4</span> &lt;= vals[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-number">0</span> &lt;= edges.length &lt;= <span class="hljs-built_in">min</span>(<span class="hljs-built_in">n</span> * (<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>, <span class="hljs-number">10</span>^<span class="hljs-number">5</span>)<br>edges[i].length == <span class="hljs-number">2</span><br><span class="hljs-number">0</span> &lt;= ai, bi &lt;= <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span><br>ai != bi<br><span class="hljs-number">0</span> &lt;= k &lt;= <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="排序-暴力枚举"><a href="#排序-暴力枚举" class="headerlink" title="排序 + 暴力枚举"></a>排序 + 暴力枚举</h2><p>注意题目中：星图是给定图中一个边的子集，且<strong>这些边都有一个公共节点</strong>。</p><p>所以我们可以直接暴力枚举所有中心点，并根据 $vals$ 中的值对该点上的边进行排序，从而找出所有点中的最大值即可。</p><p>当然由于 $val$ 可能为负数，且题目为“至多包含k条边”，所以当权值出现负数时，该点就不需要继续往下添加边。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// List 版本</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxStarSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] vals, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> vals.length;<br>        List&lt;Integer&gt;[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        Arrays.setAll(g, i -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; edges.length; i++)&#123;<br>            g[edges[i][<span class="hljs-number">0</span>]].add(vals[edges[i][<span class="hljs-number">1</span>]]);<br>            g[edges[i][<span class="hljs-number">1</span>]].add(vals[edges[i][<span class="hljs-number">0</span>]]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> vals[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> vals[i];<br>            Collections.sort(g[i]);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> g[i].size() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt; g[i].size() - <span class="hljs-number">1</span> - k; j--)&#123;<br>                <span class="hljs-keyword">if</span>(g[i].get(j) &lt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                cur += g[i].get(j);<br>            &#125;<br>            ans = Math.max(ans, cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 优先队列版本</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxStarSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] vals, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> vals.length;<br>        PriorityQueue&lt;Integer&gt;[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>[n];<br>        Arrays.setAll(g, i -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;((a, b) -&gt; b - a));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; edges.length; i++)&#123;<br>            g[edges[i][<span class="hljs-number">0</span>]].offer(vals[edges[i][<span class="hljs-number">1</span>]]);<br>            g[edges[i][<span class="hljs-number">1</span>]].offer(vals[edges[i][<span class="hljs-number">0</span>]]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> vals[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> vals[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(!g[i].isEmpty() &amp;&amp; count &lt; k)&#123;<br>                <span class="hljs-keyword">if</span>(g[i].peek() &lt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                cur += g[i].poll();<br>                count++;<br>            &#125;<br>            ans = Math.max(ans, cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//https://leetcode.cn/u/arignote/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxStarSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] vals, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> k)</span> &#123;<br>    HashMap&lt;Integer, PriorityQueue&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>        map.computeIfAbsent(edge[<span class="hljs-number">0</span>], t -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;()).offer(-vals[edge[<span class="hljs-number">1</span>]]);<br>        map.computeIfAbsent(edge[<span class="hljs-number">1</span>], t -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;()).offer(-vals[edge[<span class="hljs-number">0</span>]]);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vals.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; k &amp;&amp; map.containsKey(i) &amp;&amp; !map.get(i).isEmpty() &amp;&amp; map.get(i).peek() &lt; <span class="hljs-number">0</span>; j++) &#123;<br>            vals[i] -= map.get(i).poll();<br>        &#125;<br>        max = Math.max(max, vals[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1691.堆叠长方体的最大高度</title>
    <link href="/2022/12/11/LC-1691-%E5%A0%86%E5%8F%A0%E9%95%BF%E6%96%B9%E4%BD%93%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/"/>
    <url>/2022/12/11/LC-1691-%E5%A0%86%E5%8F%A0%E9%95%BF%E6%96%B9%E4%BD%93%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/">leetcode 困难题</a></p><p>给你 n 个长方体 cuboids ，其中第 i 个长方体的长宽高表示为 cuboids[i] &#x3D; [widthi, lengthi, heighti]（下标从 0 开始）。请你从 cuboids 选出一个 子集 ，并将它们堆叠起来。</p><p>如果 widthi &lt;&#x3D; widthj 且 lengthi &lt;&#x3D; lengthj 且 heighti &lt;&#x3D; heightj ，你就可以将长方体 i 堆叠在长方体 j 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。</p><p>返回 堆叠长方体 cuboids 可以得到的 最大高度 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cuboids = [[50,45,20],[95,37,53],[45,23,12]]<br>输出：190<br>解释：<br>第<span class="hljs-number"> 1 </span>个长方体放在底部，53x37 的一面朝下，高度为<span class="hljs-number"> 95 </span>。<br>第<span class="hljs-number"> 0 </span>个长方体放在中间，45x20 的一面朝下，高度为<span class="hljs-number"> 50 </span>。<br>第<span class="hljs-number"> 2 </span>个长方体放在上面，23x12 的一面朝下，高度为<span class="hljs-number"> 45 </span>。<br>总高度是<span class="hljs-number"> 95 </span>+<span class="hljs-number"> 50 </span>+<span class="hljs-number"> 45 </span>=<span class="hljs-number"> 190 </span>。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">n</span> == cuboids.length<br><span class="hljs-attribute">1</span> &lt;= n &lt;= <span class="hljs-number">100</span><br><span class="hljs-attribute">1</span> &lt;= widthi, lengthi, heighti &lt;= <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>结论：将每个长方体的最长边作为高度是最优的。</p><p>这是因为如果长方体 $c2$ 可以叠在长方体 $c1$ 上面，即存在某种排列 $w2 &lt; w1$ 且 $l2 &lt; l1$ 且 $h2 &lt; h1$，那么将最长边作为高度也一定会满足堆叠条件，并且由于更上方的长方体 $c3$ 也必须满足条件 $w3,l3,h3 &lt; h2$，所以类似前面所说的，更上方的长方体也必然是将最长边作为高度才是最优的。</p><p>因此最优的堆叠方法一定是基于最长边作为高度的。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>由于因此最优的堆叠方法一定是基于最长边作为高度的。</p><p>设 $dp[i]$ 表示以第 $i$ 个长方体作为最底部长方体的最大高度，$dp$ 从 $1$ 开始，此时类似 <a href="https://wecgwm.github.io/2022/12/11/LC-300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/">LC-300-最长递增子序列</a>，转移方程为</p><p>$$<br>\begin{align}<br>&amp;dp(i) &#x3D; max\{dp(j)\} + curHeight　　　　 1 &lt;&#x3D; j &lt; i　and　w_{j-1} &lt; w_{i-1}　and　l_{j-1} &lt; l_{i-1}\\<br>\end{align}<br>$$</p><p>需要注意的是，<a href="https://wecgwm.github.io/2022/12/11/LC-300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/">LC-300-最长递增子序列</a> 由题目性质保证了能出现在子序列前方的元素下标必然小于当前元素下标。那么类似的，本题也需要保证在计算到某个 $dp[i]$ 时，能堆叠在当前长方体上面的状态已经全部计算完毕，也就是说要先对长方体数组进行排序，使满足 $w_j &lt;&#x3D; w_i, l_j &lt;&#x3D; l_i, h_j &lt;&#x3D; h_i$ 时，也必然满足 $j &lt;&#x3D; i$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxHeight</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] cuboids)</span> &#123;<br>        IntStream.range(<span class="hljs-number">0</span>, cuboids.length).forEach(i -&gt; Arrays.sort(cuboids[i]));<br>        Arrays.sort(cuboids, Comparator.&lt;<span class="hljs-type">int</span>[]&gt;comparingInt(arr -&gt; arr[<span class="hljs-number">2</span>])<br>                                        .thenComparingInt(arr -&gt; arr[<span class="hljs-number">1</span>])<br>                                        .thenComparingInt(arr -&gt; arr[<span class="hljs-number">0</span>]));<br>        <span class="hljs-comment">// dp[i] 表示第 i 个箱子在最下方的最大高度</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[cuboids.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; cuboids.length + <span class="hljs-number">1</span>; i++)&#123;<br>            dp[i] = cuboids[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(cuboids[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt;= cuboids[j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &amp;&amp; cuboids[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &gt;= cuboids[j - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&#123;<br>                    dp[i] = Math.max(dp[i], dp[j] + cuboids[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(dp).max().orElseThrow();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>类似 $dp$ 解法，也可以采用自顶向下的记忆化搜索，会减少一些无效状态的计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] cuboids;<br>    <span class="hljs-type">int</span>[] mem;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxHeight</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] cuboids)</span> &#123;<br>        IntStream.range(<span class="hljs-number">0</span>, cuboids.length).forEach(i -&gt; Arrays.sort(cuboids[i]));<br>        Arrays.sort(cuboids, Comparator.&lt;<span class="hljs-type">int</span>[]&gt;comparingInt(arr -&gt; arr[<span class="hljs-number">2</span>])<br>                                .thenComparingInt(arr -&gt; arr[<span class="hljs-number">1</span>])<br>                                .thenComparingInt(arr -&gt; arr[<span class="hljs-number">0</span>]));<br>        <span class="hljs-built_in">this</span>.cuboids = cuboids;    <br>        mem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[cuboids.length];<br>        Arrays.fill(mem, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> top, <span class="hljs-type">int</span> cur)</span>&#123;<br>        <span class="hljs-keyword">if</span>(cur &gt;= cuboids.length)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(top != - <span class="hljs-number">1</span> &amp;&amp; mem[top] != -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> mem[top];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> dfs(top, cur + <span class="hljs-number">1</span>); <span class="hljs-comment">// 初始化为当前长方体无法叠在上一个顶部长方体的下方</span><br>        <span class="hljs-keyword">if</span>(top == - <span class="hljs-number">1</span> || (cuboids[cur][<span class="hljs-number">0</span>] &gt;= cuboids[top][<span class="hljs-number">0</span>] &amp;&amp; cuboids[cur][<span class="hljs-number">1</span>] &gt;= cuboids[top][<span class="hljs-number">1</span>]))&#123;<br>            ret = Math.max(ret, cuboids[cur][<span class="hljs-number">2</span>] + dfs(cur, cur + <span class="hljs-number">1</span>)); <span class="hljs-comment">// 当前长方体可以放在上一个顶部长方体的下方</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(top != - <span class="hljs-number">1</span>)&#123;<br>            mem[top] = ret;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-300.最长递增子序列</title>
    <link href="/2022/12/11/LC-300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/12/11/LC-300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">leetcode 中等题</a></p><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="hljs-number">1</span><span class="language-xml"> &lt;= nums.length &lt;= </span><span class="hljs-number">2500</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">-10</span><span class="hljs-keyword">^4</span><span class="language-xml"> &lt;= nums[i] &lt;= </span><span class="hljs-number">10</span><span class="hljs-keyword">^4</span><br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>定义 $dp[i]$ 表示以第 $i$ 个元素结尾的最长子序列长度，有：</p><p>$$<br>\begin{align}<br>&amp;dp(i) &#x3D; max\{dp(j)\} + 1　　　　 0 &lt;&#x3D; j &lt; i　 \&amp;\&amp;　 nums[j] &lt; nums[i]\\<br>&amp;LIS&#x3D; max\{dp(i)\}　　　　　　 0 &lt;&#x3D; i &lt; n<br>\end{align}<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j] &lt; nums[i])&#123;<br>                    dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(dp).max().orElseThrow() + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="贪心-二分查找"><a href="#贪心-二分查找" class="headerlink" title="贪心 + 二分查找"></a>贪心 + 二分查找</h2><p>上面解法时间复杂度为 $O(N^2)$ ，另一种更快的解法是贪心 + 二分。</p><p>定义 $d[i]$ 表示长度为 $i$ 的子序列的最后一个元素，我们需要让最后一个元素尽量小，从而可以得出 $LIS$。</p><p>可知 $d$ 数组是单调递增的，因为假设存在 $dp[i] &lt; dp[j]$ 且 $i &gt; j$，那么该 $i$ 长度的子序列第 $j$ 个元素必然会小于 $d[j]$ ，这与 $d$ 的定义矛盾。</p><p>令 $maxLength$ 为当前最大子序列长度，依次遍历 $nums$，具体的 $maxLength$ 维护过程如下：</p><ul><li>如果当前元素 $nums[i]$ 大于 $d[maxLength]$ ，那么显然有 $d[++maxLength] &#x3D; nums[i]$</li><li>如果当前元素 $nums[i]$ 小于等于 $d[maxLength]$ ，为了让 $d$ 的定义正确，需要找到最后一个小于 $nums[i]$ 的 $d[lastLess]$，显然可以得出 $d[lastLess + 1] &#x3D; nums[i]$。稍微要注意的是这里之所以要找 “第一个小于的下一个坐标” 而不是“第一个大于”的下标，是因为“第一个大于”的下标的前一个元素，即 $d[firstLarge - 1]$ 可能等于 $nums[i]$，而因为题目要求子序列严格递增，所以显然无法由此推出 $d[firstLarge] &#x3D; nums[i]$。</li></ul><p>遍历 $nums$ 的时间复杂度为 $O(N)$，而搜索最后一个小于目标元素的下标可以使用二分查找缩小右边界的方法实现，时间复杂度 $O(logN)$，所以总时间复杂度为 $O(NlogN)$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        d[maxLength] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(d[maxLength] &lt; nums[i])&#123;<br>                d[++maxLength] = nums[i];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// Search for the last less than nums[i] index, because question require strictly increasing</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = maxLength;<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(d[mid] &lt; nums[i])&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    right = mid;<br>                &#125;<br>            &#125;<br>            d[left] = nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; 001011100<br>&#x2F;&#x2F; 001110100</p><p>01<br>&#x2F;&#x2F; 000<br>&#x2F;&#x2F; 001 010 011 110 101 111 </p>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>动态规划</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1687.从仓库到码头运输箱子</title>
    <link href="/2022/12/08/LC-1687-%E4%BB%8E%E4%BB%93%E5%BA%93%E5%88%B0%E7%A0%81%E5%A4%B4%E8%BF%90%E8%BE%93%E7%AE%B1%E5%AD%90/"/>
    <url>/2022/12/08/LC-1687-%E4%BB%8E%E4%BB%93%E5%BA%93%E5%88%B0%E7%A0%81%E5%A4%B4%E8%BF%90%E8%BE%93%E7%AE%B1%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/">leetcode 困难题</a></p><p>你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有 箱子数目的限制 和 总重量的限制 。</p><p>给你一个箱子数组 boxes 和三个整数 portsCount, maxBoxes 和 maxWeight ，其中 boxes[i] &#x3D; [ports​​i​, weighti] 。</p><p>ports​​i 表示第 i 个箱子需要送达的码头， weightsi 是第 i 个箱子的重量。<br>portsCount 是码头的数目。<br>maxBoxes 和 maxWeight 分别是卡车每趟运输箱子数目和重量的限制。<br>箱子需要按照 数组顺序 运输，同时每次运输需要遵循以下步骤：</p><p>卡车从 boxes 队列中按顺序取出若干个箱子，但不能违反 maxBoxes 和 maxWeight 限制。<br>对于在卡车上的箱子，我们需要 按顺序 处理它们，卡车会通过 一趟行程 将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 额外行程 ，箱子也会立马被卸货。<br>卡车上所有箱子都被卸货后，卡车需要 一趟行程 回到仓库，从箱子队列里再取出一些箱子。<br>卡车在将所有箱子运输并卸货后，最后必须回到仓库。</p><p>请你返回将所有箱子送到相应码头的 最少行程 次数。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6<br>输出：6<br>解释：最优策略如下：<br>- 卡车首先运输第一个箱子，到达码头<span class="hljs-number"> 1 </span>，然后回到仓库，总共<span class="hljs-number"> 2 </span>趟行程。<br>- 卡车运输第二、第三、第四个箱子，到达码头<span class="hljs-number"> 3 </span>，然后回到仓库，总共<span class="hljs-number"> 2 </span>趟行程。<br>- 卡车运输第五个箱子，到达码头<span class="hljs-number"> 2 </span>，回到仓库，总共<span class="hljs-number"> 2 </span>趟行程。<br>总行程数为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 6 </span>。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= boxes.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= portsCount, maxBoxes, maxWeight &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= ports​​i &lt;= portsCount<br><span class="hljs-symbol">1 </span>&lt;= weightsi &lt;= maxWeight<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>以下前缀和或 $dp$ 数组为了方便下标都从 $1$ 开始到 $n$ 结束。</p><p>定义 $w$ 为重量前缀和数组；$diff$ 为“相邻不相等码头”前缀和数组，即 $diff[j]$ 表示 $[0, j]$ 区间箱子的相邻不相等码头的和。</p><p>利用 $diff$ 可以 $O(1)$ 的求出一趟车的最小行程，设该趟车第一个箱子为 $x$ ，最后一个箱子为 $y$ ，那么该趟的最小行程为 $diff[y] - diff[x] + 2$，其中 $2$ 是因为汽车离开仓库和返回仓库所消耗行程。</p><p>定义 $dp[i]$ 表示 $[0, i - 1]$ 区间箱子的最少行程数，$i - 1$ 显然为某趟车的最后一个箱子下标，那么 $dp[n]$ 为答案。</p><p>具体转移过程如下，对于每个 $dp[i]$，枚举上一趟车最后一个箱子的可能性 $dp[j]$，那么其在 $boxes$ 中的下标为 $j - 1$ ，也就是说 $j$ 为该趟车第一个箱子，简略的转移方程为： </p><p>$$<br>\begin{align}<br>&amp;dp(i) &#x3D; max(dp[j] + diff[i - 1] - diff[j] + 2) 　　　　　　　max(0, i - maxBoxes) &lt;&#x3D; j &lt; i\\<br>\end{align}<br>$$</p><p>该解法时间复杂度为 $O(N^2)$ ，会 TLE 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">boxDelivering</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] boxes, <span class="hljs-type">int</span> portsCount, <span class="hljs-type">int</span> maxBoxes, <span class="hljs-type">int</span> maxWeight)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> boxes.length;<br>        <span class="hljs-type">int</span>[] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 实际运算中，这里 n 下标并没有用到</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            w[i] = w[i - <span class="hljs-number">1</span>] + boxes[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            diff[i] = i == n || boxes[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == boxes[i][<span class="hljs-number">0</span>] ? diff[i - <span class="hljs-number">1</span>] : diff[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// dp[i] 表示 i 个箱子的最少行程数</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, Integer.MAX_VALUE);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, i - maxBoxes); j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(w[i] - w[j] &gt; maxWeight)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i] = Math.min(dp[i], dp[j] + diff[i - <span class="hljs-number">1</span>] - diff[j] + <span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划-单调队列"><a href="#动态规划-单调队列" class="headerlink" title="动态规划 + 单调队列"></a>动态规划 + 单调队列</h2><p>观察上面的转移过程可知，内层循环实际上是在 $[max(0, i - maxBoxes), i - 1]$ 窗口内找到一个满足要求的 $dp[j] - diff[j]$ 最小值，所以我们可以利用单调队列来实现 $O(1)$ 获取最小值。</p><p>每个下标最多进队一次出队一次，内层最多总共循环 $n$ 次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">boxDelivering</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] boxes, <span class="hljs-type">int</span> portsCount, <span class="hljs-type">int</span> maxBoxes, <span class="hljs-type">int</span> maxWeight)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> boxes.length;<br>        <span class="hljs-type">int</span>[] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            w[i] = w[i - <span class="hljs-number">1</span>] + boxes[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            diff[i] = i == n || boxes[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == boxes[i][<span class="hljs-number">0</span>] ? diff[i - <span class="hljs-number">1</span>] : diff[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// dp[i] 表示 i 个箱子的最少行程数</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        deque.offerLast(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; (i - deque.peekFirst() &gt; maxBoxes || w[i] - w[deque.peekFirst()] &gt; maxWeight))&#123;<br>                deque.pollFirst();<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> deque.peekFirst(); <span class="hljs-comment">// If NPE, there is no legal solution.</span><br>            dp[i] = dp[min] + diff[i - <span class="hljs-number">1</span>] - diff[min] + <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; (dp[i] - diff[i] &lt; dp[deque.peekLast()] - diff[deque.peekLast()]))&#123;<br>                deque.pollLast();<br>            &#125;<br>            deque.offerLast(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1775.通过最少操作次数使数组的和相等</title>
    <link href="/2022/12/08/LC-1775-%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89/"/>
    <url>/2022/12/08/LC-1775-%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/">leetcode 中等题</a></p><p>给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。</p><p>每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。</p><p>请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。</p><p>示例1：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">3</span><br>解释：你可以通过 <span class="hljs-number">3</span> 次操作使 <span class="hljs-symbol">nums1</span> 中所有数的和与 <span class="hljs-symbol">nums2</span> 中所有数的和相等。以下数组下标都从 <span class="hljs-number">0</span> 开始。<br>- 将 <span class="hljs-symbol">nums2</span>[<span class="hljs-number">0</span>] 变为 <span class="hljs-number">6</span> 。 <span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] 。<br>- 将 <span class="hljs-symbol">nums1</span>[<span class="hljs-number">5</span>] 变为 <span class="hljs-number">1</span> 。 <span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] 。<br>- 将 <span class="hljs-symbol">nums1</span>[<span class="hljs-number">2</span>] 变为 <span class="hljs-number">2</span> 。 <span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] 。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums1.length, nums2.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= nums1[i], nums2[i] &lt;= <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>设两个数组的和为 $sum1$ 、$sum2$，两者的差为 $diff$ 。</p><p>并且为了不失一般性，我们使 $nums1$ 的和始终是大于 $nums2$ 的。</p><p>因为需要通过最少次数使两个数组和相等，也就是使 $diff$ 尽快小于 $0$。那么为了更快的减少 $diff$ ，显然我们只能令 $nums1$ 中的某个数 $x$ 变成 $max(1, x - diff))$，这样一来 $x$ 对 $diff$ 贡献即为 $x - max(1, x - diff)$，同样为了更快的减少 $diff$ ，我们要尽可能的从更大贡献值的 $x$ 开始操作；对于 $num2$ 也同理，近似的改成相反操作即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        Map&lt;Integer, Integer&gt; count1 = Arrays.stream(nums1).boxed().collect(Collectors.toMap(Function.identity(), k -&gt; <span class="hljs-number">1</span>, Integer::sum));<br>        Map&lt;Integer, Integer&gt; count2 = Arrays.stream(nums2).boxed().collect(Collectors.toMap(Function.identity(), k -&gt; <span class="hljs-number">1</span>, Integer::sum));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> Arrays.stream(nums1).sum() - Arrays.stream(nums2).sum();<br>        <span class="hljs-keyword">if</span>(diff &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 为了统一, 让 count1 始终大于 count2</span><br>            diff = -diff;<br>            Map&lt;Integer, Integer&gt; tempMap = count1;<br>            count1 = count2;<br>            count2 = tempMap;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(diff &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> ans;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> count1.entrySet().stream().filter(e -&gt; e.getValue() &gt; <span class="hljs-number">0</span>).map(Map.Entry::getKey).mapToInt(Integer::valueOf).max().orElseThrow();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> count2.entrySet().stream().filter(e -&gt; e.getValue() &gt; <span class="hljs-number">0</span>).map(Map.Entry::getKey).mapToInt(Integer::valueOf).min().orElseThrow();<br>            <span class="hljs-keyword">while</span>(max - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">6</span> - min &amp;&amp; diff &gt; <span class="hljs-number">0</span> &amp;&amp; count1.getOrDefault(max, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">1</span>, max - diff);<br>                <span class="hljs-keyword">if</span>(max == to)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                diff -= max - to;<br>                count1.compute(max, (key, old) -&gt; --old);<br>                count1.compute(to, (key, old) -&gt; old == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : ++old);<br>                ans++;<br>                max = count1.entrySet().stream().filter(e -&gt; e.getValue() &gt; <span class="hljs-number">0</span>).map(Map.Entry::getKey).mapToInt(Integer::valueOf).max().orElseThrow();<br>            &#125;<br>            <span class="hljs-keyword">while</span>(max - <span class="hljs-number">1</span> &lt; <span class="hljs-number">6</span> - min &amp;&amp; diff &gt; <span class="hljs-number">0</span> &amp;&amp; count2.getOrDefault(min, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> Math.min(<span class="hljs-number">6</span>, min + diff);<br>                <span class="hljs-keyword">if</span>(min == to)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                diff -= to - min;<br>                count2.compute(min, (key, old) -&gt; --old);<br>                count2.compute(to, (key, old) -&gt; old == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : ++old);<br>                ans++;<br>                min = count2.entrySet().stream().filter(e -&gt; e.getValue() &gt; <span class="hljs-number">0</span>).map(Map.Entry::getKey).mapToInt(Integer::valueOf).min().orElseThrow();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ans == temp)&#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表优化"><a href="#哈希表优化" class="headerlink" title="哈希表优化"></a>哈希表优化</h2><p>上面的解法代码过于复杂，我们可以通过哈希表来存储不同元素对于 $diff$ 的贡献，这样一来只需要从大到小遍历贡献值以减少 $diff$ 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        Map&lt;Integer, Integer&gt; count1 = Arrays.stream(nums1).boxed().collect(Collectors.toMap(Function.identity(), k -&gt; <span class="hljs-number">1</span>, Integer::sum));<br>        Map&lt;Integer, Integer&gt; count2 = Arrays.stream(nums2).boxed().collect(Collectors.toMap(Function.identity(), k -&gt; <span class="hljs-number">1</span>, Integer::sum));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> Arrays.stream(nums1).sum() - Arrays.stream(nums2).sum();<br>        <span class="hljs-keyword">if</span>(diff &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 让 count1 始终大于 count2</span><br>            diff = -diff;<br>            Map&lt;Integer, Integer&gt; tempMap = count1;<br>            count1 = count2;<br>            count2 = tempMap;<br>        &#125;<br>        <span class="hljs-type">int</span>[] d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">7</span>]; <span class="hljs-comment">// 通过哈希表存储贡献值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>; i &gt;= <span class="hljs-number">2</span>; i--)&#123;<br>            d[i] += count1.getOrDefault(i, <span class="hljs-number">0</span>);<br>            d[i] += count2.getOrDefault(<span class="hljs-number">7</span> - i, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>; i &gt;= <span class="hljs-number">2</span> &amp;&amp; diff &gt; <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curCount</span> <span class="hljs-operator">=</span> Math.min(d[i], (diff + i - <span class="hljs-number">2</span>) / (i - <span class="hljs-number">1</span>)); <span class="hljs-comment">// 后者是 diff / (i - 1) 的向上取整</span><br>            ans += curCount;<br>            diff -= curCount * (i - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> diff &lt;= <span class="hljs-number">0</span> ? ans : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1774.最接近目标价格的甜点成本</title>
    <link href="/2022/12/04/LC-1774-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E4%BB%B7%E6%A0%BC%E7%9A%84%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC/"/>
    <url>/2022/12/04/LC-1774-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E4%BB%B7%E6%A0%BC%E7%9A%84%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/closest-dessert-cost/">leetcode 中等题</a></p><p>你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。而制作甜点需要遵循以下几条规则：</p><ul><li>必须选择 一种 冰激凌基料。</li><li>可以添加 一种或多种 配料，也可以不添加任何配料。</li><li>每种类型的配料 最多两份 。</li></ul><p>给你以下三个输入：</p><ul><li>baseCosts ，一个长度为 n 的整数数组，其中每个 baseCosts[i] 表示第 i 种冰激凌基料的价格。</li><li>toppingCosts，一个长度为 m 的整数数组，其中每个 toppingCosts[i] 表示 一份 第 i 种冰激凌配料的价格。</li><li>target ，一个整数，表示你制作甜点的目标价格。<br>你希望自己做的甜点总成本尽可能接近目标价格 target 。</li></ul><p>返回最接近 target 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：baseCosts = [1,7], toppingCosts = [3,4], target = 10<br>输出：10<br>解释：考虑下面的方案组合（所有下标均从<span class="hljs-number"> 0 </span>开始）：<br>- 选择<span class="hljs-number"> 1 </span>号基料：成本 7<br>- 选择<span class="hljs-number"> 1 </span>份<span class="hljs-number"> 0 </span>号配料：成本<span class="hljs-number"> 1 </span>x<span class="hljs-number"> 3 </span>= 3<br>- 选择<span class="hljs-number"> 0 </span>份<span class="hljs-number"> 1 </span>号配料：成本<span class="hljs-number"> 0 </span>x<span class="hljs-number"> 4 </span>= 0<br>总成本：7 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 0 </span>=<span class="hljs-number"> 10 </span>。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">n</span> == baseCosts.length<br><span class="hljs-attribute">m</span> == toppingCosts.length<br><span class="hljs-attribute">1</span> &lt;= n, m &lt;= <span class="hljs-number">10</span><br><span class="hljs-attribute">1</span> &lt;= baseCosts[i], toppingCosts[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-attribute">1</span> &lt;= target &lt;= <span class="hljs-number">104</span><br></code></pre></td></tr></table></figure><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>对每一种基料利用回溯模拟每个方案的成本。对于每个基料，每种配料存在三种可能：不加入\加入一次\加入两次。并且显然当某个方案的成本超出了 $target$ 时，可以不再往下搜索，因为继续往下差距只会继续拉大。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] toppingCosts;<br>    <span class="hljs-type">int</span> target;<br>    <span class="hljs-type">int</span> ans;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closestCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] baseCosts, <span class="hljs-type">int</span>[] toppingCosts, <span class="hljs-type">int</span> target)</span> &#123;<br>       ans = Arrays.stream(baseCosts).min().getAsInt();<br>       <span class="hljs-built_in">this</span>.toppingCosts = toppingCosts;<br>       <span class="hljs-built_in">this</span>.target = target;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> item : baseCosts)&#123;<br>           dfs(<span class="hljs-number">0</span>, item); <br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> curCost)</span>&#123;<br>        <span class="hljs-keyword">if</span>(Math.abs(target - ans) &lt; Math.abs(target - curCost) &amp;&amp; target &lt; curCost)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Math.abs(target - ans) == Math.abs(target - curCost))&#123;<br>            ans = Math.min(ans, curCost);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Math.abs(target - ans) &gt; Math.abs(target - curCost))&#123;<br>            ans = curCost;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p == toppingCosts.length)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(p + <span class="hljs-number">1</span>, curCost);<br>        dfs(p + <span class="hljs-number">1</span>, curCost + toppingCosts[p]);<br>        dfs(p + <span class="hljs-number">1</span>, curCost + (toppingCosts[p] * <span class="hljs-number">2</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举-二分查找左边界"><a href="#枚举-二分查找左边界" class="headerlink" title="枚举 + 二分查找左边界"></a>枚举 + 二分查找左边界</h2><p>每种配料最多可以选两次，我们可以把每种配料看作存在两份，类似 $[top1, top2, top1, top2]$ ，那么对于某种方案，就可以视为拆分后每个配料只存在两种情况，加入或者不加入。接着我们可以枚举其中一半的拆分后配料的子集和，然后通过二分查找得到使总和最接近 $target$ 的另一半配料的成本和。</p><p>稍微要注意的是，这里我们通过二分查找搜索的是左边界，也就是说最接近的下标只可能是 $\{left, left - 1\}$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] toppingCosts;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">inf</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closestCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] baseCosts, <span class="hljs-type">int</span>[] toppingCosts, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.toppingCosts = toppingCosts;<br>        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        Collections.sort(arr);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> inf;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : baseCosts) &#123;<br>            <span class="hljs-comment">// 枚举子集和</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : arr) &#123;<br>                <span class="hljs-comment">// 二分查找</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> search(target - x - y);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;i, i - <span class="hljs-number">1</span>&#125;) &#123;<br>                    <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; arr.size()) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">curCost</span> <span class="hljs-operator">=</span> x + y + arr.get(j);<br>                        <span class="hljs-keyword">if</span> (Math.abs(ans - target) &gt; Math.abs(curCost - target) <br>                        || (Math.abs(ans - target) == Math.abs(curCost - target) &amp;&amp; ans &gt; curCost)) &#123;<br>                            ans = curCost;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= toppingCosts.length) &#123;<br>            arr.add(t);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(i + <span class="hljs-number">1</span>, t);<br>        dfs(i + <span class="hljs-number">1</span>, t + toppingCosts[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = arr.size();<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (arr.get(mid) &lt; x) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举-二分查找右边界"><a href="#枚举-二分查找右边界" class="headerlink" title="枚举 + 二分查找右边界"></a>枚举 + 二分查找右边界</h2><p>类似的，可以使用二分查找右边界的方法进行搜索，此时最接近的下标只可能是 $\{left - 1, left\}$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java">...<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closestCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] baseCosts, <span class="hljs-type">int</span>[] toppingCosts, <span class="hljs-type">int</span> target)</span> &#123;<br>                ...<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;i, i + <span class="hljs-number">1</span>&#125;) &#123;<br>                ...<br>    &#125;<br>...<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = arr.size();<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (arr.get(mid) &gt; x) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left - <span class="hljs-number">1</span>;<br>    &#125;<br>...<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>将问题转换成某个成本是否存在可行方案的问题，然后选择最接近目标的成本即可，此时问题转换成了 <code>01背包</code>。</p><p>$dp[i]$ 为 $true$ 表示 $i$ 成本存在可行方案，初始化为 $false$ 表示不存在。</p><p>当某个基料已经大于 $target$ 时，这种情况不应该选择配料，因为选择配料只会使差距更大，并且大于 target 的合法成本只需要保留最小的一份即可，所以背包容量设为 $target$ 即可。</p><p>并且由于单独选择基料是合法的，所以如果存在 $base[x] &#x3D; i$ ，那么 $dp[i] &#x3D; true$。</p><p>接下来类似 <code>01背包</code> 枚举配料的选择，由于每个配料最多选择两次，所以类似上面二分查找的解法，将每种配料视为存在两种。</p><p>任意一个合法方案加一份配料也为合法方案，所以当前配料成本为 $y$ 时，对于开销 $c$ ，转移方程为：</p><p>$$<br>\begin{align}<br>&amp;dp(c)　 |&#x3D;　dp(c - y)　　　　　　　　　　　　　　　　　　　 c &gt; y\\<br>\end{align}<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closestCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] base, <span class="hljs-type">int</span>[] top, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[target + <span class="hljs-number">5</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : base) &#123; <br>            <span class="hljs-keyword">if</span> (x &gt; target) ans = Math.min(ans, x); <span class="hljs-comment">// 只选基料</span><br>            <span class="hljs-keyword">else</span> dp[x] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : top) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123; <span class="hljs-comment">// 拆分成两份</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                    <span class="hljs-keyword">if</span> (dp[j] &amp;&amp; j + x &gt; target) ans = Math.min(ans, j + x); <span class="hljs-comment">// 大于 target 的合法成本只需要保留最小的一份即可</span><br>                    <span class="hljs-keyword">if</span> (j &gt; x) dp[j] |= dp[j - x];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> target; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span>(target - i &gt; ans - target)&#123;<br>                <span class="hljs-comment">// 剩余的只会比 ans 差距更大</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i]) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>二分查找</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-895.最大频率栈</title>
    <link href="/2022/11/30/LC-895-%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/"/>
    <url>/2022/11/30/LC-895-%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximum-frequency-stack/">leetcode 困难题</a></p><p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。</p><p>实现 FreqStack 类:</p><ul><li>FreqStack() 构造一个空的堆栈。</li><li>void push(int val) 将一个整数 val 压入栈顶。</li><li>int pop() 删除并返回堆栈中出现频率最高的元素。<ul><li>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</li></ul></li></ul><p>示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;FreqStack&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>],<br>[[],[<span class="hljs-number">5</span>],[<span class="hljs-number">7</span>],[<span class="hljs-number">5</span>],[<span class="hljs-number">7</span>],[<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>],[],[],[],[]]<br>输出：[null,null,null,null,null,null,null,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-number">0</span> &lt;= val &lt;= <span class="hljs-number">109</span><br><span class="hljs-built_in">push</span> 和 <span class="hljs-built_in">pop</span> 的操作数不大于 <span class="hljs-number">2</span> * <span class="hljs-number">104</span>。<br>输入保证在调用 <span class="hljs-built_in">pop</span> 之前堆栈中至少有一个元素。<br></code></pre></td></tr></table></figure><h2 id="哈希表-大根堆"><a href="#哈希表-大根堆" class="headerlink" title="哈希表 + 大根堆"></a>哈希表 + 大根堆</h2><p>比较复杂的做法是使用哈希表 $indexListMap$ 维护元素和出现过的下标集合之间的映射关系，再使用大根堆维护元素之间的排序关系：出现频率更高的在队列首部，频率相同时取下标更大的。</p><p>缺点是由于相同元素在优先队列中只存储一次，所以每次 $push$ 或者 $pop$ 操作的时候都需要将当前元素从有限队列中移除后再重新加入，因为此时优先关系可能会发生变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FreqStack</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, List&lt;Integer&gt;&gt; indexListMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;<br>        List&lt;Integer&gt; index1 = indexListMap.get(a);<br>        List&lt;Integer&gt; index2 = indexListMap.get(b);<br>        <span class="hljs-keyword">if</span>(index1.size() != index2.size())&#123;<br>            <span class="hljs-keyword">return</span> index2.size() - index1.size();<br>        &#125;<br>        <span class="hljs-keyword">return</span> index2.get(index2.size() - <span class="hljs-number">1</span>) - index1.get(index1.size() - <span class="hljs-number">1</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(indexListMap.containsKey(val))&#123;<br>            maxHeap.remove(val);<br>            indexListMap.get(val).add(index++);<br>            maxHeap.offer(val);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;  <br>        List&lt;Integer&gt; indexList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(List.of(index++));<br>        indexList.add(index++);<br>        indexListMap.put(val, indexList);<br>        maxHeap.offer(val);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> maxHeap.poll();<br>        List&lt;Integer&gt; index = indexListMap.get(val);<br>        <span class="hljs-keyword">if</span>(index.size() == <span class="hljs-number">1</span>)&#123;<br>            indexListMap.remove(val);<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>        index.remove(index.size() - <span class="hljs-number">1</span>);<br>        maxHeap.offer(val);<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表-大根堆-优化"><a href="#哈希表-大根堆-优化" class="headerlink" title="哈希表 + 大根堆 优化"></a>哈希表 + 大根堆 优化</h2><p>更简单的做法是哈希表只维护元素和出现频率之间的关系，使用大根堆存储一个三元组 ${val, index, cnt}$ 分别代表元素本身、当前下标、当前频率，排序规则同上。</p><p>由于优先队列保存了完整的数据，即每个元素出现了几次就会出现在队列中几次，所以效率更高代码也更简洁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FreqStack</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Integer&gt; COUNT_MAP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// int&#123;val, index, cnt&#125;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; MAX = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b[<span class="hljs-number">2</span>] != a[<span class="hljs-number">2</span>] ? b[<span class="hljs-number">2</span>] - a[<span class="hljs-number">2</span>] : b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>]);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> COUNT_MAP.compute(val, (key, old) -&gt; old == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : ++old);<br>        MAX.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;val, index++, count&#125;);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] a = MAX.poll();<br>        COUNT_MAP.compute(a[<span class="hljs-number">0</span>], (key, count) -&gt; --count);<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表-栈"><a href="#哈希表-栈" class="headerlink" title="哈希表 + 栈"></a>哈希表 + 栈</h2><p>在上面的做法中，由于我们使用到了优先队列，所以每次入队和出队时间复杂度都为 $log(N)$ 。</p><p>另一种做法同样是使用哈希表维护元素和出现频率之间的关系，但是不再使用优先队列而是使用另一个哈希表来维护每种出现频率和对应的栈之间的关系，即会有多个栈。</p><p>稍微要注意的是，假设某个元素出现了 $5$ 次，那么在频率为 $1,2,3,4,5$ 的栈中都会有该元素，所以每当最大的栈为空时，我们只需要将最大栈的变量减一即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FreqStack</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Integer&gt; freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Deque&lt;Integer&gt;&gt; groupStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> freq.compute(val, (key, old) -&gt; old == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : ++old);<br>        groupStack.compute(x, (key, old) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(old == <span class="hljs-literal">null</span>)&#123;<br>                old = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>            &#125;<br>            old.push(val);<br>            <span class="hljs-keyword">return</span> old;<br>        &#125;);<br>        max = Math.max(max, x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        Deque&lt;Integer&gt; stack = groupStack.get(max);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> stack.pop();<br>        <span class="hljs-keyword">if</span>(stack.isEmpty())&#123;<br>            max--; <span class="hljs-comment">// 如果某个元素出现了 5 次，那么在频率为 1,2,3,4,5 的栈中都会有该元素</span><br>        &#125;<br>        freq.compute(val, (key, old) -&gt; --old);<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表-List"><a href="#哈希表-List" class="headerlink" title="哈希表 + List"></a>哈希表 + List</h2><p>类似上一种做法，可以使用哈希表加上 $List$ 来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FreqStack</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Integer&gt; freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Deque&lt;Integer&gt;&gt; stackList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> freq.getOrDefault(val, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(x == stackList.size())&#123;<br>            stackList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;());<br>        &#125;<br>        stackList.get(x).push(val);<br>        freq.put(val, x + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        Deque&lt;Integer&gt; last = stackList.get(stackList.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> last.pop();<br>        <span class="hljs-keyword">if</span>(last.isEmpty())&#123;<br>            stackList.remove(stackList.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>        freq.compute(val, (__, old) -&gt; --old);<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-115.不同的子序列</title>
    <link href="/2022/11/29/LC-115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/11/29/LC-115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/distinct-subsequences/">leetcode 困难题</a></p><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p>示例1：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;rabbbit&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;rabbit&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>如下图所示, 有 <span class="hljs-number">3</span> 种可以从 s 中得到 <span class="hljs-string">&quot;rabbit&quot;</span> 的方案。<br>rabbbit<br>rabbbit<br>rabbbit<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">0</span> &lt;= s.<span class="hljs-built_in">length</span>, t.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">1000</span><br>s 和 t 由英文字母组成<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>定义 $dp[i][j]$ 表示子串 $s[0…i]$ 中子序列 $t[0…j]$ 出现的个数。</p><p>令 $dp$ 从 $0$ 开始，表示空串。并且当 $j &#x3D; 0$ 时，$dp[i][0]$ 为 $1$ ，因为空字符串是任何字符串的子序列。其他情况下：</p><p>$$<br>\begin{align}<br>&amp;dp(i, j) &#x3D; dp(i - 1, j)　　　　　　　　　　　　 　 s[i - 1] \ne t[j - 1] \\<br>&amp;dp(i, j) &#x3D; dp(i - 1, j) + dp(i - 1, j - 1)　　　　 s[i - 1] &#x3D; t[j - 1] \\<br>\end{align}<br>$$</p><p>$dp[n][m]$ 为答案，$n$ 和 $m$ 分别为两个字符串的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-comment">// dp[i][j] 表示子串 s[0...i] 中子序列 t[0...j] 出现的个数</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">if</span>(s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] += dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><p>每一层只依赖上一层的结果，逆序遍历即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= <span class="hljs-number">1</span>; j--)&#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                    dp[j] += dp[j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-813.最大平均值和的分组</title>
    <link href="/2022/11/28/LC-813-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/"/>
    <url>/2022/11/28/LC-813-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/largest-sum-of-averages/">leetcode 中等题</a></p><p>给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成 最多 k 个相邻的非空子数组 。 分数 由每个子数组内的平均值的总和构成。</p><p>注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。</p><p>返回我们所能得到的最大 分数 是多少。答案误差在 $10^{-6}$ 内被视为是正确的。</p><p>示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: nums = [<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>], k = <span class="hljs-number">3</span><br>输出: <span class="hljs-number">20.00000</span><br>解释: <br>nums 的最优分组是[<span class="hljs-number">9</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">9</span>]. 得到的分数是 <span class="hljs-number">9</span> + (<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span>) / <span class="hljs-number">3</span> + <span class="hljs-number">9</span> = <span class="hljs-number">20.</span> <br>我们也可以把 nums 分成[<span class="hljs-number">9</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>]. <br>这样的分组得到的分数为 <span class="hljs-number">5</span> + <span class="hljs-number">2</span> + <span class="hljs-number">6</span> = <span class="hljs-number">13</span>, 但不是最大值.<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">100</span><br><span class="hljs-symbol">1 </span>&lt;= nums[i] &lt;= <span class="hljs-number">104</span><br><span class="hljs-symbol">1 </span>&lt;= k &lt;= nums.length<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>定义 $dp[i][j]$ 表示子数组 $[0…i]$ 分成 $j$ 段的最大分数。<br>为了方便，令 $i$ 和 $j$ 从 $1$ 开始，简略的状态转移方程如下:</p><p>$$<br>\begin{align}<br>&amp;dp(i, j) &#x3D; \frac{sum(nums[0] … nums[i - 1])}{i}　　　　　　　　　　　　　　　　　　　 j &#x3D; 1\\<br>&amp;dp(i, j) &#x3D; max\{dp(x, j - 1) + \frac{sum(nums[x + 1] … nums[i])}{i - x}\}　　　　 1 &lt;j ,　j - 1 &lt;&#x3D; x &lt; i \\<br>\end{align}<br>$$</p><p>$dp[n][k]$ 为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">largestSumOfAverages</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// dp[i][j] 表示i区间分j组的最大分数</span><br>        <span class="hljs-type">double</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n + <span class="hljs-number">1</span>][k + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k; j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">1</span>)&#123;<br>                    dp[i][j] = ((<span class="hljs-type">double</span>)preSum[i] - preSum[<span class="hljs-number">0</span>]) / i;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> j - <span class="hljs-number">1</span>; p &lt; i; p++)&#123;<br>                    <span class="hljs-type">double</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> dp[p][j - <span class="hljs-number">1</span>] + ((<span class="hljs-type">double</span>)preSum[i] - preSum[p]) / (i - (p + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>); <br>                    dp[i][j] = Math.max(dp[i][j], temp);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><p>类似01背包，可以进行滚动数组优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">largestSumOfAverages</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// dp[i][j] 表示i区间分j组的最大分数</span><br>        <span class="hljs-type">double</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k; j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt;= <span class="hljs-number">1</span>; i--)&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">1</span>)&#123;<br>                    dp[i] = ((<span class="hljs-type">double</span>)preSum[i] - preSum[<span class="hljs-number">0</span>]) / i;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> j - <span class="hljs-number">1</span>; p &lt; i; p++)&#123;<br>                    <span class="hljs-type">double</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> dp[p] + ((<span class="hljs-type">double</span>)preSum[i] - preSum[p]) / (i - (p + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>); <br>                    dp[i] = Math.max(dp[i], temp);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6248.统计中位数为K的子数组</title>
    <link href="/2022/11/28/LC-6248-%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/11/28/LC-6248-%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/count-subarrays-with-median-k/">leetcode 困难题</a></p><p>给你一个长度为 n 的数组 nums ，该数组由从 1 到 n 的 不同 整数组成。另给你一个正整数 k 。</p><p>统计并返回 num 中的 中位数 等于 k 的非空子数组的数目。</p><p>注意：</p><ul><li>数组的中位数是按 递增 顺序排列后位于 中间 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 左 的那个元素。<ul><li>例如，[2,3,1,4] 的中位数是 2 ，[8,4,3,5,1] 的中位数是 4 。</li></ul></li><li>子数组是数组中的一个连续部分。</li></ul><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,1,4,5]</span>, k = 4<br>输出：3<br>解释：中位数等于 4 的子数组有：<span class="hljs-comment">[4]</span>、<span class="hljs-comment">[4,5]</span> 和 <span class="hljs-comment">[1,4,5]</span> 。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">n</span> == nums.length<br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-number">1</span> &lt;= nums[i], k &lt;= <span class="hljs-built_in">n</span><br>nums 中的整数互不相同<br></code></pre></td></tr></table></figure><h2 id="等价转换"><a href="#等价转换" class="headerlink" title="等价转换"></a>等价转换</h2><p>由于是求中位数等于 $k$ 的子数组的个数，所以可以 <strong>把数组中大于 $k$ 的元素转换成 $1$ ，小于的转换成 $-1$ 。</strong>经过该转换后就可以利用类似前缀和的方式进行求解。并且由于该数组是一个数列，那么就只需要找到 $k$ 后通过用前缀和的做法向左右扩散即可。</p><p>具体来说，找到 $k$ 的位置后，选一个方向计算前缀和，并将该方向每个子数组的结果通过哈希表统计起来；然后遍历另一个方向，每次得出前缀和后，设其为 $preSum$，通过判断哈希表是否存在 $-preSum$ （偶数个数情况）和 $-preSum + 1$ （奇数个数情况），如果存在的话就可以加上对应的个数。当然，由题意可知如果是 $0$ 或者 $1$ 的话，直接将 $ans + 1$ 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(p++ &lt; n)&#123;<br>            <span class="hljs-keyword">if</span>(nums[p] == k)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        Map&lt;Integer, Integer&gt; sumCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 左边前缀和</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            sum[i] = i + <span class="hljs-number">1</span> &lt; n ? sum[i + <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>;<br>            sum[i] += nums[i] &gt; k ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>            sumCount.compute(sum[i], (key, old) -&gt; old == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span>: ++old);<br>        &#125;<br>        ans += sumCount.getOrDefault(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) + sumCount.getOrDefault(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 右边前缀和</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p + <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            sum[i] = i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> ? sum[i - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>;w<br>            sum[i] += nums[i] &gt; k ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(sum[i] == <span class="hljs-number">0</span> || sum[i] == <span class="hljs-number">1</span>)&#123;<br>                ans++;<br>            &#125;<br>            ans += sumCount.getOrDefault(-sum[i], <span class="hljs-number">0</span>);<br>            ans += sumCount.getOrDefault(-sum[i] + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>等价转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6251.统计回文子序列数目</title>
    <link href="/2022/11/28/LC-6251-%E7%BB%9F%E8%AE%A1%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/11/28/LC-6251-%E7%BB%9F%E8%AE%A1%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/count-palindromic-subsequences/">leetcode 困难题</a></p><p>给你数字字符串 s ，请你返回 s 中长度为 5 的 回文子序列 数目。由于答案可能很大，请你将答案对 $10^9 + 7$ 取余 后返回。</p><p>提示：</p><p>如果一个字符串从前往后和从后往前读相同，那么它是 回文字符串 。<br>子序列是一个字符串中删除若干个字符后，不改变字符顺序，剩余字符构成的字符串。</p><p>示例1：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;103301&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：<br>总共有 <span class="hljs-number">6</span> 长度为 <span class="hljs-number">5</span> 的子序列：<span class="hljs-string">&quot;10330&quot;</span> ，<span class="hljs-string">&quot;10331&quot;</span> ，<span class="hljs-string">&quot;10301&quot;</span> ，<span class="hljs-string">&quot;10301&quot;</span> ，<span class="hljs-string">&quot;13301&quot;</span> ，<span class="hljs-string">&quot;03301&quot;</span> 。<br>它们中有两个（都是 <span class="hljs-string">&quot;10301&quot;</span>）是回文的。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> &lt;= s.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-attribute">s</span> 只包含数字字符。<br></code></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>由于题目要求的子序列限定了长度必须为 $5$，那么我们可以通过枚举回文子序列的中心点来得出结果。</p><p>因为 $s$ 只包含数字字符，可知中心点的每侧字符只有 $10 \times 10$ 种可能（如果只包含字母的话就是 $24 \times 24$ 种可能），那么我们可以通过类似前缀和的方式进行枚举即可得到结果。</p><p>具体来说，我们预先通过一个 $right[10][10]$ 保存该数组所有长度为 $2$ 的子序列组合的个数、$rightCount[10]$ 保存每个不同字符的出现个数。然后 $i$ 从 $0$ 开始遍历，每次将当前字符的可能性从 $right[10][10]$ 和 $right[10]$ 中撤销，并累加到 $left[10][10]$ 和 $leftCount$ 中，再遍历所有 $left[10][10]$ ，那么通过乘法原理可知，以当前字符为中心的回文子序列个数就为每个 $left[a][b] \times right[b][a]$ 的总和。</p><p>题目给出 $n$ 范围为 $10^4$，内层最多循环 $10 \times 10$ 次，计算量为 $10^6$ ，不会 TLE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPalindromes</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>        <span class="hljs-type">int</span>[] rightCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">9</span>; j++)&#123;<br>                right[s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>][j] += rightCount[j];<br>            &#125;<br>            rightCount[s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>        <span class="hljs-type">int</span>[] leftCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            rightCount[item - <span class="hljs-string">&#x27;0&#x27;</span>]--;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">9</span>; j++)&#123;<br>                right[item - <span class="hljs-string">&#x27;0&#x27;</span>][j] -= rightCount[j];<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; a &lt;= <span class="hljs-number">9</span>; a++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; b &lt;= <span class="hljs-number">9</span>; b++)&#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> ans;<br>                    ans = (ans % MOD + ((<span class="hljs-type">long</span>)left[a][b] * right[b][a]) % MOD) % MOD;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">9</span>; j++)&#123;<br>                left[j][item - <span class="hljs-string">&#x27;0&#x27;</span>] += leftCount[j];<br>            &#125;<br>            leftCount[item - <span class="hljs-string">&#x27;0&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(ans % MOD);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举-动态规划"><a href="#枚举-动态规划" class="headerlink" title="枚举 + 动态规划"></a>枚举 + 动态规划</h2><p>另一种做法是枚举出长度为 $5$ 的回文串的所有可能，再将字符串中这些回文子序列出现的次数累加起来就是答案。</p><p>枚举出所有回文串需要循环 $10 \times 10 \times 10$ 次，求子序列出现次数计算量为 $5 \times 10^4$，总计算量为 $5 \times 10^7$ ，不会 TLE。</p><p><a href="https://wecgwm.github.io/2022/11/29/LC-115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/">LC-115：枚举某个子序列在字符串中出现次数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPalindromes</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">9</span>; j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= <span class="hljs-number">9</span>; k++)&#123;<br>                    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(i).append(j).append(k).append(j).append(i);<br>                    ans = (ans + help(s, sb.toString())) % MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(ans % MOD);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">help</span><span class="hljs-params">(String s, String t)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">if</span>(s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = (dp[i][j] + dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-882.细分图中的可到达节点</title>
    <link href="/2022/11/26/LC-882-%E7%BB%86%E5%88%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9/"/>
    <url>/2022/11/26/LC-882-%E7%BB%86%E5%88%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/">leetcode 困难题</a></p><p>给你一个无向图（原始图），图中有 n 个节点，编号从 0 到 n - 1 。你决定将图中的每条边 细分 为一条节点链，每条边之间的新节点数各不相同。</p><p>图用由边组成的二维数组 edges 表示，其中 edges[i] &#x3D; [ui, vi, cnti] 表示原始图中节点 ui 和 vi 之间存在一条边，cnti 是将边 细分 后的新节点总数。注意，cnti &#x3D;&#x3D; 0 表示边不可细分。</p><p>要 细分 边 [ui, vi] ，需要将其替换为 (cnti + 1) 条新边，和 cnti 个新节点。新节点为 x1, x2, …, xcnti ，新边为 [ui, x1], [x1, x2], [x2, x3], …, [xcnti+1, xcnti], [xcnti, vi] 。</p><p>现在得到一个 新的细分图 ，请你计算从节点 0 出发，可以到达多少个节点？如果节点间距离是 maxMoves 或更少，则视为 可以到达 。</p><p>给你原始图和 maxMoves ，返回 新的细分图中从节点 0 出发 可到达的节点数 。</p><p>示例1：<br><img src="/../img/Snipaste_2022-11-26_22-18-03.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：edges = <span class="hljs-string">[[0,1,10],[0,2,1],[1,2,2]]</span>, maxMoves = <span class="hljs-number">6</span>, n = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">13</span><br>解释：边的细分情况如上图所示。<br>可以到达的节点已经用黄色标注出来。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">0</span> &lt;= edges.length &lt;= <span class="hljs-built_in">min</span>(<span class="hljs-built_in">n</span> * (<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>, <span class="hljs-number">104</span>)<br>edges[i].length == <span class="hljs-number">3</span><br><span class="hljs-number">0</span> &lt;= ui &lt; vi &lt; <span class="hljs-built_in">n</span><br>图中 不存在平行边<br><span class="hljs-number">0</span> &lt;= cnti &lt;= <span class="hljs-number">104</span><br><span class="hljs-number">0</span> &lt;= maxMoves &lt;= <span class="hljs-number">109</span><br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>将 $cnt_i$ 看成类似权值，再通过 <a href="https://oi-wiki.org/graph/shortest-path/#dijkstra-%E7%AE%97%E6%B3%95">Dijkstra</a> 算法得到每个原始点到 $0$ 的最短路径即可。</p><p>需要注意的有两点：</p><ol><li>计算距离的时候要使用 $cnt + 1$ ，因为还要加上原始节点的消耗。</li><li>得到最短路径后，计算 <code>可达点</code> 总数时需要将 <code>原始节点</code> 和 <code>拆分节点</code> 分开来计算避免重复计算原始点。对于原始节点，当 $d[i]$ 小于 $maxMoves$ 时，即为可达；而对于拆分节点，通过遍历所有边得出，对于某条边 $e(u, v)$ ，该边的可达的拆分点显然为经过 $u$ 点可达的拆分点与经过 $v$ 点可达的拆分点交集，设两者数量分别为 $u_x$ 和 $v_x$ 、该边拆分点总数为 $all$，那么该边可达的拆分点总数即为 $min(all, u_x + v_x)$ ，注意这里的 $min(all, )$ 相当于去了重。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reachableNodes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> maxMoves, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// Build graph</span><br>        List&lt;<span class="hljs-type">int</span>[]&gt;[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        Arrays.setAll(g, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; edges.length; i++)&#123;<br>            g[edges[i][<span class="hljs-number">0</span>]].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;edges[i][<span class="hljs-number">1</span>], edges[i][<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>&#125;); <span class="hljs-comment">// +1, 因为还要算上原始点的距离</span><br>            g[edges[i][<span class="hljs-number">1</span>]].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>&#125;);<br>        &#125;<br>        <span class="hljs-comment">// dijkstra</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; min = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>        min.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-type">int</span>[] d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(d, Integer.MAX_VALUE);<br>        d[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        Set&lt;Integer&gt; visit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(!min.isEmpty())&#123;<br>            <span class="hljs-type">int</span>[] top = min.poll();<br>            <span class="hljs-keyword">if</span>(!visit.add(top[<span class="hljs-number">0</span>]))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] p : g[top[<span class="hljs-number">0</span>]])&#123;<br>                <span class="hljs-keyword">if</span>(d[p[<span class="hljs-number">0</span>]] &gt; d[top[<span class="hljs-number">0</span>]] + p[<span class="hljs-number">1</span>])&#123;<br>                    d[p[<span class="hljs-number">0</span>]] = d[top[<span class="hljs-number">0</span>]] + p[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 对该点的所有出边执行松弛操作</span><br>                    min.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;p[<span class="hljs-number">0</span>], d[p[<span class="hljs-number">0</span>]]&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 原始点和拆分点分开来算</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> item : d)&#123;<br>            <span class="hljs-keyword">if</span>(item &lt;= maxMoves)&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] e : edges)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, maxMoves - d[e[<span class="hljs-number">0</span>]]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, maxMoves - d[e[<span class="hljs-number">1</span>]]);<br>            ans += Math.min(e[<span class="hljs-number">2</span>], a + b);<br>        &#125;<br>        <span class="hljs-keyword">return</span>  ans;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>优先队列</tag>
      
      <tag>图</tag>
      
      <tag>最短路径</tag>
      
      <tag>Dijkstra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-795.区间子数组个数</title>
    <link href="/2022/11/24/LC-795-%E5%8C%BA%E9%97%B4%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/11/24/LC-795-%E5%8C%BA%E9%97%B4%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/">leetcode 中等题</a></p><p>给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。</p><p>示例1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[2,1,4,3]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：满足条件的三个子数组：<span class="hljs-selector-attr">[2]</span>, <span class="hljs-selector-attr">[2, 1]</span>, <span class="hljs-selector-attr">[3]</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span>&lt;= nums[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br><span class="hljs-symbol">0 </span>&lt;= left &lt;= right &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>显然符合题意的子数组必然不包含任意的 $nums[i] &gt; right$，并且必须包含一个 $left &lt;&#x3D; nums[i] &lt;&#x3D; right$。 </p><p>我们初始化左右指针都指向 $0$ ，右指针每次后移一位。<strong>并统计以右指针为子数组右端点且符合题意的子数组个数。</strong></p><p>具体遍历时，分以下三种情况进行处理</p><ul><li>如果当前元素 $left &lt;&#x3D; nums[i] &lt;&#x3D; right$，我们只需要将答案累加 $rightPoint - leftPoint + 1$ 即可。并且同时维护一个 $lastMatch$，代表最后一个遇到的符合大于 $left$ 小于 $right$ 的元素下标，将其更新为当前下标。</li><li>如果当前元素 $nums[i] &lt; left$ ，我们就需要找到左边第一个满足 $left &lt;&#x3D; nums[i] &lt;&#x3D; right$ 的下标，也就是 $lastMatch$，则显然以 $[lastMatch…rightPoint]$ 段任意元素作为左端点的子数组都不符合要求；而对于 $[leftPoint…lastMatch]$ 段，每个子数组都至少存在一个 $lastMatch$ 是符合要求的，所以我们将答案累加 $lastMatch - leftPoint + 1$ 。</li><li>如果当前元素 $nums &gt; right$ ，我们只需要将左指针移动到 $i + 1$ 并将 $lastMatch$ 置为 $-1$ 即可，因为包含该元素的任意子数组都不符合题目要求。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarrayBoundedMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lastMatch = -<span class="hljs-number">1</span>, n = nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">leftPoint</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightPoint = <span class="hljs-number">0</span>; rightPoint &lt; n; rightPoint++)&#123;<br>            <span class="hljs-keyword">if</span>(left &lt;= nums[rightPoint]  &amp;&amp; nums[rightPoint] &lt;= right)&#123;<br>                lastMatch = rightPoint;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[rightPoint] &gt; right)&#123;<br>                lastMatch = -<span class="hljs-number">1</span>;<br>                leftPoint = rightPoint + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(lastMatch != - <span class="hljs-number">1</span>)&#123;<br>                ans += lastMatch - leftPoint + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>前面双指针的做法相当于每次求解以遍历到的当前元素作为右端点的合法子数组数量，另一种方法则是求解以当前元素作为子数组最大值的合法子数组数量。</p><p>容易想到，我们利用单调栈维护出每个元素左边第一个大于当前元素的下标 $left[i]$、右边第一个大于当前元素的下标 $right[i]$。</p><p>那么该范围内以该元素作为子数组最大值的数量就等价于包含该元素的子数组数量，也就是 $(i - left[i]) \times (right[i] - i)$。</p><p>需要注意的是，由于数组中存在重复元素，我们在找第一个大于当前元素的下标时，可能存在每个重复元素都越过了彼此，由此产生重复统计。所以我们可以将某一侧的条件改为大于等于，实现类似半闭半开的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarrayBoundedMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] leftMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] rightMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Deque&lt;Integer&gt; monoStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!monoStack.isEmpty() &amp;&amp; nums[i] &gt;= nums[monoStack.peekLast()])&#123;<br>                monoStack.pollLast();<br>            &#125;<br>            leftMax[i] =monoStack.isEmpty() ? -<span class="hljs-number">1</span> : monoStack.peekLast();<br>            monoStack.offerLast(i);<br>        &#125;<br>        monoStack.clear();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(!monoStack.isEmpty() &amp;&amp; nums[i] &gt; nums[monoStack.peekLast()])&#123;<br>                monoStack.pollLast();<br>            &#125;<br>            rightMax[i] = monoStack.isEmpty() ? n : monoStack.peekLast();<br>            monoStack.offerLast(i);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; right || nums[i] &lt; left)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            ans += (i - leftMax[i]) * (rightMax[i] - i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>单调栈</tag>
      
      <tag>双指针/多指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-878.第N个神奇数字</title>
    <link href="/2022/11/22/LC-878-%E7%AC%ACN%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97/"/>
    <url>/2022/11/22/LC-878-%E7%AC%ACN%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/nth-magical-number/">leetcode 困难题</a></p><p>一个正整数如果能被 a 或 b 整除，那么它是神奇的。</p><p>给定三个整数 n , a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案 对 10^9 + 7 取模 后的值。</p><p>示例1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：n = <span class="hljs-number">1</span>, <span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：n = <span class="hljs-number">4</span>, <span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= n &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br><span class="hljs-symbol">2 </span>&lt;= a, b &lt;= <span class="hljs-number">4</span> * <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="容斥原理-二分查找"><a href="#容斥原理-二分查找" class="headerlink" title="容斥原理 + 二分查找"></a>容斥原理 + 二分查找</h2><p>这道题容易想到的做法是多指针，两个指针分别指向 $a$ 和 $b$ 的某个倍数，并通过不断比较找到第 $n$ 个数，该做法的时间复杂度为 $O(N)$，在该题的数据规模下显然会 TLE。</p><p>容易想到的优化方法是通过二分查找找到第 $n$ 个数，但是需要解决的问题是<strong>如何确定某个数 $i$ 前面的神奇数字的数量</strong>，将该数量设为 $x$。</p><p>可以发现每个神奇数字必然满足以下三种情况之一：</p><ul><li>为 $a$ 的倍数</li><li>为 $b$ 的倍数</li><li>为 $lcm(a, b)$ 的倍数</li></ul><p>显然通过容斥原理可以得出：<br>$x$ &#x3D; $i$ 前面的数为 $a$ 的倍数的数量 + $i$ 前面的数为 $b$ 的倍数的数量 - $i$ 前面的数为 $lcm(a, b)$ 的倍数的数量</p><p>也就是</p><p>$x &#x3D; \lfloor \frac{i}{a} \rfloor + \lfloor \frac{i}{b} \rfloor - \lfloor \frac{i}{lcm} \rfloor$</p><p>答案为二分查找的左边界，也就是第一个满足的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> lcm;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthMagicalNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Math.min(a, b);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Long.MAX_VALUE;<br>        <span class="hljs-built_in">this</span>.a = a;<br>        <span class="hljs-built_in">this</span>.b = b;<br>        <span class="hljs-built_in">this</span>.lcm = lcm(a, b);<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(get(mid) &lt; n)&#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (l % MOD);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> mid)</span>&#123;<br>        <span class="hljs-keyword">return</span> (mid / a) + (mid / b) - (mid / lcm);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> (a * b) / gcd(a, b);<br>    &#125; <br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>类似的，也可以转化成</p><p>$x &#x3D; \lceil \frac{i}{a} \rceil + \lceil \frac{i}{b} \rceil - \lceil \frac{i}{lcm} \rceil$</p><p>此时答案为右边界，也就是最后一个满足的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> lcm;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthMagicalNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Math.min(a, b);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Long.MAX_VALUE;<br>        <span class="hljs-built_in">this</span>.a = a;<br>        <span class="hljs-built_in">this</span>.b = b;<br>        <span class="hljs-built_in">this</span>.lcm = lcm(a, b);<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(get(mid) &gt; n)&#123;<br>                r = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ((l - <span class="hljs-number">1</span>) % MOD);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> mid)</span>&#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> mid;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>)(Math.ceil(temp / a) + Math.ceil(temp / b) - Math.ceil(temp / lcm));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> (a * b) / gcd(a, b);<br>    &#125; <br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>思维题</tag>
      
      <tag>二分查找</tag>
      
      <tag>容斥原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6244.完美分割的方案数</title>
    <link href="/2022/11/21/LC-6244-%E5%AE%8C%E7%BE%8E%E5%88%86%E5%89%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/"/>
    <url>/2022/11/21/LC-6244-%E5%AE%8C%E7%BE%8E%E5%88%86%E5%89%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/number-of-beautiful-partitions/">leetcode 困难题</a></p><p>给你一个字符串 s ，每个字符是数字 ‘1’ 到 ‘9’ ，再给你两个整数 k 和 minLength 。</p><p>如果对 s 的分割满足以下条件，那么我们认为它是一个 完美 分割：</p><ul><li>s 被分成 k 段互不相交的子字符串。</li><li>每个子字符串长度都 至少 为 minLength 。</li><li>每个子字符串的第一个字符都是一个 质数 数字，最后一个字符都是一个 非质数 数字。质数数字为 ‘2’ ，’3’ ，’5’ 和 ‘7’ ，剩下的都是非质数数字。<br>请你返回 s 的 完美 分割数目。由于答案可能很大，请返回答案对 109 + 7 取余 后的结果。</li></ul><p>一个 子字符串 是字符串中一段连续字符串序列。</p><p>示例1：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">输入：s = <span class="hljs-string">&quot;23542185131&quot;</span>, k = <span class="hljs-number">3</span>, <span class="hljs-keyword">min</span>Length = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：存在 <span class="hljs-number">3</span> 种完美分割方案：<br><span class="hljs-string">&quot;2354 | 218 | 5131&quot;</span><br><span class="hljs-string">&quot;2354 | 21851 | 31&quot;</span><br><span class="hljs-string">&quot;2354218 | 51 | 31&quot;</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> &lt;= k, minLength &lt;= s.length &lt;= <span class="hljs-number">1000</span><br><span class="hljs-attribute">s</span> 每个字符都为数字 &#x27;<span class="hljs-number">1</span>&#x27; 到 &#x27;<span class="hljs-number">9</span>&#x27; 之一。<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>定义 $f(i, j)$ 表示字符串 $S[0..(j -1)]$ 分割 $i$ 份时的满足题目要求的方案数。</p><p>所以 $j$ 如果为一个合法的分割点，需满足 $j$ 为非质数，且 $j - 0 &gt;&#x3D; minLength - 1$。</p><p>而对于 $f(i, j)$ 的求解，我们通过可以枚举上一个分割点来得出，定义其为 $j’$，需满足 $j’$ 为非质数，$j’ + 1$ 为质数，$j - j’ &gt;&#x3D; minLength$。</p><p>那么就可以得到 $f(i, j)$ 为所有符合要求的 $f(i - 1, j’)$ 的总和。</p><p>定义 $f(0,0)$ 为 $1$ ，即空串的 $0$ 个分割算作一种方案，$f(k, n)$ 为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;Character&gt; P = Set.of(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span>  (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">beautifulPartitions</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> minLength)</span> &#123;     <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; k + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> minLength - <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(isP(s.charAt(j)))&#123; <span class="hljs-comment">// j 不是合法的分割点</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 累加符合要求的 j&#x27;，也就是这里的 q</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; q &lt;= j - minLength; q++)&#123; <span class="hljs-comment">// 需要注意这里 j&#x27; 可以为-1，因为 dp 的第二维度能取到 0</span><br>                    <span class="hljs-keyword">if</span>((q == - <span class="hljs-number">1</span> || !isP(s.charAt(q))) &amp;&amp; isP(s.charAt(q + <span class="hljs-number">1</span>)))&#123;<br>                        sum = (sum + dp[i - <span class="hljs-number">1</span>][q + <span class="hljs-number">1</span>]) % MOD;<br>                    &#125;<br>                &#125;<br>                dp[i][j + <span class="hljs-number">1</span>] = sum; <span class="hljs-comment">// 这里是 j + 1。因为 dp[0][0] 为空串分割 0 段</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[k][n];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isP</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span>&#123;<br>        <span class="hljs-keyword">return</span> P.contains(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会发现上面代码的时间复杂度为 $O(N^3)$，会 TLE ，需要进行优化。</p><p>可以发现对于同一个 $i$ 的不同 $j$ ，许多 $j’$ 的枚举是重复的。</p><p>所以可以同时进行 $j$ 和 $j’$ 的枚举，并且利用类似前缀和的思路，记录对于同一个 $i$ 不同 $j’$ 的总和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;Character&gt; P = Set.of(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span>  (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">beautifulPartitions</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> minLength)</span> &#123;     <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; k + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> minLength - <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> j - minLength;<br>                <span class="hljs-keyword">if</span>((q == - <span class="hljs-number">1</span> || !isP(s.charAt(q))) &amp;&amp; isP(s.charAt(q + <span class="hljs-number">1</span>)))&#123;<br>                    sum = (sum + dp[i - <span class="hljs-number">1</span>][q + <span class="hljs-number">1</span>]) % MOD;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(isP(s.charAt(j)))&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i][j + <span class="hljs-number">1</span>] = sum;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[k][n];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isP</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span>&#123;<br>        <span class="hljs-keyword">return</span> P.contains(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># root at wecgwm in /home/yichen [1:42:51]</span><br>→ <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-808.分汤</title>
    <link href="/2022/11/21/LC-808-%E5%88%86%E6%B1%A4/"/>
    <url>/2022/11/21/LC-808-%E5%88%86%E6%B1%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/soup-servings/solution/fen-tang-by-leetcode-solution-0yxs/">leetcode 中等题</a></p><p>有 A 和 B 两种类型 的汤。一开始每种类型的汤有 n 毫升。有四种分配操作：</p><ul><li>提供 100ml 的 汤A 和 0ml 的 汤B 。</li><li>提供 75ml 的 汤A 和 25ml 的 汤B 。</li><li>提供 50ml 的 汤A 和 50ml 的 汤B 。</li><li>提供 25ml 的 汤A 和 75ml 的 汤B 。</li></ul><p>当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。</p><p>注意 不存在先分配 100 ml 汤B 的操作。</p><p>需要返回的值： 汤A 先分配完的概率 +  汤A和汤B 同时分配完的概率 &#x2F; 2。返回值在正确答案 $10^{-5}$ 的范围内将被认为是正确的。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: n = <span class="hljs-number">50</span><br>输出: <span class="hljs-number">0.62500</span><br>解释:如果我们选择前两个操作，<span class="hljs-keyword">A</span> 首先将变为空。<br>对于第三个操作，<span class="hljs-keyword">A</span> 和 B 会同时变为空。<br>对于第四个操作，B 首先将变为空。<br>所以 <span class="hljs-keyword">A</span> 变为空的总概率加上 <span class="hljs-keyword">A</span> 和 B 同时变为空的概率的一半是 <span class="hljs-number">0</span>.<span class="hljs-number">25</span> *(<span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">5</span> + <span class="hljs-number">0</span>)= <span class="hljs-number">0</span>.<span class="hljs-number">625</span>。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= n &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span>​​​​​​​<br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在该题的两个解法中，不论是自顶向下的记忆化搜索还是自底向上的动态规划，时间复杂度都是 $O(n^2)$，即使是将 $n$ 除以 $25$ （后面有解释），在该题的数据规模下仍然会 TLE。</p><p>我们可以发现，随着分配次数的增加，汤 A 比汤 B 先分配完的概率或者答案也是增大的。事实上，当 $n &gt;&#x3D; 4475$ 后，这个答案和 $1$ 的误差就已经小于题目容忍的误差了。所以当 $n &lt; 4475$ 时，我们可以通过记忆化搜索或者动态规模得出答案，否则直接返回 $1$ 即可。</p><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>首先，由于数据规模较大以及四种分配操作都是 $25$ 的倍数，因此我们可以将 $n$ 除以 $25$（向上取整），并将四种分配操作变为 $(4, 0),(3, 1),(2, 2),(1, 3)$，且每种操作的概率均为 $0.25$。</p><p>递归求解，当要分给 $A$ 和 $B$ 的汤均小于等于 $0$ 时，依题意返回 $0.5$，当仅 $A$ 小于等于 $0$ 时依题意返回 $1$，仅 $B$ 小于等于 $0$ 时返回 $0$，其他情况递归求解四种情况下的平均值即可。</p><p>同时为了避免重复递归，使用 $cache[i][j]$ 保存 $A$ 剩余 $i$，$B$ 剩余 $j$ 时的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">double</span>[][] cache;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">soupServings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        n= (<span class="hljs-type">int</span>)Math.ceil((<span class="hljs-type">double</span>)n / <span class="hljs-number">25</span>);<br>        <span class="hljs-keyword">if</span>(n &gt;= <span class="hljs-number">179</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(n, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">if</span>(a &lt;= <span class="hljs-number">0</span> &amp;&amp; b &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(b &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cache[a][b] == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> dfs(a - <span class="hljs-number">4</span>, b);<br>            <span class="hljs-type">double</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> dfs(a - <span class="hljs-number">3</span>, b - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">double</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> dfs(a - <span class="hljs-number">2</span>, b - <span class="hljs-number">2</span>);<br>            <span class="hljs-type">double</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dfs(a - <span class="hljs-number">1</span>, b - <span class="hljs-number">3</span>);<br>            cache[a][b] = <span class="hljs-number">0.25</span> * (q + w + e + r);<br>        &#125;<br>        <span class="hljs-keyword">return</span> cache[a][b];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>类似记忆化搜索的思路，可以转成动态规划求解。</p><p>定义 $dp(i, j)$ 表示 $A$ 剩余 $i$ 、 $B$ 剩余 $j$ 时的解，边界情况如同上面所解释的，非边界情况下转移方程为：</p><p>$$<br>\begin{align}<br>&amp;dp(i, j) &#x3D; \frac{1}{4} \times (dp(i - 4, j) + dp(i - 3, j - 1) + dp(i - 2, j - 2) + dp(i - 1, j - 3))\\<br>\end{align}<br>$$</p><p>需要注意的是在这道题中与记忆化搜索相比动态规划会多出一些无效状态的计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">soupServings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        n = (n + <span class="hljs-number">25</span> - <span class="hljs-number">1</span>) / <span class="hljs-number">25</span>; <span class="hljs-comment">// 向上取整</span><br>        <span class="hljs-keyword">if</span>(n &gt;= <span class="hljs-number">179</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">double</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0.5</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n + <span class="hljs-number">1</span>; j++)&#123;<br>                dp[i][j] += dp[Math.max(<span class="hljs-number">0</span>, i - <span class="hljs-number">4</span>)][j] / <span class="hljs-number">4</span>;<br>                dp[i][j] += dp[Math.max(<span class="hljs-number">0</span>, i - <span class="hljs-number">3</span>)][j - <span class="hljs-number">1</span>] / <span class="hljs-number">4</span>;<br>                dp[i][j] += dp[Math.max(<span class="hljs-number">0</span>, i - <span class="hljs-number">2</span>)][Math.max(<span class="hljs-number">0</span>, j - <span class="hljs-number">2</span>)] / <span class="hljs-number">4</span>;<br>                dp[i][j] += dp[i - <span class="hljs-number">1</span>][Math.max(<span class="hljs-number">0</span>, j - <span class="hljs-number">3</span>)] / <span class="hljs-number">4</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6243.到达首都的最少油耗</title>
    <link href="/2022/11/20/LC-6243-%E5%88%B0%E8%BE%BE%E9%A6%96%E9%83%BD%E7%9A%84%E6%9C%80%E5%B0%91%E6%B2%B9%E8%80%97/"/>
    <url>/2022/11/20/LC-6243-%E5%88%B0%E8%BE%BE%E9%A6%96%E9%83%BD%E7%9A%84%E6%9C%80%E5%B0%91%E6%B2%B9%E8%80%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/">leetcode 中等题</a></p><p>给你一棵 n 个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从 0 到 n - 1 ，且恰好有 n - 1 条路。0 是首都。给你一个二维整数数组 roads ，其中 roads[i] &#x3D; [ai, bi] ，表示城市 ai 和 bi 之间有一条 双向路 。</p><p>每个城市里有一个代表，他们都要去首都参加一个会议。</p><p>每座城市里有一辆车。给你一个整数 seats 表示每辆车里面座位的数目。</p><p>城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。</p><p>请你返回到达首都最少需要多少升汽油。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：roads = [[0,1],[0,2],[0,3]], seats = 5<br>输出：3<br>解释：<br>- 代表<span class="hljs-number"> 1 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 2 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 3 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>最少消耗<span class="hljs-number"> 3 </span>升汽油。<br></code></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2<br>输出：7<br>解释：<br>- 代表<span class="hljs-number"> 2 </span>到达城市<span class="hljs-number"> 3 </span>，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 2 </span>和代表<span class="hljs-number"> 3 </span>一起到达城市<span class="hljs-number"> 1 </span>，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 2 </span>和代表<span class="hljs-number"> 3 </span>一起到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 1 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 5 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 6 </span>到达城市<span class="hljs-number"> 4 </span>，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 4 </span>和代表<span class="hljs-number"> 6 </span>一起到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>最少消耗<span class="hljs-number"> 7 </span>升汽油。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：roads </span>=<span class="hljs-string"> [], seats = 1</span><br><span class="hljs-string">输出：0</span><br><span class="hljs-string">解释：没有代表需要从别的城市到达首都。</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> &lt;= n &lt;= <span class="hljs-number">105</span><br><span class="hljs-attribute">roads</span>.length == n - <span class="hljs-number">1</span><br><span class="hljs-attribute">roads</span>[i].length == <span class="hljs-number">2</span><br><span class="hljs-attribute">0</span> &lt;= ai, bi &lt; n<br><span class="hljs-attribute">ai</span> != bi<br><span class="hljs-attribute">roads</span> 表示一棵合法的树。<br><span class="hljs-attribute">1</span> &lt;= seats &lt;= <span class="hljs-number">105</span><br></code></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>车辆可以视为无限的，要使消耗的油最少，可以递归的判断对于每个子节点，汇集到该节点的人一共有多少，那么也就是该节点的子节点数量 $count$，<strong>并且每次都可以取汇集到该节点的所有人到下一个节点最少需要花费的油量</strong> $ceil(\frac{count}{seats})$ 视为该节点的贡献，最后累加所有节点的贡献就为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt;[] g;<br>    <span class="hljs-type">int</span> seats;<br>    <span class="hljs-type">long</span> ans;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumFuelCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] roads, <span class="hljs-type">int</span> seats)</span> &#123;<br>        <span class="hljs-keyword">if</span>(roads.length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.seats = seats;<br>        g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[roads.length + <span class="hljs-number">1</span>];<br>        IntStream.range(<span class="hljs-number">0</span>, roads.length + <span class="hljs-number">1</span>).forEach(i -&gt; g[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] road : roads)&#123;<br>            g[road[<span class="hljs-number">0</span>]].add(road[<span class="hljs-number">1</span>]);<br>            g[road[<span class="hljs-number">1</span>]].add(road[<span class="hljs-number">0</span>]);<br>        &#125;<br>        dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> father)</span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> item : g[p])&#123;<br>            <span class="hljs-keyword">if</span>(item == father)&#123; <span class="hljs-comment">// 题目给的双向边，避免死循环重复遍历</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            size += dfs(item, p);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 0节点不需要计算，所有人都到达了</span><br>            ans += Math.ceil((<span class="hljs-type">double</span>)size / seats); <span class="hljs-comment">// 向上取整等价于 （size + seats - 1) / seats</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-799.香槟塔</title>
    <link href="/2022/11/20/LC-799-%E9%A6%99%E6%A7%9F%E5%A1%94/"/>
    <url>/2022/11/20/LC-799-%E9%A6%99%E6%A7%9F%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/champagne-tower/">leetcode 中等题</a></p><p>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。</p><p><img src="/../img/Snipaste_2022-11-20_20-06-33.png" alt="leetcode"></p><p>现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（ i 和 j 都从0开始）。</p><p>示例1：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">示例 1</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0.00000</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span> <span class="hljs-string">我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入: <span class="hljs-built_in">poured</span>(倾倒香槟总杯数) = <span class="hljs-number">2</span>, <span class="hljs-built_in">query_glass</span>(杯子的位置数) = <span class="hljs-number">1</span>, <span class="hljs-built_in">query_row</span>(行数) = <span class="hljs-number">1</span><br>输出: <span class="hljs-number">0.50000</span><br>解释: 我们在顶层（下标是（<span class="hljs-number">0</span>，<span class="hljs-number">0</span>）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（<span class="hljs-number">1</span>，<span class="hljs-number">0</span>）的玻璃杯和（<span class="hljs-number">1</span>，<span class="hljs-number">1</span>）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。<br></code></pre></td></tr></table></figure><p>示例3:</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: poured = <span class="hljs-number">100000009</span>, query_row = <span class="hljs-number">33</span>, query_glass = <span class="hljs-number">17</span><br>输出: <span class="hljs-number">1.00000</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= poured &lt;= <span class="hljs-number">109</span><br><span class="hljs-symbol">0 </span>&lt;= query_glass &lt;= query_row &lt; <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>首先需要知道除了最上层的杯子，其余所有杯子 $[i, j]$ 的香槟均来自上一层的杯子 $[i - 1, j]$ 和 $[i - 1, j + 1]$，并且当该杯子满后（超过$1$），流出的水会等量的流向下一层 $[i + 1, j]$ 和 $[i + 1, j + 1]$。</p><p>dp，定义 $f(i, j)$ 表示流过该层的香槟总量，那么 $f(0, 0)$ 为 $poured$，可以得到</p><p>$$<br>\begin{align}<br>&amp;f(i + 1, j) +&#x3D; \frac{f(i, j) - 1}{2}\\<br>&amp;f(i + 1, j + 1) +&#x3D; \frac{f(i, j) - 1}{2}\\<br>\end{align}<br>$$</p><p>$min(1, f(queryRow, queryGlass))$ 为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">champagneTower</span><span class="hljs-params">(<span class="hljs-type">int</span> poured, <span class="hljs-type">int</span> query_row, <span class="hljs-type">int</span> query_glass)</span> &#123;<br>        <span class="hljs-type">double</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[query_row + <span class="hljs-number">1</span>][query_row + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = poured;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; query_row; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(dp[i][j] &lt;= <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i + <span class="hljs-number">1</span>][j] += (dp[i][j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] += (dp[i][j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(dp[query_row][query_glass], <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，每层的香槟流量，只依赖于上一层，所以可以用滚动数组的方式进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">champagneTower</span><span class="hljs-params">(<span class="hljs-type">int</span> poured, <span class="hljs-type">int</span> query_row, <span class="hljs-type">int</span> query_glass)</span> &#123;<br>        <span class="hljs-type">double</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[query_row + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = poured;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; query_row; i++)&#123;<br>            <span class="hljs-type">double</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[query_row + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(dp[j] &lt;= <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                temp[j] += (dp[j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                temp[j + <span class="hljs-number">1</span>] += (dp[j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            &#125;<br>            dp = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(dp[query_glass], <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6242.二叉搜索树最近节点查询</title>
    <link href="/2022/11/20/LC-6242-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E8%8A%82%E7%82%B9%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/11/20/LC-6242-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E8%8A%82%E7%82%B9%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/">leetcode 中等题</a></p><p>给你一个 二叉搜索树 的根节点 root ，和一个由正整数组成、长度为 n 的数组 queries 。</p><p>请你找出一个长度为 n 的 二维 答案数组 answer ，其中 answer[i] &#x3D; [mini, maxi] ：</p><p>mini 是树中小于等于 queries[i] 的 最大值 。如果不存在这样的值，则使用 -1 代替。<br>maxi 是树中大于等于 queries[i] 的 最小值 。如果不存在这样的值，则使用 -1 代替。<br>返回数组 answer 。</p><p>示例1：</p><p><img src="/../img/Snipaste_2022-11-20_23-04-47.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]<br>输出：[[2,2],[4,6],[15,-1]]<br>解释：按下面的描述找出并返回查询的答案：<br>- 树中小于等于<span class="hljs-number"> 2 </span>的最大值是<span class="hljs-number"> 2 </span>，且大于等于<span class="hljs-number"> 2 </span>的最小值也是<span class="hljs-number"> 2 </span>。所以第一个查询的答案是 [2,2] 。<br>- 树中小于等于<span class="hljs-number"> 5 </span>的最大值是<span class="hljs-number"> 4 </span>，且大于等于<span class="hljs-number"> 5 </span>的最小值是<span class="hljs-number"> 6 </span>。所以第二个查询的答案是 [4,6] 。<br>- 树中小于等于<span class="hljs-number"> 16 </span>的最大值是<span class="hljs-number"> 15 </span>，且大于等于<span class="hljs-number"> 16 </span>的最小值不存在。所以第三个查询的答案是 [15,-1] 。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">树中节点的数目在范围 <span class="hljs-selector-attr">[2, 105]</span> 内<br><span class="hljs-number">1</span> &lt;= Node<span class="hljs-selector-class">.val</span> &lt;= <span class="hljs-number">106</span><br>n == queries<span class="hljs-selector-class">.length</span><br><span class="hljs-number">1</span> &lt;= n &lt;= <span class="hljs-number">105</span><br><span class="hljs-number">1</span> &lt;= queries<span class="hljs-selector-attr">[i]</span> &lt;= <span class="hljs-number">106</span><br></code></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>需要注意的是题目给的是二叉查找树而不是平衡树，如果直接在树上查找的话，某些数据下树可能会退化成链表导致 TLE。</p><p>中序遍历树得到排序后的数组，再二分查找出 $min_x$ 以及 $max_x$ 即可。</p><p>可以通过两次左闭右开的二分查找分别通过缩小右边界、左边界获得 $min_x$ 和 $max_x$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">closestNodes</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; queries)</span> &#123;<br>        List&lt;Integer&gt; sort = dfs(root, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sort.size();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.size(); i++)&#123;<br>            List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n, target = queries.get(i);<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(sort.get(mid) &lt; target)&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sort.get(mid) &gt;= target)&#123;<br>                    right = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left &lt; n &amp;&amp; sort.get(left) == target)&#123;<br>                cur.add(sort.get(left));<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)&#123;<br>                cur.add(sort.get(left - <span class="hljs-number">1</span>));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.add(-<span class="hljs-number">1</span>);<br>            &#125;<br>            left = <span class="hljs-number">0</span>;<br>            right = n;<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(sort.get(mid) &lt;= target)&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sort.get(mid) &gt; target)&#123;<br>                    right = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; sort.get(left - <span class="hljs-number">1</span>) == target)&#123;<br>                cur.add(sort.get(left - <span class="hljs-number">1</span>));<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left &lt; n)&#123;<br>                cur.add(sort.get(left));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.add(-<span class="hljs-number">1</span>);<br>            &#125;<br>            ans.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; sort)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> sort;<br>        &#125;<br>        dfs(root.left, sort);<br>        sort.add(root.val);<br>        dfs(root.right, sort);<br>        <span class="hljs-keyword">return</span> sort;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然也可以通过缩小右边界一次性得到 $min_x$ 和 $max_x$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">closestNodes</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; queries)</span> &#123;<br>        List&lt;Integer&gt; sort = dfs(root, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sort.size();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.size(); i++)&#123;<br>            List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n, target = queries.get(i);<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(sort.get(mid) &lt; target)&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    right = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left &lt; n &amp;&amp; sort.get(left) == target)&#123;<br>                cur.add(sort.get(left));<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)&#123;<br>                cur.add(sort.get(left - <span class="hljs-number">1</span>));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.add(-<span class="hljs-number">1</span>);<br>            &#125;                       <br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (left &lt; n ? sort.get(left) : -<span class="hljs-number">1</span>);      <br>            cur.add(b);<br>            ans.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; sort)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> sort;<br>        &#125;<br>        dfs(root.left, sort);<br>        sort.add(root.val);<br>        dfs(root.right, sort);<br>        <span class="hljs-keyword">return</span> sort;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缩小左边界一次性得到 $min_x$ 和 $max_x$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 二分查找通过缩小左边界一次性得到 min_x 和 min_y</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">closestNodes</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; queries)</span> &#123;<br>        List&lt;Integer&gt; sort = dfs(root, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sort.size();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.size(); i++)&#123;<br>            List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n, target = queries.get(i);<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(sort.get(mid) &gt; target)&#123;<br>                    right = mid;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> ? sort.get(left - <span class="hljs-number">1</span>) : -<span class="hljs-number">1</span>);<br>            cur.add(a);<br>            <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; sort.get(left - <span class="hljs-number">1</span>) == target)&#123;<br>                cur.add(sort.get(left - <span class="hljs-number">1</span>));<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left &lt; n)&#123;<br>                cur.add(sort.get(left));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.add(-<span class="hljs-number">1</span>);<br>            &#125;<br>            ans.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; sort)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> sort;<br>        &#125;<br>        dfs(root.left, sort);<br>        sort.add(root.val);<br>        dfs(root.right, sort);<br>        <span class="hljs-keyword">return</span> sort;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-792.匹配子序列的单词数</title>
    <link href="/2022/11/18/LC-792-%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
    <url>/2022/11/18/LC-792-%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/number-of-matching-subsequences/">leetcode 中等题</a></p><p>给定字符串 s 和字符串数组 words, 返回  words[i] 中是s的子序列的单词个数 。</p><p>字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。</p><ul><li>例如， “ace” 是 “abcde” 的子序列。</li></ul><p>示例1：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入: s = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>,<span class="hljs-string">&quot;acd&quot;</span>,<span class="hljs-string">&quot;ace&quot;</span>]<br>输出: <span class="hljs-number">3</span><br>解释: 有三个是 s 的子序列的单词: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;acd&quot;</span>, <span class="hljs-string">&quot;ace&quot;</span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入: s = <span class="hljs-string">&quot;dsahjpjauf&quot;</span>, <span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;ahjpjau&quot;</span>,<span class="hljs-string">&quot;ja&quot;</span>,<span class="hljs-string">&quot;ahbwzgqnuk&quot;</span>,<span class="hljs-string">&quot;tnmlanowax&quot;</span>]<br>输出: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1</span> &lt;= s.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">5</span> * <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">words</span>.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">5000</span><br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">words</span>[i].<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">50</span><br><span class="hljs-built_in">words</span>[i]和 s 都只由小写字母组成。<br></code></pre></td></tr></table></figure><h2 id="分桶-二分查找-（贪心）"><a href="#分桶-二分查找-（贪心）" class="headerlink" title="分桶 + 二分查找 （贪心）"></a>分桶 + 二分查找 （贪心）</h2><p>最容易想到的方法就是对于每个 $word$ ，通过双指针的方法和 $s$ 进行匹配，指针 $i$ 和 $j$ 初始时分别指向 $word$ 和 $a$ 的第 $0$ 位字符，如果匹配成功则将两个指针分别向后移动，否则只移动 $j$，如果 $i$ 能匹配结束的话则 $ans$ 加一。</p><p>但是该方法在该题的数据规模下会 TLE，所以需要进行优化。</p><p>一种方法是我们可以将 $s$ 按照每个字符进行分桶，每个桶内存储该字符在 $s$ 内从小到大排列后的索引值。那么对于每个 $word$ 我们都会进行一轮遍历，每一轮都独立维护一个 $next$ 值，并在每次 $i$ 指针后移时，尝试通过二分查找得到当前 $i$ 所指向字符的对应桶内第一个大于 $next$ 的索引值（贪心思路，目的是让每次的 $next$ 都尽量小），然后将 $next$ 更新为该索引值，过程中若不存在大于 $next$ 的索引值则匹配失败，若能匹配结束则 $ans$ 加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numMatchingSubseq</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br>        Map&lt;Character, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            List&lt;Integer&gt; list = map.computeIfAbsent(c, ArrayList::<span class="hljs-keyword">new</span>);<br>            list.add(i);<br>            map.put(c, list);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++)&#123;<br>            <span class="hljs-type">char</span>[] item = words[i].toCharArray();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; item.length; j++)&#123;<br>                List&lt;Integer&gt; list = map.getOrDefault(item[j], <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                <span class="hljs-comment">// 二分查找第一个大于 target 的数</span><br>                <span class="hljs-comment">// 也就是右边界 + 1, 右边界为 left - 1, 右边界 &lt;= target</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = list.size();<br>                <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + right &gt;&gt; <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(list.get(mid) &lt;= next)&#123;<br>                        left = mid + <span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list.get(mid) &gt; next)&#123;<br>                        right = mid;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(left &lt; list.size())&#123;<br>                    next = list.get(left);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似上面的思路，我们也可以对于每个 $word$ 进行逆序遍历，只需要在二分查找时改成找到第一个小于 $i$ 的索引值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numMatchingSubseq</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br>        Map&lt;Character, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            List&lt;Integer&gt; list = map.computeIfAbsent(c, ArrayList::<span class="hljs-keyword">new</span>);<br>            list.add(i);<br>            map.put(c, list);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++)&#123;<br>            <span class="hljs-type">char</span>[] item = words[i].toCharArray();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> item.length - <span class="hljs-number">1</span>; j &gt;=<span class="hljs-number">0</span>; j--)&#123;<br>                List&lt;Integer&gt; list = map.getOrDefault(item[j], <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                <span class="hljs-comment">// 二分查找第一个小于 target 的数</span><br>                <span class="hljs-comment">// 也就是左边界 - 1, 左边界为 left, 左边界 &gt;= target</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = list.size();<br>                <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + right &gt;&gt; <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(list.get(mid) &lt; next)&#123;<br>                        left = mid + <span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list.get(mid) &gt;= next)&#123;<br>                        right = mid;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; left - <span class="hljs-number">1</span> &lt; list.size())&#123;<br>                    next = list.get(left - <span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分桶-多指针"><a href="#分桶-多指针" class="headerlink" title="分桶 + 多指针"></a>分桶 + 多指针</h2><p>上面的做法的思路是对 $s$ 按字符进行分桶，从而加速每一个 $word$ 与 $s$ 之间的匹配速度，相当于每个 $word$ 都会独立匹配一次。</p><p>而另一种做法的思路是将 $s$ 同时与所有 $word$ 进行匹配。具体来说每一个 $word$ 都有着独立的指针 $i$ ，并且初始值为 0，那么对每一个 $word$ 按照当前匹配到的字符，也就是各自 $i$ 指针指向的字符进行分桶。那么我们就可以直接遍历 $s$，每次只需要将 $j$ 所指向字符的对应桶内的所有 $word$ 拿出来并将它们的 $i$ 指针往后移动一位，然后重新维护桶即可，而若当前取出的 $word$ 对应的 $i$ 已经到达结尾，则 $ans$ 加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numMatchingSubseq</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt;[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>            bucket[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; ++i) &#123;<br>            bucket[words[i].charAt(<span class="hljs-number">0</span>) - <span class="hljs-string">&#x27;a&#x27;</span>].offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, <span class="hljs-number">0</span>&#125;);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> bucket[c - <span class="hljs-string">&#x27;a&#x27;</span>].size();<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span>[] item = bucket[c - <span class="hljs-string">&#x27;a&#x27;</span>].poll();<br>                <span class="hljs-keyword">if</span> (item[<span class="hljs-number">1</span>] == words[item[<span class="hljs-number">0</span>]].length() - <span class="hljs-number">1</span>) &#123;<br>                    ++ans;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ++item[<span class="hljs-number">1</span>];<br>                    bucket[words[item[<span class="hljs-number">0</span>]].charAt(item[<span class="hljs-number">1</span>]) - <span class="hljs-string">&#x27;a&#x27;</span>].offer(item);<br>                &#125;<br>                --size;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-891.子序列宽度之和</title>
    <link href="/2022/11/18/LC-891-%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/11/18/LC-891-%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/sum-of-subsequence-widths/">leetcode 困难题</a></p><p>一个序列的 宽度 定义为该序列中<strong>最大元素和最小元素的差值</strong>。</p><p>给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 1e9 + 7 取余 后的结果。</p><p>子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,1,3]</span><br>输出：6<br>解释：子序列为 <span class="hljs-comment">[1]</span>, <span class="hljs-comment">[2]</span>, <span class="hljs-comment">[3]</span>, <span class="hljs-comment">[2,1]</span>, <span class="hljs-comment">[2,3]</span>, <span class="hljs-comment">[1,3]</span>, <span class="hljs-comment">[2,1,3]</span> 。<br>相应的宽度是 0, 0, 0, 1, 1, 2, 2 。<br>宽度之和是 6 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">105</span><br><span class="hljs-symbol">1 </span>&lt;= nums[i] &lt;= <span class="hljs-number">105</span><br></code></pre></td></tr></table></figure><h2 id="考虑每个元素的贡献"><a href="#考虑每个元素的贡献" class="headerlink" title="考虑每个元素的贡献"></a>考虑每个元素的贡献</h2><p>考虑到数据范围，肯定是无法通过求具体的子序列来得到答案的。</p><p>我们可以考虑每个元素对答案的贡献来得到最终的答案。并且由于宽度为序列中最大元素和最小元素的差值，那么也就是说每个元素只有在作为某个序列的最小值或者最大值时，才会在该序列中对答案有贡献。容易想到先对数组进行排序，那么排序后就能可以得到以某个 $nums[i]$ 为最大值的序列一共有 $2^i$ 个，因为左边的每个元素都可以选或者不选，即一共会有 $2 \times 2 \times 2 … \times 2$ 个；同理右边就有 $2 ^{j-i-1}$ 个以 $num[i]$ 作为最小值的序列。</p><p>需要注意的是，根据题意，长度为 1 的序列是没有贡献的，所以 $nums[i]$ 的左边不能全部不选，右边也不能全部不选，也就是说，以 $nums[i]$ 作为最大值或最小值的序列数量均需要分别减一。</p><p>那么就可以得到，每个元素对答案的贡献为 $nums[i] \times (2^i - 1 - (2^{j-i-1} - 1) )$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumSubseqWidths</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span>[] pow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        pow[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            pow[i] = pow[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> % MOD;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            ans = (ans + (nums[i] * (pow[i] - <span class="hljs-number">1</span> - pow[n - i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)))% MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(ans % MOD);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>思维题</tag>
      
      <tag>贡献法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-775.全局倒置与局部倒置</title>
    <link href="/2022/11/16/LC-775-%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/"/>
    <url>/2022/11/16/LC-775-%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/global-and-local-inversions/">leetcode 中等题</a></p><p>给你一个长度为 n 的整数数组 nums ，表示由范围 [0, n - 1] 内所有整数组成的一个排列。</p><p>全局倒置 的数目等于满足下述条件不同下标对 (i, j) 的数目：</p><ul><li>0 &lt;&#x3D; i &lt; j &lt; n</li><li>nums[i] &gt; nums[j]</li></ul><p>局部倒置 的数目等于满足下述条件的下标 i 的数目：</p><ul><li>0 &lt;&#x3D; i &lt; n - 1</li><li>nums[i] &gt; nums[i + 1]</li></ul><p>当数组 nums 中 全局倒置 的数量等于 局部倒置 的数量时，返回 true ；否则，返回 false 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,0,2]<br>输出：true<br>解释：有<span class="hljs-number"> 1 </span>个全局倒置，和<span class="hljs-number"> 1 </span>个局部倒置。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,0]<br>输出：false<br>解释：有<span class="hljs-number"> 2 </span>个全局倒置，和<span class="hljs-number"> 1 </span>个局部倒置。<br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">n</span> == nums.length<br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-number">0</span> &lt;= nums[i] &lt; <span class="hljs-built_in">n</span><br>nums 中的所有整数 互不相同<br>nums 是范围 [<span class="hljs-number">0</span>, <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>] 内所有数字组成的一个排列<br></code></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>这道题最容易且方便的做法是，逆序遍历且维护一个 $[i + 2, n]$ 的最小值，如果当前元素大于该最小值返回 $false$ ，如果顺利遍历结束返回 $true$ 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIdealPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> nums[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">3</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; min)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;         <br>            <span class="hljs-comment">// 判断后再更新 min，相当于维护的是 [i + 2, n] 的最小值 </span><br>            min = Math.min(min, nums[i + <span class="hljs-number">1</span>]); <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>对于求 <a href="https://zh.m.wikipedia.org/zh-hans/%E9%80%86%E5%BA%8F%E5%AF%B9">逆序对</a> 更通用的做法是使用 <a href="https://www.acwing.com/blog/content/80/">树状数组</a>。</p><p>由于树状数组的索引位置 $0$ 一般不会存储元素，因为 $lowbit(0) &#x3D; 0$，会导致 $query$ 和 $update$ 的循环条件都要进行特判，然而题目数据范围为 $0 &lt;&#x3D; nums[i] &lt; n$，会取到 $0$。</p><p>一种方法是构造一个原数组元素与排名的映射（排名从 $1$ 开始），使得原数组离散化，这样既不会取到 $0$ 的索引，也能压缩数字区间（虽然本题数据为排列，所以起到没有压缩作用）。</p><p>构建完映射之后只需要通过树状数组得到逆序对的总数量，再与“局部倒置”的数量比较即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIdealPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 元素map排名</span><br>        <span class="hljs-type">int</span>[] sort = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        System.arraycopy(nums, <span class="hljs-number">0</span>, sort, <span class="hljs-number">0</span>, n);<br>        Arrays.sort(sort);<br>        Map&lt;Integer, Integer&gt; rank = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            rank.put(sort[i - <span class="hljs-number">1</span>], i);<br>        &#125;<br>        <span class="hljs-type">FenwickTree</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FenwickTree</span>(rank.keySet().size() + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">local</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, global = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rank.get(nums[i]);<br>            t.update(r, <span class="hljs-number">1</span>);<br>            global += t.query(rank.keySet().size()) - t.query(r);<br>            <span class="hljs-keyword">if</span>(i != n - <span class="hljs-number">1</span> &amp;&amp; nums[i] &gt; nums[i + <span class="hljs-number">1</span>])&#123;<br>                local += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> local == global;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FenwickTree</span>&#123;<br>        <span class="hljs-type">int</span>[] c;<br><br>        FenwickTree(<span class="hljs-type">int</span> size)&#123;<br>            c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size];<br>        &#125;<br><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> updateValue)</span>&#123;<br>            <span class="hljs-keyword">while</span>(index &lt; c.length)&#123;<br>                c[index] += updateValue;<br>                index += lowbit(index);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(index &gt; <span class="hljs-number">0</span>)&#123;<br>                ans += c[index];<br>                index -= lowbit(index); <br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>            <span class="hljs-keyword">return</span> x &amp; -x;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>另一种避免取到 $0$ 的方法是每次加入树状数组时把元素手动加上 $1$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIdealPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">FenwickTree</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FenwickTree</span>(nums.length + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">local</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, global = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> nums[i] + <span class="hljs-number">1</span>;<br>            global += t.query(n) - t.query(item);<br>            t.update(item, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(i != n - <span class="hljs-number">1</span> &amp;&amp; nums[i] &gt; nums[i + <span class="hljs-number">1</span>])&#123;<br>                local += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> local == global;<br>    &#125;<br>    <span class="hljs-comment">// FenwickTree 代码同上</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-805.数组的均值分割</title>
    <link href="/2022/11/14/LC-805-%E6%95%B0%E7%BB%84%E7%9A%84%E5%9D%87%E5%80%BC%E5%88%86%E5%89%B2/"/>
    <url>/2022/11/14/LC-805-%E6%95%B0%E7%BB%84%E7%9A%84%E5%9D%87%E5%80%BC%E5%88%86%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/split-array-with-same-average/">leetcode 困难题</a></p><p>给定你一个整数数组 nums</p><p>我们要将 nums 数组中的每个元素移动到 A 数组 或者 B 数组中，使得 A 数组和 B 数组不为空，并且 average(A) &#x3D;&#x3D; average(B) 。</p><p>如果可以完成则返回true ， 否则返回 false  。</p><p>注意：对于数组 arr ,  average(arr) 是 arr 的所有元素除以 arr 长度的和。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: nums = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>]<br>输出: true<br>解释: 我们可以将数组分割为 [<span class="hljs-number">1,4,5,8</span>] 和 [<span class="hljs-number">2,3,6,7</span>], 他们的平均值都是<span class="hljs-number">4</span>.<span class="hljs-number">5</span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [3,1]</span><br><span class="hljs-section">输出: false</span><br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">30</span><br><span class="hljs-symbol">0 </span>&lt;= nums[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设我们移动了 $k$ 个元素到数组 $A$ 中，移动了 $k_2$ 或者说 $n-k$ 个元素到数组 $B$ 中，分割后的数组为 $A$ 和 $B$，且${sum}(A)$， ${sum}(B)$， ${sum}(nums)$ 分别表示数组 $A$， $B$， $nums$ 的元素和，由于数组 $A$，$B$ 的平均值相等，可以推出：</p><p>$$<br>\begin{align}<br>&amp;\frac{sum(A)}{k} &#x3D; \frac{sum(B)}{n-k}\\<br>\Leftrightarrow &amp; sum(A) \times n - sum(A) \times k &#x3D; sum(B) \times k\\<br>\Leftrightarrow &amp; sum(A) \times n &#x3D; (sum(B) + sum(A)) \times k\\<br>\Leftrightarrow &amp; sum(A) \times n &#x3D; (sum(nums)) \times k\\<br>\Leftrightarrow &amp; \frac{sum(A)}{k} &#x3D; \frac{sum(nums)}{n}\\<br>\end{align}<br>$$</p><p>也就是说如果存在子数组 $A$，$B$ 的平均值相等，则该平均值必然还会等于 $nums$ 的平均值。</p><p><strong>并且我们只需要求出是否存在一个子数组的平均值等于原数组平均值即可</strong>，因为如果存在一个子数组平均值等于原数组平均值的话：<br>$$<br>\begin{align}<br>&amp;\frac{sum(nums)}{n} &#x3D; \frac{sum(A)}{k}\\<br>\Leftrightarrow &amp; \frac{sum(A) + sum(B)}{k + k_2} &#x3D; \frac{sum(A)}{k}\\<br>\Leftrightarrow &amp; \frac{sum(A) + sum(B)}{k_2} &#x3D; \frac{sum(A) \times (k + k_2)}{k \times k_2}\\<br>\Leftrightarrow &amp; \frac{sum(B)}{k_2} &#x3D; \frac{sum(A) \times (k + k_2) - (sum(A) \times k)}{k \times k_2}\\<br>\Leftrightarrow &amp; \frac{sum(B)}{k_2} &#x3D; \frac{sum(A) \times k_2 }{k \times k_2}\\<br>\Leftrightarrow &amp; \frac{sum(B)}{k_2} &#x3D; \frac{sum(A)}{k}\\<br>\end{align}<br>$$<br>可以得出剩余元素组成的子数组的平均值也为原数组平均值。</p><p>那么问题变成求是否存在子数组平均值等于原数组，容易想到的思路是枚举每个子数组，此时一共有 $2^n$ 种方案（每个元素取或不取），由于题目中 <code>n</code> 最大是 <code>30</code>，会 TLE。</p><p>我们可以使用折半查找的方法，将时间复杂度降低到 $O(2^\frac{n}{2})$。</p><p>我们将数组 $nums$ 分成左右两部分，那么子数组 $A$ 可能存在三种情况：</p><ul><li>子数组 $A$ 完全在数组 $nums$ 的左半部分；</li><li>子数组 $A$ 完全在数组 $nums$ 的右半部分；</li><li>子数组 $A$ 一部分在数组 $nums$ 的左半部分，一部分在数组 $nums$ 的右半部分。</li></ul><p>我们分两次来处理数组，每次处理一部分。<br>如果是前两种情况比较好处理，我们只需要在处理对应部分数组时计算平均值，再与原数组的平均值比较即可。</p><p>但如果是第三种情况，则要等我们在处理右半部分时，回过头来通过某种方式搜索左边是否存在符合我们预期的方案（无法简单的通过在哈希表中保存总和来求，因为还和左边数组取了几个有关系），即会花费额外的时间（可能TLE）又难实现。</p><p>所以我们可以将数组 ${nums}$ 中的每个元素减去 $nums$ 的平均值，这样数组的平均值则变为 <code>0</code>。那么此时题目中的问题则变为：能否从 $nums$ 中找出若干个元素组成集合 $A$，使得 $A$ 的元素之和为 <code>0</code>。</p><p>但是如果直接减去 $\frac{sum(nums)}{n}$ 会引进浮点数，如果在 <code>Java</code> 中直接使用 <code>double</code> 进行运算，会因为浮点数的误差出现WA，所以更好的方案是先将 $nums$ 中的每个元素乘以 $n$ 后再减去数组总和，也就是：<br>$$<br>\begin{align}<br>&amp;nums[i] &#x3D; nums[i] - \frac{sum(nums)}{n}\\<br>\Rightarrow &amp;nums[i] &#x3D; nums[i] \times n - \frac{sum(nums) \times n}{n}\\<br>\end{align}<br>$$<br>这样就不会出现浮点数了。</p><p>这样处理后，如果是第一、二种情况，我们只需要在遍历时判断当前方案总和是否等于 $0$ 即可，如果是就直接返回。对于第三种情况，我们也只需要在遍历左边部分时额外再把当前方案的总和保存到哈希表中，然后在遍历右边部分数组的时候，如果当前总和是 $curSum$ ，判断哈希表是否存在 $-curSum$ 即可。</p><p>另外需要注意的是，我们不能同时选择左右两边的所有元素，这样数组 $B$ 就为空了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">splitArraySameAverage</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, m = nums.length / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            nums[i] = nums[i] * n - sum; <span class="hljs-comment">// 避免浮点数</span><br>        &#125;<br>        Set&lt;Integer&gt; exist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; m); i++)&#123; <span class="hljs-comment">// 2 ^（n/2）个方案</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                <span class="hljs-keyword">if</span>((i &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 当前位为 1 代表当前位被选到了，例如 011 代表该轮只选择第一个和第二个元素</span><br>                    curSum += nums[j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(curSum == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            exist.add(curSum);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m; i &lt; n; i++) &#123;<br>            rSum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; (n - m)); i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>((i &amp; (<span class="hljs-number">1</span> &lt;&lt; (j - m))) != <span class="hljs-number">0</span>)&#123;<br>                    curSum += nums[j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(curSum == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(curSum != rSum &amp;&amp; exist.contains(-curSum))&#123; <span class="hljs-comment">// 第一个判断是因为不能同时选择左右两边的所有元素</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>折半搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6236.不重叠回文子字符串的最大数目</title>
    <link href="/2022/11/13/LC-6236-%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/11/13/LC-6236-%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/">leetcode 困难题</a></p><p>给你一个字符串 s 和一个 正 整数 k 。</p><p>从字符串 s 中选出一组满足下述条件且 不重叠 的子字符串：</p><ul><li>每个子字符串的长度 至少 为 k 。</li><li>每个子字符串是一个 回文串 。<br>返回最优方案中能选择的子字符串的 最大 数目。</li></ul><p>子字符串 是字符串中一个连续的字符序列。</p><p><strong>字符串之间互不重叠，也就是说对于任意两个子字符串 s[i..j] 和 s[x..y] ，要么 j &lt; x 要么 i &gt; y 。</strong></p><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abaccdbbd&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：可以选择 <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abaccdbbd&quot;</span> 中斜体加粗的子字符串。<span class="hljs-string">&quot;aba&quot;</span> 和 <span class="hljs-string">&quot;dbbd&quot;</span> 都是回文，且长度至少为 <span class="hljs-attr">k</span> = <span class="hljs-number">3</span> 。<br>可以证明，无法选出两个以上的有效子字符串。<br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">提示：<br><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> k &lt;<span class="hljs-operator">=</span> s.length &lt;<span class="hljs-operator">=</span> <span class="hljs-number">2000</span><br>s 仅由小写英文字母组成<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>我们可以通过两次动态规划得出结果，其中第一次动态规划处理出某个子串 <code>s(i, j)</code> 是否为回文串，第二次动态规划处理如何划分得到最多的不重叠子字符串。</p><hr><p>第一次 <code>dp</code>，定义 <code>f(i, j)</code> 表示子串 <code>s(i, j)</code> 是否为回文串，那么可以得到转移方程：</p><p><code>f(i, j) = s[i] == s[j]</code>，当 <code>j - i &lt;= 1</code> 时</p><p><code>f(i, j) = f(i + 1, j - 1) &amp;&amp; (s[i] == s[j])</code>，当 <code>j - i &gt; 1</code> 时</p><hr><p>第二次 <code>dp</code>，定义 <code>f(i)</code> 表示 <code>s(0, i)</code> 的最多不重叠回文子串数量，那么 <code>f(n)</code> 为答案。</p><p>对于某个 <code>f(i)</code>，可以分两种情况讨论：</p><p>如果 <code>s[i]</code> 不在任意回文子串内的话，那么 <code>f(i) = f(i - 1)</code>，可以作为 <code>f(i)</code> 的初始值。</p><p>如果 <code>s[i]</code> 在某个回文子串内时，枚举左端点 <code>left</code>，可以得到：<br><code>当 s(left, i) 为回文串，f(i) = Max(f(i), f(left - 1) + 1)</code>，其中<code>left</code> 取值范围为 <code>i - left + 1 &gt;= k</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPalindromes</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] c = s.toCharArray();<br>        <span class="hljs-type">boolean</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n + <span class="hljs-number">1</span>; j++)&#123;<br>                <span class="hljs-keyword">if</span>(c[i - <span class="hljs-number">1</span>] == c[j - <span class="hljs-number">1</span>] &amp;&amp; (j - i &lt;= <span class="hljs-number">1</span> || g[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]))&#123;<br>                    g[i][j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            f[i] = f[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// i不参与</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i - k + <span class="hljs-number">1</span>; left &gt;= <span class="hljs-number">1</span>; left--)&#123;<br>                <span class="hljs-keyword">if</span>(g[left][i])&#123;<br>                    f[i] = Math.max(f[i], f[left - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-790.多米诺和托米诺平铺</title>
    <link href="/2022/11/12/LC-790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/"/>
    <url>/2022/11/12/LC-790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/domino-and-tromino-tiling/">leetcode 中等题</a></p><p>有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。<br><img src="/../img/1668239955779.jpg"></p><p>给定整数 n ，返回可以铺满 2 x n 的面板的方法的数量。返回对 10e9 + 7 取模 的值。</p><p><strong>注意下图中的 1-3 方案，是白色瓷砖而不是没铺满，不要产生误解</strong></p><p><img src="/../img/1668239825809.jpg"></p><h2 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h2><ul><li>f(1) &#x3D; 1</li><li>f(2) &#x3D; 2</li><li>f(3) &#x3D; 5</li><li>f(4) &#x3D; 11 &#x3D; 5 * 2 + 1 &#x3D; f(3) * 2 + f(1)</li><li>f(5) &#x3D; 24 &#x3D; 11 * 2 + 2 &#x3D; f(4) * 2 + f(2)</li></ul><p>得出 <code>f(i) = 2 * (f - i) + f(i - 3)</code>，其中 <code>i &gt; 3</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">10</span>];<br>        f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        f[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; i &lt;= n; i++)&#123;<br>            f[i] = (((<span class="hljs-number">2</span> * f[i - <span class="hljs-number">1</span>]) % MOD) + f[i - <span class="hljs-number">3</span>]) % MOD;<br>        &#125;        <br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="找规律-滚动数组"><a href="#找规律-滚动数组" class="headerlink" title="找规律 + 滚动数组"></a>找规律 + 滚动数组</h2><p>可以发现最多会往前依赖到 <code>i - 3</code>，那么只需要保存最近的三个结果即可。</p><p>但这里为了方便（抖机灵），保存了 <code>4</code> 个结果。因为对 <code>2</code> 的 <code>n</code> 次方的取模运算，可以转换成对 <code>n - 1</code> 的与运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br>        f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        f[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> i &amp; <span class="hljs-number">3</span>, pre = i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">3</span>, magic = i - <span class="hljs-number">3</span> &amp; <span class="hljs-number">3</span>;<br>            f[cur] = (((<span class="hljs-number">2</span> * f[pre]) % MOD) + f[magic]) % MOD;<br>        &#125;        <br>        <span class="hljs-keyword">return</span> f[n &amp; <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种类型的题目由于结果固定，且数据范围有限，还能用第一种解法 + 打表对结果进行保存，由于做法类似就不在这里列出了。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>定义 <code>dp[i][j]</code> 为： 在第 <code>i</code> 列前面的正方形都被瓷砖覆盖，当前第 <code>i</code> 列状态为 <code>j</code> 时的方案数。那么第 <code>i</code> 列的正方形有四种（即 <code>j</code> 取值范围）被覆盖的情况：</p><p>第 <code>i</code> 列为空，<code>j</code> 为 <code>0</code>；</p><p>第 <code>i</code> 列上方格子为空，<code>j</code>为 <code>1</code>；</p><p>第 <code>i</code> 列下方格子为空，<code>j</code>为 <code>2</code>；</p><p>第 <code>i</code> 列为满，<code>j</code>为 <code>3</code>。</p><p>那么状态转移如下:</p><p><img src="/../img/20221112170609.png" alt="https://leetcode.cn/problems/domino-and-tromino-tiling/solution/duo-mi-nuo-he-tuo-mi-nuo-ping-pu-by-leet-7n0j/"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>            dp[i][<span class="hljs-number">1</span>] = (dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) % MOD;<br>            dp[i][<span class="hljs-number">2</span>] = (dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % MOD;<br>            dp[i][<span class="hljs-number">3</span>] = (((dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]) % MOD + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % MOD + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][<span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划-滚动数组"><a href="#动态规划-滚动数组" class="headerlink" title="动态规划 + 滚动数组"></a>动态规划 + 滚动数组</h2><p>类似于 <code>找规律 + 滚动数组</code> 的优化，<code>dp[i]</code>只往前依赖于 <code>dp[i - 1]</code>，所以可以把数组的第一维优化成 <code>2</code>。</p><p>稍微要注意的是，由于 <code>0、1、2、3</code> 状态之间存在相互依赖，所以无法优化成一维数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">4</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span>  <span class="hljs-operator">=</span> i &amp; <span class="hljs-number">1</span>, pre = i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>;<br>            dp[cur][<span class="hljs-number">0</span>] = dp[pre][<span class="hljs-number">3</span>];<br>            dp[cur][<span class="hljs-number">1</span>] = (dp[pre][<span class="hljs-number">0</span>] + dp[pre][<span class="hljs-number">2</span>]) % MOD;<br>            dp[cur][<span class="hljs-number">2</span>] = (dp[pre][<span class="hljs-number">0</span>] + dp[pre][<span class="hljs-number">1</span>]) % MOD;<br>            dp[cur][<span class="hljs-number">3</span>] = (((dp[pre][<span class="hljs-number">0</span>] + dp[pre][<span class="hljs-number">3</span>]) % MOD + dp[pre][<span class="hljs-number">1</span>]) % MOD + dp[pre][<span class="hljs-number">2</span>]) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n &amp; <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;<br>        &#125;;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br>        &#125;;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                ans = mul(matrix, ans);<br>            &#125;<br>            matrix = mul(matrix, matrix);<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 应该等价</span><br>        <span class="hljs-comment">// int[] first = new int[]&#123;0, 0, 0, 1&#125;;</span><br>        <span class="hljs-comment">// return ans[3][0] * first[0] + ans[3][1] * first[1] + ans[3][2] * first[2] + ans[3][3] * first[3];</span><br>        <span class="hljs-keyword">return</span> ans[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] mul(<span class="hljs-type">int</span>[][] a, <span class="hljs-type">int</span>[][] b)&#123;<br>        <span class="hljs-type">int</span>[][] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length][a.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; a.length; j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; a.length; k++)&#123;<br>                    ret[i][j] = (<span class="hljs-type">int</span>)((ret[i][j] + (<span class="hljs-type">long</span>) a[i][k] * b[k][j]) % MOD);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>矩阵快速幂</tag>
      
      <tag>动态规划</tag>
      
      <tag>思维题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.NULL-The-Missing-Semester-of-Your-CS-Education</title>
    <link href="/2022/11/11/6.NULL-The-Missing-Semester-of-Your-CS-Education/"/>
    <url>/2022/11/11/6.NULL-The-Missing-Semester-of-Your-CS-Education/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://missing.csail.mit.edu/">The Missing Semester of Your CS Education</a></p><p>该课程主要是教如何更高效的使用命令行、编辑器、Git 等工具。</p></blockquote><h2 id="Lecture-1-Course-overview-the-shell"><a href="#Lecture-1-Course-overview-the-shell" class="headerlink" title="Lecture 1 - Course overview + the shell"></a>Lecture 1 - Course overview + the shell</h2><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><ul><li>&gt; 将一个命令&#x2F;程序的输出流重定向到一个 <strong>文件</strong>， &lt; 相反。&gt;&gt; 和 &lt;&lt; 用做追加</li><li>管道符 <code>|</code> 与 &gt; 不同的是，目标可以是 <strong>命令&#x2F;程序</strong></li><li>单引号：所见即所得</li><li>双引号：所见非所得，它会先把变量解析之后，再输出</li></ul><h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><p>这一节练习比较简单，所以其他的省略。</p><ul><li>Write the following into that file, one line at a time:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs file">#!/bin/bash<br>curl --head --silent https://missing.csail.mit.edu<br></code></pre></td></tr></table></figure>The first line might be tricky to get working. It’s helpful to know that # starts a comment in Bash, and ! has a special meaning even within double-quoted (“) strings. Bash treats single-quoted strings (‘) differently: they will do the trick in this case. See the Bash quoting manual page for more information.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;#!/bin/bash&#x27;</span> &gt;&gt; semester<br><span class="hljs-built_in">echo</span> curl --<span class="hljs-built_in">head</span> --silent https://missing.csail.mit.edu  &gt;&gt; semester<br></code></pre></td></tr></table></figure></li><li>Use | and &gt; to write the “last modified” date output by semester into a file called last-modified.txt in your home directory.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./semester | grep last-modified | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&quot; &quot;</span> -f 2- &gt; last-modified.txt<br></code></pre></td></tr></table></figure></li></ul><h2 id="Lecture-2-Shell-Tools-and-Scripting"><a href="#Lecture-2-Shell-Tools-and-Scripting" class="headerlink" title="Lecture 2 - Shell Tools and Scripting"></a>Lecture 2 - Shell Tools and Scripting</h2><h3 id="Notes-1"><a href="#Notes-1" class="headerlink" title="Notes"></a>Notes</h3><ul><li>To assign variables in bash, use the syntax foo&#x3D;bar and access the value of the variable with $foo. Note that foo &#x3D; bar will not work since it is interpreted as calling the foo program with arguments &#x3D; and bar. In general, in shell scripts the space character will perform argument splitting. This behavior can be confusing to use at first, so always check for that.</li><li><code>$_</code> 上条命令的最后一个参数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># e.g.</span><br><span class="hljs-variable">$mkdir</span> <span class="hljs-built_in">test</span><br><span class="hljs-variable">$cd</span> <span class="hljs-variable">$_</span><br></code></pre></td></tr></table></figure></li><li><code>$?</code> 上条命令的错误代码（返回值）</li><li><code>$0</code> 脚本名字，<code>$1</code> 到 <code>$9</code> 为 bash 脚本的第一个到第九个参数</li><li><code>$?</code> 错误代码, 0正常1错误</li><li>花括号{} - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># e.g.</span><br><span class="hljs-variable">$mkdir</span> &#123;foo,bar&#125;<br><span class="hljs-variable">$mkdir</span> &#123;foo,bar&#125;/&#123;a,b,c&#125;<br><span class="hljs-variable">$mkdir</span> foo/x bar/y<br><span class="hljs-variable">$diff</span> &#123;foo,bar&#125;   <br>Common subdirectories: foo/a and bar/a<br>Common subdirectories: foo/b and bar/b<br>Common subdirectories: foo/c and bar/c<br>Only <span class="hljs-keyword">in</span> foo: x<br>Only <span class="hljs-keyword">in</span> bar: y<br></code></pre></td></tr></table></figure></li><li>当您通过 $( ls ) 这样的方式来执行 ls 这个命令时，它的输出结果会替换掉 $( ls ) 。例如，如果执行 for file in $(ls) ，shell首先将调用ls ，然后遍历得到的这些返回值。</li><li>&lt;() 进程替换（process substitution）， &lt;( ls ) 会执行 ls 并将结果输出到一个临时文件中，并将 &lt;( ls ) 替换成临时文件名。这在我们希望返回值 <strong>通过文件而不是STDIN传递</strong> 时很有用。例如， diff &lt;(ls foo) &lt;(ls bar) 会显示文件夹 foo 和 bar 中文件的区别。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># e.g.</span><br><span class="hljs-variable">$cat</span> &lt;(<span class="hljs-built_in">ls</span> foo) &lt;(<span class="hljs-built_in">ls</span> bar)<br>a<br>b<br>c<br>x<br>a<br>b<br>c<br>y<br><span class="hljs-variable">$diff</span> &lt;(<span class="hljs-built_in">ls</span> bar) &lt;(<span class="hljs-built_in">ls</span> foo)<br>4c4<br>&lt; y<br>---<br>&gt; x<br><br></code></pre></td></tr></table></figure></li><li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 ? 和 * 来匹配一个或任意个字符。例如，对于文件foo, foo1, foo2, foo10 和 bar, rm foo?这条命令会删除foo1 和 foo2 ，而rm foo* 则会删除除了bar之外的所有文件。</li><li>find<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># e.g. 删除全部扩展名为.tmp 的文件</span><br>find . -name <span class="hljs-string">&#x27;*.tmp&#x27;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">rm</span> &#123;&#125; \;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Exercises-1"><a href="#Exercises-1" class="headerlink" title="Exercises"></a>Exercises</h3><ul><li><p>Write bash functions marco and polo that do the following. Whenever you execute marco the current working directory should be saved in some manner, then when you execute polo, no matter what directory you are in, polo should cd you back to the directory where you executed marco. For ease of debugging you can write the code in a file marco.sh and (re)load the definitions to your shell by executing source marco.sh.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing  <span class="hljs-built_in">cat</span> marco.sh   <br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-function"><span class="hljs-title">marco</span></span>()&#123;<br>    <span class="hljs-built_in">pwd</span> &gt; /tmp/missing/save-path.log<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">polo</span></span>()&#123;<br>    p=$(<span class="hljs-built_in">cat</span> /tmp/missing/save-path.log)<br>    <span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$p</span>&quot;</span><br>&#125;<br><br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing  <span class="hljs-built_in">cd</span> /usr/local/dev<br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /usr/local/dev  <span class="hljs-built_in">source</span> /tmp/missing/marco.sh <br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /usr/local/dev  marco    <br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /usr/local/dev  <span class="hljs-built_in">cat</span> /tmp/missing/save-path.log <br>/usr/local/dev<br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /usr/local/dev  <span class="hljs-built_in">cd</span> /                          <br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /  polo          <br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /usr/local/dev  <br></code></pre></td></tr></table></figure></li><li><p>Say you have a command that fails rarely. In order to debug it you need to capture its output but it can be time consuming to get a failure run. Write a bash script that runs the following script until it fails and captures its standard output and error streams to files and prints everything at the end. Bonus points if you can also report how many runs it took for the script to fail.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  <span class="hljs-built_in">cat</span> call.sh  <br><span class="hljs-comment">#!/usr/bin/env bash</span><br>count=1<br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span><br>    ./mock &amp;&gt;&gt; out.log<br>    <span class="hljs-keyword">if</span> [[ $? -ne 0 ]]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">cat</span> out.log<br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$count</span>&quot;</span><br>        <span class="hljs-built_in">break</span><br>    <span class="hljs-keyword">fi</span><br>    ((count++))<br><span class="hljs-keyword">done</span><br><br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  ./call.sh <br>119<br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  <span class="hljs-built_in">cat</span> out.log<br>...<br>Everything went according to plan<br>Everything went according to plan<br>Everything went according to plan<br>Something went wrong<br>The error was using magic numbers<br></code></pre></td></tr></table></figure></li><li><p>Your task is to write a command that recursively finds all HTML files in the folder and makes a zip with them. Note that your command should work even if the files have spaces (hint: check -d flag for xargs).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  <span class="hljs-built_in">mkdir</span> &#123;a,b&#125;    <br>⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  <span class="hljs-built_in">touch</span>  &#123;a,b&#125;/&#123;1,2.html,3.html&#125;                  <br>⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  <span class="hljs-built_in">touch</span> &#123;a,b&#125;/&#123;4\ 4.html,5\ 5.html&#125;<br>⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  find . -name <span class="hljs-string">&quot;*.html&quot;</span> -print0 | xargs -0 zip -r 1.zip<br><span class="hljs-comment"># or</span><br>⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  find . -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*.html&quot;</span> | xargs -d <span class="hljs-string">&#x27;\n&#x27;</span>  tar -cvzf html.zip<br></code></pre></td></tr></table></figure></li></ul><h2 id="Lecture-3-command-lineShell-Tools-and-Scripting"><a href="#Lecture-3-command-lineShell-Tools-and-Scripting" class="headerlink" title="Lecture 3 - command-lineShell Tools and Scripting"></a>Lecture 3 - command-lineShell Tools and Scripting</h2><h3 id="Notes-2"><a href="#Notes-2" class="headerlink" title="Notes"></a>Notes</h3><h3 id="Exercises-2"><a href="#Exercises-2" class="headerlink" title="Exercises"></a>Exercises</h3><p>Job control<br>2. …<br>However, this strategy will fail if we start in a different bash session, since wait only works for child processes. One feature we did not discuss in the notes is that the kill command’s exit status will be zero on success and nonzero otherwise. kill -0 does not send a signal but will give a nonzero exit status if the process does not exist. Write a bash function called pidwait that takes a pid and waits until the given process completes. You should use sleep to avoid wasting CPU unnecessarily.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># root at izwz9bpgwmtcoix1llcjwqz in /tmp/missing/lecture-3 [7:23:55] → cat pidwait     </span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">kill</span> -0 <span class="hljs-variable">$1</span>;<span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">sleep</span> 1<br><span class="hljs-keyword">done</span><br><span class="hljs-comment"># root at izwz9bpgwmtcoix1llcjwqz in /tmp/missing/lecture-3 [7:22:35] → sleep 35 &amp;</span><br>[1] 16599<br><span class="hljs-comment"># root at izwz9bpgwmtcoix1llcjwqz in /tmp/missing/lecture-3 [7:22:41] → pgrep -f sleep\ 35 | xargs ./pidwait</span><br>+ 16599 <span class="hljs-keyword">done</span>       <span class="hljs-built_in">sleep</span> 35<br>./pidwait: line 2: <span class="hljs-built_in">kill</span>: (16599) - No such process<br></code></pre></td></tr></table></figure><p>Dotfiles<br>5.Migrate all of your current tool configurations to your dotfiles repository.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Now I use https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/lra/m</span>ackup.<br>Other choices https:<span class="hljs-regexp">//</span>dotfiles.github.io<span class="hljs-regexp">/utilities/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-864.获取所有钥匙的最短路径</title>
    <link href="/2022/11/10/LC-864-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/11/10/LC-864-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/shortest-path-to-get-all-keys/">leetcode 困难题</a></p><p>给定一个二维网格 grid ，其中：</p><ul><li>‘.’ 代表一个空房间</li><li>‘#’ 代表一堵</li><li>‘@’ 是起点</li><li>小写字母代表钥匙</li><li>大写字母代表锁</li></ul><p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p><p>假设 k 为 钥匙&#x2F;锁 的个数，且满足 1 &lt;&#x3D; k &lt;&#x3D; 6，字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p><p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。</p><p>示例1：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">grid</span> = [<span class="hljs-string">&quot;@.a.#&quot;</span>,<span class="hljs-string">&quot;###.#&quot;</span>,<span class="hljs-string">&quot;b.A.B&quot;</span>]<br>输出：<span class="hljs-number">8</span><br>解释：目标是获得所有钥匙，而不是打开所有锁。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">grid</span> = [<span class="hljs-string">&quot;@..aA&quot;</span>,<span class="hljs-string">&quot;..B#.&quot;</span>,<span class="hljs-string">&quot;....b&quot;</span>]<br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: grid = [&quot;@Aa&quot;]</span><br><span class="hljs-section">输出: -1</span><br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">m == grid.length<br>n == grid[i].length<br><span class="hljs-number">1</span> &lt;= m, n &lt;= <span class="hljs-number">30</span><br>grid[i][j] 只含有 <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;#&#x27;</span>, <span class="hljs-string">&#x27;@&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>-<span class="hljs-string">&#x27;f&#x27;</span> 以及 <span class="hljs-string">&#x27;A&#x27;</span>-<span class="hljs-string">&#x27;F&#x27;</span><br>钥匙的数目范围是 [<span class="hljs-number">1</span>, <span class="hljs-number">6</span>] <br>每个钥匙都对应一个 不同 的字母<br>每个钥匙正好打开一个对应的锁<br></code></pre></td></tr></table></figure><h2 id="BFS-状态压缩"><a href="#BFS-状态压缩" class="headerlink" title="BFS + 状态压缩"></a>BFS + 状态压缩</h2><p>对于最短路径我们可以通过 <a href="https://oi-wiki.org/graph/bfs/">BFS</a> 求出，并且因为钥匙最多只有 6 把，所以可以通过一个 <code>int</code> 来记录当前路径获得钥匙的情况 (称为 <code>state</code>)，对应位数为 1 时代表已经取得对应钥匙。</p><p>需要注意的是，不同于普通的 <code>BFS</code>：在确定访问状态时，不能仅仅通过坐标 <code>x, y</code> 来确定，还要加入状态，也就是说通过 <code>x, y, state</code> 来确定一个访问状态。</p><p>这是因为比如说经过某个房间 <code>a</code> 后，在房间 <code>b</code> 拿到一把新锁，接着又因为碰到墙壁或者其他未拿到钥匙的锁需要原路返回，重新经过了 <code>a</code>，那么这显然是一条新的有效路径（因为拿到了 <code>b</code> 的锁），所以我们还需要加入钥匙 <code>state</code> 来确定访问状态。反之如果坐标和钥匙 <code>state</code> 都相同，就是无效的路径，无需重新入队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathAllKeys</span><span class="hljs-params">(String[] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">keyCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stratx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, starty = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 初始化图、统计钥匙数量、记录起点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            g[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[m];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> grid[i].charAt(j);<br>                g[i][j] = c;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= sub &amp;&amp; sub &lt;= <span class="hljs-number">23</span>)&#123;<br>                    keyCount++;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;@&#x27;</span>)&#123;<br>                    stratx = i;<br>                    starty = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// Deque for BFS</span><br>        Deque&lt;<span class="hljs-type">int</span>[]&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        deque.offerLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;stratx, starty, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-comment">// 通过 `[x][y][state]` 来确定访问状态，并且记录下此时的路径距离，初始化为 -1 表示未访问过</span><br>        <span class="hljs-type">int</span>[][][] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m][<span class="hljs-number">1</span> &lt;&lt; keyCount];<br>        IntStream.range(<span class="hljs-number">0</span>, n).forEach(i -&gt; IntStream.range(<span class="hljs-number">0</span>, m).forEach(j -&gt; Arrays.fill(vis[i][j], - <span class="hljs-number">1</span>)));<br>        vis[stratx][starty][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            <span class="hljs-type">int</span>[] cur = deque.pollFirst();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> vis[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]][cur[<span class="hljs-number">2</span>]] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; help.length; i++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>] + help[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>] + help[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(!checkIndex(x, y, n, m) || g[x][y] == <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> g[x][y];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">if</span>(c != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;@&#x27;</span> &amp;&amp; (c &amp; <span class="hljs-number">32</span>) == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 锁</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">need</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;A&#x27;</span>);<br>                    <span class="hljs-keyword">if</span>((state &amp; need) != need)&#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(c != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; (c &amp; <span class="hljs-number">32</span>) == <span class="hljs-number">32</span>)&#123; <br>                    <span class="hljs-comment">// 钥匙</span><br>                    state |= (<span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;a&#x27;</span>));<br>                    <span class="hljs-keyword">if</span>(getCurKeyCount(state) == keyCount)&#123;<br>                        <span class="hljs-keyword">return</span> d;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(vis[x][y][state] == -<span class="hljs-number">1</span>)&#123;<br>                    vis[x][y][state] = d;<br>                    deque.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x, y, state&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> xLimit, <span class="hljs-type">int</span> yLimit)</span>&#123;<br>        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; xLimit &amp;&amp; y &lt; yLimit;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCurKeyCount</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(state &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>((state &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                count++;<br>            &#125;<br>            state = state &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>状态压缩</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about-windows</title>
    <link href="/2022/11/10/about-windows/"/>
    <url>/2022/11/10/about-windows/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前 <code>windows</code> 使用的比较多，在日常使用中会重复遇到一些问题，但总是解决后过段时间就忘了，所以在此记录下来。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>需要知道的是，<code>cmd</code> 和 <code>PowerShell</code> 打印某个环境变量的方式是不同的</p><ul><li>cmd<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">echo</span> <span class="hljs-variable">%Path%</span><br></code></pre></td></tr></table></figure></li><li>PowerShell<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-variable">$env:path</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="刷新环境变量"><a href="#刷新环境变量" class="headerlink" title="刷新环境变量"></a>刷新环境变量</h3><p><a href="https://github.com/chocolatey/choco">choco</a> 内置的 <code>refreshenv</code> 可以帮助我们在不重启终端的情况下方便的刷新环境变量。</p><p>需要注意的是虽然旧版命令行可以通过重启终端的手段刷新环境变量，但在 <a href="https://github.com/microsoft/terminal">win11 默认的 terminal</a> 中由于 <a href="https://github.com/microsoft/terminal/issues/1125">某些问题</a> 导致无法确保重启终端能够刷新环境变量。在这种时候，使用 <code>choco</code> 中的 <code>refreshenv</code> 几乎就是必须的了。</p><ul><li><p>cmd</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">refreshenv<br></code></pre></td></tr></table></figure></li><li><p>可能会发现在 <code>PowerShell</code> 中使用该命令并没有生效，这是因为还要进行 <a href="https://docs.chocolatey.org/en-us/troubleshooting#why-does-choco-tab-not-work-for-me">some additional work</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Uncategorized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6232.最小移动总距离</title>
    <link href="/2022/11/08/LC-6232-%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%80%BB%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/11/08/LC-6232-%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%80%BB%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/minimum-total-distance-traveled/">leetcode 困难题</a></p><p>X 轴上有一些机器人和工厂。给你一个整数数组 robot ，其中 robot[i] 是第 i 个机器人的位置。再给你一个二维整数数组 factory ，其中 factory[j] &#x3D; [positionj, limitj] ，表示第 j 个工厂的位置在 positionj ，且第 j 个工厂最多可以修理 limitj 个机器人。</p><p>每个机器人所在的位置 互不相同 。每个工厂所在的位置也 互不相同 。注意一个机器人可能一开始跟一个工厂在 相同的位置 。</p><p>所有机器人一开始都是坏的，他们会沿着设定的方向一直移动。设定的方向要么是 X 轴的正方向，要么是 X 轴的负方向。当一个机器人经过一个没达到上限的工厂时，这个工厂会维修这个机器人，且机器人停止移动。</p><p>任何时刻，你都可以设置 部分 机器人的移动方向。你的目标是最小化所有机器人总的移动距离。</p><p>请你返回所有机器人移动的最小总距离。测试数据保证所有机器人都可以被维修。</p><p>注意：</p><p>所有机器人移动速度相同。<br>如果两个机器人移动方向相同，它们永远不会碰撞。<br>如果两个机器人迎面相遇，它们也不会碰撞，它们彼此之间会擦肩而过。<br>如果一个机器人经过了一个已经达到上限的工厂，机器人会当作工厂不存在，继续移动。<br>机器人从位置 x 到位置 y 的移动距离为 |y - x| 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：robot = [0,4,6], factory = [[2,2],[6,2]]<br>输出：4<br>解释：如上图所示：<br>- 第一个机器人从位置<span class="hljs-number"> 0 </span>沿着正方向移动，在第一个工厂处维修。<br>- 第二个机器人从位置<span class="hljs-number"> 4 </span>沿着负方向移动，在第一个工厂处维修。<br>- 第三个机器人在位置<span class="hljs-number"> 6 </span>被第二个工厂维修，它不需要移动。<br>第一个工厂的维修上限是<span class="hljs-number"> 2 </span>，它维修了<span class="hljs-number"> 2 </span>个机器人。<br>第二个工厂的维修上限是<span class="hljs-number"> 2 </span>，它维修了<span class="hljs-number"> 1 </span>个机器人。<br>总移动距离是 |2 - 0| + |2 - 4| + |6 - 6| =<span class="hljs-number"> 4 </span>。没有办法得到比<span class="hljs-number"> 4 </span>更少的总移动距离。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：robot = [1,-1], factory = [[-2,1],[2,1]]<br>输出：2<br>解释：如上图所示：<br>- 第一个机器人从位置<span class="hljs-number"> 1 </span>沿着正方向移动，在第二个工厂处维修。<br>- 第二个机器人在位置 -1 沿着负方向移动，在第一个工厂处维修。<br>第一个工厂的维修上限是<span class="hljs-number"> 1 </span>，它维修了<span class="hljs-number"> 1 </span>个机器人。<br>第二个工厂的维修上限是<span class="hljs-number"> 1 </span>，它维修了<span class="hljs-number"> 1 </span>个机器人。<br>总移动距离是 |2 - 1| + |(-2) - (-1)| =<span class="hljs-number"> 2 </span>。没有办法得到比<span class="hljs-number"> 2 </span>更少的总移动距离。<br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span> &lt;= robot<span class="hljs-selector-class">.length</span>, factory<span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">100</span><br>factory<span class="hljs-selector-attr">[j]</span><span class="hljs-selector-class">.length</span> == <span class="hljs-number">2</span><br>-<span class="hljs-number">109</span> &lt;= robot<span class="hljs-selector-attr">[i]</span>, positionj &lt;= <span class="hljs-number">109</span><br><span class="hljs-number">0</span> &lt;= limitj &lt;= robot<span class="hljs-selector-class">.length</span><br>测试数据保证所有机器人都可以被维修。<br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>有一个关键的结论：</p><blockquote><p>设两个机器人的位置分别为 r1, r2，且 r1 &lt; r2 ，机器人去的工厂的位置为 f1,f2 ，则 f1 必然小于 f2 ，因为如果 f1 &gt; f2 的话，交换这两个机器人去的工厂，移动距离就变小了。</p></blockquote><p>因此我们可以先对机器人和工厂按照位置从小到大排序，那么每个工厂要修复的机器人就将是连续的一段。</p><hr><p><strong>在以下几种解法中，我们统一设 f(i, j) 的含义为第 j 个及其右侧的工厂，修理第 i 个及其右侧的机器人时的最小距离，那么 f(0, 0) 就是题目所求。</strong></p><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>一种解法是递归 + 记忆化搜索。</p><p>对于某个 <code>f(i, j)</code>，我们枚举出第 <code>j</code> 个工厂修任意个机器人的可能（比如修 <code>k</code> 个），同时设修这 <code>k</code> 个机器人所花费的距离为 <code>d(k)</code>，那么只需要取所有 <code>f(i + k + 1, j + 1) + d(k)</code> 的最小值，就是我们要求的 <code>f(i, j)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">long</span>[][] cache;<br>    List&lt;Integer&gt; robot;<br>    <span class="hljs-type">int</span>[][] factory;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTotalDistance</span><span class="hljs-params">(List&lt;Integer&gt; robot, <span class="hljs-type">int</span>[][] factory)</span> &#123;<br>        Collections.sort(robot);<br>        Arrays.sort(factory, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">this</span>.robot = robot;<br>        <span class="hljs-built_in">this</span>.factory = factory;<br>        <span class="hljs-built_in">this</span>.cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[robot.size()][factory.length];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// cache[i][j] 表示第 i 个及其右侧的工厂，修理第 j 个及其右侧的机器人时的最小距离</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= robot.size())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j &gt;= factory.length)&#123;<br>            <span class="hljs-keyword">return</span> Long.MAX_VALUE; <span class="hljs-comment">// Integer.MAX_VALUE 不够大</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(cache[i][j] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> cache[i][j];<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> dfs(i, j + <span class="hljs-number">1</span>); <span class="hljs-comment">// 初始化为当前工厂不修理任何机器人</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; factory[j][<span class="hljs-number">1</span>] &amp;&amp; i + k &lt; robot.size(); k++)&#123;<br>            d +=  Math.abs(robot.get(i + k) - factory[j][<span class="hljs-number">0</span>]); <span class="hljs-comment">// d(a)</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> dfs(i + k + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> temp == Long.MAX_VALUE ? Long.MAX_VALUE : temp + d; <span class="hljs-comment">//防止溢出</span><br>            min = Math.min(min, next);<br>        &#125;<br>        cache[i][j] = min;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><p>根据 <code>记忆化搜索</code> 的解法，我们容易发现前面工厂的状态总是依赖于后面工厂的状态，所以我们只需要逆序遍历 <code>factory</code> 就可以实现动态规划，简略的方程如下：</p><p><code>f(i, j) = min( f(i + k + 1, j + 1) + d(k) ) </code>（ <code>k</code> 取值范围为 <code>[0, factory[i][1]] - 1</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTotalDistance</span><span class="hljs-params">(List&lt;Integer&gt; robot, <span class="hljs-type">int</span>[][] factory)</span> &#123;<br>        Collections.sort(robot);<br>        Arrays.sort(factory, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> robot.size(), fs = factory.length;<br>        <span class="hljs-comment">// dp[i][j] 表示第 i 个及其右侧的工厂，修理第 j 个及其右侧的机器人时的最小距离</span><br>        <span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[rs][fs + <span class="hljs-number">1</span>];<br>        IntStream.range(<span class="hljs-number">0</span>, dp.length).forEach(index -&gt; Arrays.fill(dp[index], Long.MAX_VALUE));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> fs - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rs; i++)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> dp[i][j + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 初始化为一个都不修</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= factory[j][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &amp;&amp; i + k &lt; rs; k++)&#123;<br>                    d += Math.abs(robot.get(i + k) - factory[j][<span class="hljs-number">0</span>]);<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> i + k == rs - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : dp[i + k + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] ;<br>                    <span class="hljs-keyword">if</span>(next != Long.MAX_VALUE)&#123;<br>                        min = Math.min(min, next + d);<br>                    &#125;<br>                &#125;<br>                dp[i][j] = min;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h3><p>就像背包问题一样，我们可以发现工厂 <code>j</code> 只会依赖于工厂 <code>j + 1</code> 的状态，即实际上我们只需要保留最新的工厂状态，可以利用滚动数组进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTotalDistance</span><span class="hljs-params">(List&lt;Integer&gt; robot, <span class="hljs-type">int</span>[][] factory)</span> &#123;<br>        Collections.sort(robot);<br>        Arrays.sort(factory, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> robot.size(), fs = factory.length;<br>        <span class="hljs-comment">// dp[i][j] 表示第 i 个及其右侧的工厂，修理第 j 个及其右侧的机器人时的最小距离</span><br>        <span class="hljs-type">long</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[rs + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, Long.MAX_VALUE);<br>        dp[rs] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> fs - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rs; i++)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> dp[i]; <span class="hljs-comment">// 一个都不修</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= factory[j][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &amp;&amp; i + k &lt; rs; k++)&#123;<br>                    d += Math.abs(robot.get(i + k) - factory[j][<span class="hljs-number">0</span>]);<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> dp[i + k + <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>(next != Long.MAX_VALUE)&#123;<br>                        min = Math.min(min, next + d);<br>                    &#125;<br>                &#125;<br>                dp[i] = min;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6231.雇佣K位工人的总代价</title>
    <link href="/2022/11/06/LC-6231-%E9%9B%87%E4%BD%A3K%E4%BD%8D%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%80%BB%E4%BB%A3%E4%BB%B7/"/>
    <url>/2022/11/06/LC-6231-%E9%9B%87%E4%BD%A3K%E4%BD%8D%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%80%BB%E4%BB%A3%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/total-cost-to-hire-k-workers/">leetcode 中等题</a></p><p>给你一个下标从 0 开始的整数数组 costs ，其中 costs[i] 是雇佣第 i 位工人的代价。</p><p>同时给你两个整数 k 和 candidates 。我们想根据以下规则恰好雇佣 k 位工人：</p><p>总共进行 k 轮雇佣，且每一轮恰好雇佣一位工人。<br>在每一轮雇佣中，从最前面 candidates 和最后面 candidates 人中选出代价最小的一位工人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。<br>比方说，costs &#x3D; [3,2,7,7,1,2] 且 candidates &#x3D; 2 ，第一轮雇佣中，我们选择第 4 位工人，因为他的代价最小 [3,2,7,7,1,2] 。<br>第二轮雇佣，我们选择第 1 位工人，因为他们的代价与第 4 位工人一样都是最小代价，而且下标更小，[3,2,7,7,2] 。注意每一轮雇佣后，剩余工人的下标可能会发生变化。<br>如果剩余员工数目不足 candidates 人，那么下一轮雇佣他们中代价最小的一人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。<br>一位工人只能被选择一次。<br>返回雇佣恰好 k 位工人的总代价。</p><p>示例1：<br>输入：costs &#x3D; [17,12,10,2,7,2,11,20,8], k &#x3D; 3, candidates &#x3D; 4<br>输出：11<br>解释：我们总共雇佣 3 位工人。总代价一开始为 0 。</p><ul><li>第一轮雇佣，我们从 [17,12,10,2,,2,11,20,8] 中选择。最小代价是 2 ，有两位工人，我们选择下标更小的一位工人，即第 3 位工人。总代价是 0 + 2 &#x3D; 2 。</li><li>第二轮雇佣，我们从 [17,12,10,7,2,11,20,8] 中选择。最小代价是 2 ，下标为 4 ，总代价是 2 + 2 &#x3D; 4 。</li><li>第三轮雇佣，我们从 [17,12,10,7,11,20,8] 中选择，最小代价是 7 ，下标为 3 ，总代价是 4 + 7 &#x3D; 11 。注意下标为 3 的工人同时在最前面和最后面 4 位工人中。<br>总雇佣代价是 11 。</li></ul><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= costs.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= costs[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= k, candidates &lt;= costs.length<br></code></pre></td></tr></table></figure><h2 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h2><p>通过两个最小堆模拟 <code>最前面 candidates 和最后面 candidates 个人</code> 即可，具体来说每次取出两个堆的最小值，接着继续尝试维护堆直到 <code>k</code> 轮选人结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">totalCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] costs, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> candidates)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> costs.length;<br>        Comparator&lt;<span class="hljs-type">int</span>[]&gt; cmp = (a, b) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];<br>        &#125;;<br>        <span class="hljs-comment">// 实际上不需要比较下标，可以改成 PriorityQueue&lt;Integer&gt;</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; front = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(cmp); <br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(cmp);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; candidates &amp;&amp; left &lt;= right; i++)&#123; <span class="hljs-comment">// candidates 个人</span><br>            front.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[left], left++&#125;);<br>            <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            tail.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[right], right--&#125;);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(k-- &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span>[] f = front.peek();<br>            <span class="hljs-type">int</span>[] t = tail.peek();<br>            <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span> || (f != <span class="hljs-literal">null</span> &amp;&amp; f[<span class="hljs-number">0</span>] &lt;= t[<span class="hljs-number">0</span>]))&#123;<br>                ans += front.poll()[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">if</span>(left &lt;= right)&#123;<br>                    front.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[left], left++&#125;);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans += tail.poll()[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">if</span>(left &lt;= right)&#123;<br>                    tail.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[right], right--&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6230.长度为K子数组中的最大和</title>
    <link href="/2022/11/06/LC-6230-%E9%95%BF%E5%BA%A6%E4%B8%BAK%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <url>/2022/11/06/LC-6230-%E9%95%BF%E5%BA%A6%E4%B8%BAK%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/">leetcode 中等题</a></p><p>给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和：</p><p>子数组的长度是 k，且<br>子数组中的所有元素 各不相同 。<br>返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。</p><p>子数组 是数组中一段连续非空的元素序列。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,5,4,2,9,9,9], k = 3<br>输出：15<br>解释：nums 中长度为<span class="hljs-number"> 3 </span>的子数组是：<br>- [1,5,4] 满足全部条件，和为<span class="hljs-number"> 10 </span>。<br>- [5,4,2] 满足全部条件，和为<span class="hljs-number"> 11 </span>。<br>- [4,2,9] 满足全部条件，和为<span class="hljs-number"> 15 </span>。<br>- [2,9,9] 不满足全部条件，因为元素<span class="hljs-number"> 9 </span>出现重复。<br>- [9,9,9] 不满足全部条件，因为元素<span class="hljs-number"> 9 </span>出现重复。<br>因为<span class="hljs-number"> 15 </span>是满足全部条件的所有子数组中的最大子数组和，所以返回<span class="hljs-number"> 15 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [4,4,4], k = 3<br>输出：0<br>解释：nums 中长度为<span class="hljs-number"> 3 </span>的子数组是：<br>- [4,4,4] 不满足全部条件，因为元素<span class="hljs-number"> 4 </span>出现重复。<br>因为不存在满足全部条件的子数组，所以返回<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= k &lt;= nums.length &lt;= <span class="hljs-number">1e5</span><br><span class="hljs-symbol">1 </span>&lt;= nums[i] &lt;= <span class="hljs-number">1e5</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>滑动窗口的时间复杂度只有 <code>O(N)</code>，因为不管嵌套了几次内层循环，左右指针都是单调的从 <code>0 -&gt; (n - 1)</code> 递增，即总共的循环次数只会有 <code>n</code> 次，所以时间复杂度是满足题目的数据范围要求的。</p><h2 id="滑动窗口-Set"><a href="#滑动窗口-Set" class="headerlink" title="滑动窗口 + Set"></a>滑动窗口 + Set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumSubarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Set&lt;Integer&gt; exist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n &amp;&amp; j &lt; n; j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightItem</span> <span class="hljs-operator">=</span> nums[j];<br>            <span class="hljs-keyword">while</span>(exist.contains(rightItem))&#123;<br>                <span class="hljs-comment">// 存在重复元素, 移动左指针，直到重复元素被移除了</span><br>                exist.remove(nums[i]);<br>                curSum -= nums[i++];<br>            &#125;<br>            curSum += rightItem;<br>            exist.add(rightItem);<br>            <span class="hljs-keyword">if</span>(exist.size() &gt; k)&#123;<br>                exist.remove(nums[i]);<br>                curSum -= nums[i++];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(exist.size() == k)&#123;<br>                ans = Math.max(ans, curSum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O（N）：左右指针单调的从 <code>0-&gt;(n - 1)</code> 递增，循环次数总共只会有 <code>n</code> 次</li><li>空间复杂度：O（K）</li></ul><h2 id="滑动窗口-Map"><a href="#滑动窗口-Map" class="headerlink" title="滑动窗口 + Map"></a>滑动窗口 + Map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumSubarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Map&lt;Integer, Integer&gt; cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= k - <span class="hljs-number">1</span>; j++)&#123;<br>            cnt.put(nums[j], cnt.getOrDefault(nums[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            curSum += nums[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt.size() == k)&#123;<br>            ans = Math.max(ans, curSum);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = k; j &lt; n; i++, j++)&#123;<br>            curSum -= nums[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> cnt.get(nums[i - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span>(value == <span class="hljs-number">1</span>)&#123;<br>                cnt.remove(nums[i - <span class="hljs-number">1</span>]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cnt.put(nums[i - <span class="hljs-number">1</span>], value - <span class="hljs-number">1</span>);<br>            &#125;<br>            curSum += nums[j];<br>            cnt.put(nums[j], cnt.getOrDefault(nums[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(cnt.size() == k)&#123;<br>                ans = Math.max(ans, curSum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O（N）</li><li>空间复杂度：O（K）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-375.猜数字大小II</title>
    <link href="/2022/11/05/LC-375-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8FII/"/>
    <url>/2022/11/05/LC-375-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8FII/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/">leetcode 中等题</a></p><p>我们正在玩一个猜数游戏，游戏规则如下：</p><p>我从 1 到 n 之间选择一个数字。</p><ol><li>你来猜我选了哪个数字。</li><li>如果你猜到正确的数字，就会赢得游戏 。</li><li>如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。</li><li>每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。</li></ol><p>给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2<br>输出：1<br>解释：有两个可能的数字<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 2 </span>。<br>- 你可以先猜<span class="hljs-number"> 1 </span>。<br>    - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。<br>    - 如果我的数字更大，那么这个数字一定是<span class="hljs-number"> 2 </span>。你猜测数字为<span class="hljs-number"> 2 </span>并赢得游戏，总费用为 $1 。<br>最糟糕的情况下，你需要支付 $1 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">0</span><br>解释：只有一个可能的数字，所以你可以直接猜 <span class="hljs-number">1</span> 并赢得游戏，无需支付任何费用。<br></code></pre></td></tr></table></figure><p>提示:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= n &lt;= <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h2 id="递归-TLE"><a href="#递归-TLE" class="headerlink" title="递归(TLE)"></a>递归(TLE)</h2><p>枚举所有选择，以及对应答案的所有可能，稳 TLE，需要优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt;= end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++)&#123;<br>            <span class="hljs-comment">// 无法决策答案是哪个数，只能取最差情况，因为要确保获胜</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Math.max(dfs(start, i - <span class="hljs-number">1</span>), dfs(i + <span class="hljs-number">1</span>, end)) + i;<br>            <span class="hljs-comment">// 可以决策要猜哪个数，取最好的情况</span><br>            ans = Math.min(ans, cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>容易发现计算的结果其实只跟区间的开始以及结束有关（即 dfs 的入参），同时又因为数据范围只有 1-200 ，所以可以通过一个二维数组 <code>cache</code> 来保存计算过的结果来避免重复计算，<code>cache[i][j]</code> 表示 i 到 j 范围的数确保获胜的最小现金数， <code>cache[1][n]</code> 为题目所求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] cache;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt;= end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cache[start][end] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> cache[start][end];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++)&#123;<br>            <span class="hljs-comment">// 无法决策答案是哪个数，只能取最差情况，因为要确保获胜</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Math.max(dfs(start, i - <span class="hljs-number">1</span>), dfs(i + <span class="hljs-number">1</span>, end)) + i;<br>            <span class="hljs-comment">// 可以决策要猜哪个数，取最好的情况</span><br>            ans = Math.min(ans, cur);<br>        &#125;<br>        cache[start][end] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间-DP"><a href="#区间-DP" class="headerlink" title="区间 DP"></a>区间 DP</h2><p>我们发现在求解 <code>[start, end]</code> 区间时，假设当前选择的数是 <code>i</code>，那么只会依赖区间 <code>[start, i - 1]</code> 和 <code>[ i + 1, end]</code>，同时还具有以下几点性质：</p><ol><li>每次在求解某个区间的结果时，只会依赖更小的区间</li><li><code>f(start, end)</code> 下某个 <code>i</code> 最小成本 &#x3D; <code>max(f(start, i - 1), f(i + 1, end)) + i</code></li><li>如果 <code>start == end</code>，那么最小成本为 0，如果 <code>start + 1 == end</code>, 那么最小成本为 <code>start</code></li></ol><p>由第 1 点可知在求解区间需要逆推，从 <code>[n - 2, n]</code> 开始扩散区间直到求出 <code>[1, n]</code>，整个过程如下：</p><p><code>[n - 2, n - 2 + 2] -&gt; [n - 3, n - 1] -&gt; [n - 3, n] -&gt; ... -&gt; [1, n]</code> </p><p>而由第 3 点我们可以先得到所有 <code>start + 1 &lt;= end</code> 的区间结果，那么在求解其他所有区间的过程中就可以通过第 2 点的式子以及第 3 点的结果逐步得出所有区间的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>             dp[i][i + <span class="hljs-number">1</span>] = i; <span class="hljs-comment">// 初始化所有 start + 1 &lt;= end 区间的结果</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--)&#123; <span class="hljs-comment">// 从小区间开始逐渐扩散</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">2</span>; j &lt;= n; j++)&#123; <br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i; x &lt;= j; x++)&#123; <span class="hljs-comment">// 枚举猜的数</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Math.max(dp[i][x - <span class="hljs-number">1</span>], dp[x + <span class="hljs-number">1</span>][j]) + x; <span class="hljs-comment">// 无法决策答案是哪个数，只能取最差情况，因为要确保获胜</span><br>                    cur = Math.min(cur, t); <span class="hljs-comment">// 取枚举出来的猜某个数的最好结果</span><br>                &#125;<br>                dp[i][j] = cur;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][n];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-10-I.斐波那契数列</title>
    <link href="/2022/11/04/LC-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <url>/2022/11/04/LC-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">leetcode 简单题</a></p><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>,   <span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(N)</span></span> = <span class="hljs-built_in">F</span>(N - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(N - <span class="hljs-number">2</span>), 其中 N &gt; <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007）</p><h2 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1E9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (a + b) % MOD; <br>            a = b;<br>            b = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>对于数列递推问题，可以使用矩阵快速幂进行加速，矩阵快速幂的时间复杂度能够突破线性达到 <code>O(logN)</code>。</p><p><a href="https://oi-wiki.org/math/binary-exponentiation/">OI-WIKI-快速幂</a>　　<a href="https://oi-wiki.org/math/linear-algebra/matrix/#%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95">OI-WIKI-矩阵乘法</a>　　<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247488198&idx=1&sn=8272ca6b0ef6530413da4a270abb68bc&chksm=fd9cb9d9caeb30cf6c2defab0f5204adc158969d64418916e306f6bf50ae0c38518d4e4ba146&token=1067450240&lang=zh_CN#rd">宫水三叶-矩阵快速幂</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1E9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">long</span>[][] matrix = &#123;<br>                &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>                &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;<br>        &#125;;<br>        <span class="hljs-type">long</span>[][] ans = &#123;<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br>        &#125;; <span class="hljs-comment">// 矩阵中的1，对角线为1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((k &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>                ans = mul(matrix, ans); <span class="hljs-comment">// 快速幂，将对应二进制位为 1 时的整系数幂乘起来</span><br>            &#125;<br>            matrix = mul(matrix, matrix);<br>            k &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(ans[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] % MOD); <span class="hljs-comment">// 实际上为 ans[0][0] * f(1) + ans[0][1] * f(0)</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span>[][] mul(<span class="hljs-type">long</span>[][] matrix1, <span class="hljs-type">long</span>[][] matrix2) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix1.length;<br>        <span class="hljs-type">long</span>[][] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                ret[i][j] = (((matrix1[i][<span class="hljs-number">0</span>] * matrix2[<span class="hljs-number">0</span>][j]) % MOD) + ((matrix1[i][<span class="hljs-number">1</span>] * matrix2[<span class="hljs-number">1</span>][j]) % MOD)) % MOD; <span class="hljs-comment">// 同余</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>矩阵快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-464.我能赢吗</title>
    <link href="/2022/11/03/LC-464-%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97/"/>
    <url>/2022/11/03/LC-464-%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/can-i-win/submissions/">leetcode 中等题</a></p><p>两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过  100 的玩家，即为胜者。</p><p>两位玩家不能使用重复的整数 </p><p>给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家是否能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。</p><p>示例 1:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：maxChoosableInteger = 10, desiredTotal = 11<br>输出：false<br>解释：<br>无论第一个玩家选择哪个整数，他都会失败。<br>第一个玩家可以选择从<span class="hljs-number"> 1 </span>到<span class="hljs-number"> 10 </span>的整数。<br>如果第一个玩家选择 1，那么第二个玩家只能选择从<span class="hljs-number"> 2 </span>到<span class="hljs-number"> 10 </span>的整数。<br>第二个玩家可以通过选择整数 10（那么累积和为<span class="hljs-number"> 11 </span>&gt;= desiredTotal），从而取得胜利.<br>同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">maxChoosableInteger</span> = <span class="hljs-number">10</span>, <span class="hljs-attr">desiredTotal</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">maxChoosableInteger</span> = <span class="hljs-number">10</span>, <span class="hljs-attr">desiredTotal</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= maxChoosableInteger &lt;= <span class="hljs-number">20</span><br><span class="hljs-symbol">0 </span>&lt;= desiredTotal &lt;= <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><h2 id="递归-TLE"><a href="#递归-TLE" class="headerlink" title="递归 (TLE)"></a>递归 (TLE)</h2><p>最无脑的做法是直接递归, 用一个 <code>List</code> 来模拟选数的情况，每次选走一个数时 <code>remove</code> 掉对应元素即可，但同时因为要找到最优决策，所以不能改变原集合，只能改变拷贝的 <code>List</code>（如果直接对原集合 <code>remove</code> ，递归结束后不好还原，重新 <code>add</code> 会添加到集合末尾，那整个 for 循环遍历集合就不正确了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canIWin</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> dest)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(IntStream.rangeClosed(<span class="hljs-number">1</span>, n).boxed().collect(Collectors.toList()), dest);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; list, <span class="hljs-type">int</span> dest)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-keyword">if</span>(item &gt;= dest)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            List&lt;Integer&gt; copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list);<br>            copy.remove(i);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> dfs(copy, dest - item);<br>            <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="状态压缩-记忆化搜索"><a href="#状态压缩-记忆化搜索" class="headerlink" title="状态压缩 + 记忆化搜索"></a>状态压缩 + 记忆化搜索</h2><p>上面方案有问题的地方在于直接使用了 <code>List</code> 模拟选数过程，而整个递归过程是存在很多重复计算的，使用 <code>List</code> 无法进行记忆化搜索。</p><p>所以容易发现从一开始使用 <code>List</code> 就是一个 <strong>错误的思路</strong> 。</p><p>由于 n 数据范围为 20，且每个数只能被选择一次，所以我们可以 <strong>用一个 int (32位)</strong> 来表示选数的情况（<code>状态压缩</code>），对应二进制为 1 代表已被选择，否则代表未被选择。这种方案的好处在于很容易就能实现 <code>记忆化搜索</code>，不管是用 <code>int[1 &lt;&lt; 20]</code> 又或者是 <code>Map&lt;Integer, Integer&gt;</code> 。</p><p>整体实现的逻辑还是和上面的版本一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>]; <span class="hljs-comment">// int 的第 n 位为 1 代表 n - 1 被选择</span><br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canIWin</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> dest)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt; dest) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 依题意平手算先出手的玩家输</span><br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, dest) == <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> state, <span class="hljs-type">int</span> dest)</span>&#123;<br>        <span class="hljs-keyword">if</span>(cache[state] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> cache[state];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(((state &gt;&gt; (i - <span class="hljs-number">1</span>)) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">// 玩家不能重复使用整数</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i &gt;= dest)&#123;<br>                <span class="hljs-keyword">return</span> cache[state] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dfs((state | (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>))), dest - i) == -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> cache[state] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cache[state] = -<span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串哈希</title>
    <link href="/2022/11/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <url>/2022/11/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<br><a href="https://oi-wiki.org/string/hash/">OI-WIKI-# 字符串哈希</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247489813&idx=1&sn=7f3bc18ca390d85b17655f7164d8e660">宫水三叶-# 字符串哈希入门</a><br><a href="https://leetcode.cn/problems/repeated-dna-sequences/">Leetcode-187重复的 DNA 序列</a></p></blockquote><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>具体来说，哈希函数最重要的性质可以概括为下面两条：</p><ol><li><p>在 Hash 函数值不一样的时候，两个字符串一定不一样；</p></li><li><p>在 Hash 函数值一样的时候，两个字符串不一定一样（哈希冲突&#x2F;碰撞。但大概率一样，且我们当然希望它们总是一样的）。</p></li></ol><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>我们需要关注的是什么？</p><p>时间复杂度和 Hash 的准确率。</p><p>通常我们采用的是<strong>多项式 Hash</strong>的方法，对于一个长度为 L 的字符串 s 来说，我们可以这样定义多项式 Hash 函数：</p><p><img src="/img/20221001012815.png"></p><p>这种情况下，对于字符串 xyz ，其哈希函数值为 xb^2 + yb + z。</p><p>对于该 Hash 函数的参考实现如下(（效率低下的版本，实际使用时一般不会这么写）)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">233</span>; <br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll; <br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_hash</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span> </span>&#123; <br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123; <br>res = (ll)(res * B + s[i]) % M; <br>&#125; <br><span class="hljs-keyword">return</span> res; <br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">const</span> string&amp; t)</span> </span>&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">get_hash</span>(s) == <span class="hljs-built_in">get_hash</span>(t); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多次询问子串哈希"><a href="#多次询问子串哈希" class="headerlink" title="多次询问子串哈希"></a>多次询问子串哈希</h2><p>单次计算一个字符串的哈希值复杂度是 O(n)，其中 n 为串长，与暴力匹配没有区别，如果需要多次询问一个字符串的子串的哈希值，每次重新计算效率会非常低下。</p><p>一般采取的方法是对整个字符串先 <strong>预处理出每个前缀的哈希值(设该数组为H)</strong> ，将哈希值看成一个 b 进制的数对 m 取模的结果，这样的话可以做到快速求出子串的哈希。</p><p>首先对于F(s[1, i]) ，即原串长度为 i 的前缀（即子串s[1, i]）的哈希值 <strong>(即H[i])</strong> ，按照定义为</p><p><strong>F(s[1, i])  &#x3D; s[1] * b^ (i - 1) + s[2] * b ^ (i - 2) + … + s[i - 1] * b +s[i]</strong> </p><p>现在，我们想要用类似前缀和的方式快速求出子串 s[L, R] 的哈希值即 F(s[L, R])，按照定义哈希值为</p><p><strong>F(s[L, R])  &#x3D; s[L] * b^ (R - L) + s[L + 1] * b ^ (R - L - 1) + … + s[R - 1] * b +s[R]</strong></p><p>对比观察上述两个式子，可以发现 <code>式2</code> 其实可以由 <code>式1</code> 得出，即<br><strong>F(s[L, R])  &#x3D; F(s[1, R]) - F(s[1, L-1]) * b ^ (r - L + 1)</strong> </p><p>那么即字串 S[L, R] 的哈希值等于 H[R] - H[L-1] * B ^ (R - L +1)</p><p>而 B ^ (r - L + 1)  又可以通过 O(n) 的预处理出次方数组，以实现 O(1) 的回答每次询问</p><p>实现，<a href="https://leetcode.cn/problems/repeated-dna-sequences/">Leetcode187</a>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-number">131313</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] POWER = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M]; <span class="hljs-comment">// 次方数组  </span><br>  <br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findRepeatedDnaSequences</span><span class="hljs-params">(String s)</span> &#123;  <br>        <span class="hljs-type">int</span>[] hashTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length() + <span class="hljs-number">1</span>];  <br>        POWER[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++)&#123;  <br>            <span class="hljs-comment">// 预处理前缀哈希数组  </span><br>            hashTable[i] = hashTable[i - <span class="hljs-number">1</span>] * B + s.charAt(i - <span class="hljs-number">1</span>) % M;  <br>            <span class="hljs-comment">// 预处理次方数组</span><br>            POWER[i] = POWER[i - <span class="hljs-number">1</span>] * B;  <br>        &#125;  <br>        Map&lt;Integer, Integer&gt; countMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length() - <span class="hljs-number">10</span> + <span class="hljs-number">1</span>; i++)&#123;  <br>            <span class="hljs-comment">// 子串哈希等于 h(r) - h(l - 1) * b ^ (r - l + 1)            </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hashTable[i + <span class="hljs-number">9</span> + <span class="hljs-number">1</span>] - hashTable[i] * POWER[i + <span class="hljs-number">9</span> - i + <span class="hljs-number">1</span>];  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> countMap.merge(hash, <span class="hljs-number">0</span>, (oldValue, __) -&gt; ++oldValue);  <br>            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">1</span>)&#123;  <br>                ans.add(s.substring(i, i + <span class="hljs-number">10</span>));  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> ans;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collector-and-Stream.reduce()</title>
    <link href="/2022/11/03/Collector-and-Stream.reduce()/"/>
    <url>/2022/11/03/Collector-and-Stream.reduce()/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://leetcode.cn/problems/reformat-phone-number/">删除字符串中的破折号和空字符</a></p><blockquote><p>当然，最简洁的方式是<br>        String s &#x3D; number.replace(“ “, “”).replace(“-“, “”);<br>但这里暂时忽略这种方案，只是为了指出该背景</p></blockquote><p>一种较复杂的方案是使用 Stream，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">justCase</span><span class="hljs-params">(String str)</span>&#123;  <br>    <span class="hljs-keyword">return</span> str.chars()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>)<br>            .collect(Collector.of(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    (__, ___) -&gt; &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;un support parallel stream&quot;</span>);&#125;,<br>                    StringBuilder::toString));  <br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，要将字符数组重新收集成 <code>String</code> 的合理做法应该只有使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">.collect(supplier,  accumulator,  combiner);<br><span class="hljs-comment">// or</span><br>.collect(Collector.of());  <br></code></pre></td></tr></table></figure><p>其余做法例如 <code>mapToObj(String::valueOf).collect(joining)</code> 会频繁创建 String；<br>而 <code>reduce</code> 严格来讲既不是<strong>可变规约</strong>也没有简洁多少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">justCase</span><span class="hljs-params">(String str)</span>&#123;  <br>    <span class="hljs-keyword">return</span>  str.chars().parallel()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>)  <br>            .reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(),  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString();  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实例化-CollectorImpl"><a href="#实例化-CollectorImpl" class="headerlink" title="实例化 CollectorImpl"></a>实例化 CollectorImpl</h2><blockquote><p>这里只对 <code>Collector</code> 做该话题下的简单介绍，详细知识见 javadocs</p></blockquote><p>Collector 接口由四个抽象函数指定，这些函数协同工作以将条目累积到可变结果容器中，并可选择对结果执行最终转换。他们是：</p><ul><li>supplier() ：创建一个新的结果容器</li><li>accumulator() ：将新数据元素合并到结果容器中</li><li>combiner()：将两个结果容器合并为一个（  ）</li><li>finisher() ：对容器执行可选的最终转换</li></ul><p><code>Collector</code> 接口在 JDK 中的实现类位于 <code>Collectors.CollectorImpl</code><br>而实例化  <code>CollectorImpl</code> 有两种途径：</p><ul><li>通过 <code>Collectors</code> 类预定义的例如 <code>Collectors.toList()</code> 等静态工厂方法实例化</li><li>通过 <code>Collector</code> 接口中暴露出的两种 <code>Collector.of</code> 方法实例化：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collector</span>&lt;T, A, R&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T, R&gt; Collector&lt;T, R, R&gt; <span class="hljs-title function_">of</span><br><br><span class="hljs-params">(Supplier&lt;R&gt; supplier,  </span><br><span class="hljs-params">                                          BiConsumer&lt;R, T&gt; accumulator,  </span><br><span class="hljs-params">                                          BinaryOperator&lt;R&gt; combiner,  </span><br><span class="hljs-params">                                          Characteristics... characteristics)</span> <br>                                          <br>                                          &#123;...&#125;<br>                                          <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T, A, R&gt; Collector&lt;T, A, R&gt; <span class="hljs-title function_">of</span><br>    <br><span class="hljs-params">(Supplier&lt;A&gt; supplier,  </span><br><span class="hljs-params">                                             BiConsumer&lt;A, T&gt; accumulator,  </span><br><span class="hljs-params">                                             BinaryOperator&lt;A&gt; combiner,  </span><br><span class="hljs-params">                                             Function&lt;A, R&gt; finisher,  </span><br><span class="hljs-params">                                             Characteristics... characteristics)</span><br><br>                                             &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>可以看到，<code>Collector</code> 接口只提供了两种重载用于实例化 <code>CollectorImpl</code><br>并且这两种重载都必须传入 <code>supplier</code> 、<code>accmulator</code> 以及 <code>combiner</code>，前两个参数很好理解，毕竟 <code>CollectorImpl</code> 不好对此提供默认的实现<br>但是对于组合器  <code>combiner</code>，<strong>由于组合器只有在执行并发规约时会使用到</strong>，也就是说，对于上面场景下的收集器（即不考虑使用并发流的场景），提供一个 <code>combiner</code> 并没有实际意义</p><h2 id="为什么必须提供-combiner"><a href="#为什么必须提供-combiner" class="headerlink" title="为什么必须提供 combiner"></a>为什么必须提供 combiner</h2><p>在<a href="https://stackoverflow.com/questions/24308146/why-is-a-combiner-needed-for-reduce-method-that-converts-type-in-java-8/24316429#24316429">该问题中</a>，发现这种操作在 <code>Scala</code> 中被称为<code>foldLeft</code>。需要注意的是，Java 的库函数中并没有提供等效于 <code>foldLeft</code> 的实现。</p><blockquote><p>在上面的回答中提到：<br>Finally, Java doesn’t provide <code>foldLeft</code> and <code>foldRight</code> operations because they imply a particular ordering of operations that is inherently sequential. This clashes with the design principle stated above of providing APIs that support sequential and parallel operation equally.<br>最后，Java 不提供<code>foldLeft</code>and<code>foldRight</code>操作，因为它们暗示了一种特定的操作顺序，这种顺序本质上是顺序的。这与上述提供同样支持顺序和并行操作的 API 的设计原则相冲突。</p></blockquote><p>虽然该说法有一定说服力，但还是继续搜索了为什么 Java 没有提供 <code>foldLeft</code>，试图继续理解所提到的<code>设计原则</code>。<br>但是结果却找到了<a href="https://bugs.openjdk.org/browse/JDK-8292845">JDK-8292845</a>和<a href="https://bugs.openjdk.org/browse/JDK-8292845">JDK-8292845</a>，但在这两个增强请求中，却没有对相关<code>设计原则</code>进行讨论，而是计划会在将来对此进行实现。</p><p>也许在不久的将来，就会有一种更合理的 folding operations 可以替换上方看似不合理的实现</p><h2 id="reduce-vs-collect"><a href="#reduce-vs-collect" class="headerlink" title="reduce vs collect"></a>reduce vs collect</h2><p>先看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">justCase</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a-b&quot;</span>;  s<br>    Function&lt;String, Stream&lt;Character&gt;&gt; function = str -&gt; str.chars()  <br>            .parallel()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>);  <br>  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(),  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString(); <span class="hljs-comment">// baba  </span><br>  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .collect(Collector.of(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    StringBuilder::append,  <br>                    StringBuilder::toString)); <span class="hljs-comment">// ab</span><br>                    <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .collect(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString(); <span class="hljs-comment">// ab</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现在 <code>parallel stream</code> 下 <code>reduce()</code> 的输出并不符合我们的预期，先查看 <code>reduce()</code> 的方法注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java">...<br> identity值必须是组合器函数的标识。这意味着对于所有u ，<br>     combiner(identity , u) == u<br> 此外， combiner函数必须与accumulator函数兼容；对于所有u和t ，必须满足以下条件：<br>     combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)<br>...<br><br>&lt;U&gt; U <span class="hljs-title function_">reduce</span><span class="hljs-params">(U identity,  BiFunction&lt;U, ? <span class="hljs-built_in">super</span> T, U&gt; accumulator,  BinaryOperator&lt;U&gt; combiner)</span>;<br></code></pre></td></tr></table></figure><p>对这里的约定进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">justCase</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// combiner(identity , u) == u  </span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">identity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(<span class="hljs-string">&#x27;b&#x27;</span>);  <br>BinaryOperator&lt;StringBuilder&gt; combiner = StringBuilder::append;  <br><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply0</span> <span class="hljs-operator">=</span> combiner.apply(identity, u);  <br>log.debug(String.valueOf(apply0.toString().equals(u.toString()))); <span class="hljs-comment">// true  </span><br><br><br><span class="hljs-comment">// combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)  </span><br><span class="hljs-type">Object</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;  <br>BiFunction&lt;StringBuilder, Object, StringBuilder&gt; acc = StringBuilder::append;  <br>  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply1</span> <span class="hljs-operator">=</span> acc.apply(identity, t);  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply2</span> <span class="hljs-operator">=</span> combiner.apply(u, apply1);  <br>  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply3</span> <span class="hljs-operator">=</span> acc.apply(u, t);  <br><br>log.debug(String.valueOf(apply2.toString().equals(apply3.toString()))); <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现我们的用例其实是符合 <code>reduce()</code> 方法在 javadocs 中的约定的，于是继续查看相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 使用提供的标识、累积和组合函数对该流的元素执行 归约 </span><br>reduce(U identity, BiFunction&lt;U,? <span class="hljs-built_in">super</span> T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)<br><br><span class="hljs-comment">// 对此流的元素执行 可变归约 操作</span><br>collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? <span class="hljs-built_in">super</span> T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)<br></code></pre></td></tr></table></figure><p>会发现这其实是因为 <code>reduce()</code> 只是 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#ReductionOperations">Reduction operations</a> 导致的（而 <code>StringBuilder</code> 是可变对象），在该场景下应该使用  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#MutableReduction">Mutable reduction(可变规约)</a> ，也就是 <code>collect()</code></p><p>实际上仔细查看代码会发现 <code>reduce</code> 和 <code>collect</code> 的累加器 <code>accumulator</code> 定义也并不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// Reduction operations 在累加器中返回处理结果，处理结果的类型不能是可变的</span><br>reduce(... BiFunction&lt;U, ? <span class="hljs-built_in">super</span> T, U&gt; accumulator...)<br><span class="hljs-comment">// Mutable reduction(可变规约) 在累加器中不返回处理结果而是通过修改可变容器本身</span><br>collect(...BiConsumer&lt;R, ? <span class="hljs-built_in">super</span> T&gt; accumulator...) <br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#MutableReduction">Mutable reduction(可变规约)</a></p><p><a href="https://stackoverflow.com/questions/56023452/how-does-reduce-method-work-with-parallel-streams-in-java-8">how-does-reduce-method-work-with-parallel-streams-in-java-8</a></p><blockquote><p>The problem lies in you using Stream::reduce for mutable reduction.<br>You should instead use Stream::collect</p></blockquote><p><a href="https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce/38728166#38728166">java-8-streams-collect-vs-reduce</a></p><blockquote><p>The reason is simply that:</p><ul><li>collect() can only work with mutable result objects.</li><li>reduce() is designed to work with immutable result objects.</li></ul></blockquote><p><a href="https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce/22577274#22577274">java-8-streams-collect-vs-reduce</a></p><blockquote><p>reduce是一个“折叠”操作，它将二元运算符应用于流中的每个元素，其中运算符的第一个参数是前一个应用程序的返回值，第二个参数是当前流元素。<br>collect是一种聚合操作，其中创建“集合”并将每个元素“添加”到该集合中。然后将流中不同部分的集合添加到一起。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
