<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Collector-and-Stream.reduce()</title>
    <link href="/2022/11/03/Collector-and-Stream.reduce()/"/>
    <url>/2022/11/03/Collector-and-Stream.reduce()/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://leetcode.cn/problems/reformat-phone-number/">删除字符串中的破折号和空字符</a></p><blockquote><p>当然，最简洁的方式是<br>        String s &#x3D; number.replace(“ “, “”).replace(“-“, “”);<br>但这里暂时忽略这种方案，只是为了指出该背景</p></blockquote><p>一种较复杂的方案是使用 Stream，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">justCase</span><span class="hljs-params">(String str)</span>&#123;  <br>    <span class="hljs-keyword">return</span> str.chars()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>)<br>            .collect(Collector.of(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    (__, ___) -&gt; &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;un support parallel stream&quot;</span>);&#125;,<br>                    StringBuilder::toString));  <br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，要将字符数组重新收集成 <code>String</code> 的合理做法应该只有使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">.collect(supplier,  accumulator,  combiner);<br><span class="hljs-comment">// or</span><br>.collect(Collector.of());  <br></code></pre></td></tr></table></figure><p>其余做法例如 <code>mapToObj(String::valueOf).collect(joining)</code> 会频繁创建 String；<br>而 <code>reduce</code> 严格来讲既不是<strong>可变规约</strong>也没有简洁多少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">justCase</span><span class="hljs-params">(String str)</span>&#123;  <br>    <span class="hljs-keyword">return</span>  str.chars().parallel()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>)  <br>            .reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(),  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString();  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实例化-CollectorImpl"><a href="#实例化-CollectorImpl" class="headerlink" title="实例化 CollectorImpl"></a>实例化 CollectorImpl</h2><blockquote><p>这里只对 <code>Collector</code> 做该话题下的简单介绍，详细知识见 javadocs</p></blockquote><p>Collector 接口由四个抽象函数指定，这些函数协同工作以将条目累积到可变结果容器中，并可选择对结果执行最终转换。他们是：</p><ul><li>supplier() ：创建一个新的结果容器</li><li>accumulator() ：将新数据元素合并到结果容器中</li><li>combiner()：将两个结果容器合并为一个（  ）</li><li>finisher() ：对容器执行可选的最终转换</li></ul><p><code>Collector</code> 接口在 JDK 中的实现类位于 <code>Collectors.CollectorImpl</code><br>而实例化  <code>CollectorImpl</code> 有两种途径：</p><ul><li>通过 <code>Collectors</code> 类预定义的例如 <code>Collectors.toList()</code> 等静态工厂方法实例化</li><li>通过 <code>Collector</code> 接口中暴露出的两种 <code>Collector.of</code> 方法实例化：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collector</span>&lt;T, A, R&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T, R&gt; Collector&lt;T, R, R&gt; <span class="hljs-title function_">of</span><br><br><span class="hljs-params">(Supplier&lt;R&gt; supplier,  </span><br><span class="hljs-params">                                          BiConsumer&lt;R, T&gt; accumulator,  </span><br><span class="hljs-params">                                          BinaryOperator&lt;R&gt; combiner,  </span><br><span class="hljs-params">                                          Characteristics... characteristics)</span> <br>                                          <br>                                          &#123;...&#125;<br>                                          <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T, A, R&gt; Collector&lt;T, A, R&gt; <span class="hljs-title function_">of</span><br>    <br><span class="hljs-params">(Supplier&lt;A&gt; supplier,  </span><br><span class="hljs-params">                                             BiConsumer&lt;A, T&gt; accumulator,  </span><br><span class="hljs-params">                                             BinaryOperator&lt;A&gt; combiner,  </span><br><span class="hljs-params">                                             Function&lt;A, R&gt; finisher,  </span><br><span class="hljs-params">                                             Characteristics... characteristics)</span><br><br>                                             &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>可以看到，<code>Collector</code> 接口只提供了两种重载用于实例化 <code>CollectorImpl</code><br>并且这两种重载都必须传入 <code>supplier</code> 、<code>accmulator</code> 以及 <code>combiner</code>，前两个参数很好理解，毕竟 <code>CollectorImpl</code> 不好对此提供默认的实现<br>但是对于组合器  <code>combiner</code>，<strong>由于组合器只有在执行并发规约时会使用到</strong>，也就是说，对于上面场景下的收集器（即不考虑使用并发流的场景），提供一个 <code>combiner</code> 并没有实际意义</p><h2 id="为什么必须提供-combiner"><a href="#为什么必须提供-combiner" class="headerlink" title="为什么必须提供 combiner"></a>为什么必须提供 combiner</h2><p>在<a href="https://stackoverflow.com/questions/24308146/why-is-a-combiner-needed-for-reduce-method-that-converts-type-in-java-8/24316429#24316429">该问题中</a>，发现这种操作在 <code>Scala</code> 中被称为<code>foldLeft</code>。需要注意的是，Java 的库函数中并没有提供等效于 <code>foldLeft</code> 的实现。</p><blockquote><p>在上面的回答中提到：<br>Finally, Java doesn’t provide <code>foldLeft</code> and <code>foldRight</code> operations because they imply a particular ordering of operations that is inherently sequential. This clashes with the design principle stated above of providing APIs that support sequential and parallel operation equally.<br>最后，Java 不提供<code>foldLeft</code>and<code>foldRight</code>操作，因为它们暗示了一种特定的操作顺序，这种顺序本质上是顺序的。这与上述提供同样支持顺序和并行操作的 API 的设计原则相冲突。</p></blockquote><p>虽然该说法有一定说服力，但还是继续搜索了为什么 Java 没有提供 <code>foldLeft</code>，试图继续理解所提到的<code>设计原则</code>。<br>但是结果却找到了<a href="https://bugs.openjdk.org/browse/JDK-8292845">JDK-8292845</a>和<a href="https://bugs.openjdk.org/browse/JDK-8292845">JDK-8292845</a>，但在这两个增强请求中，却没有对相关<code>设计原则</code>进行讨论，而是计划会在将来对此进行实现。</p><p>也许在不久的将来，就会有一种更合理的 folding operations 可以替换上方看似不合理的实现</p><h2 id="reduce-vs-collect"><a href="#reduce-vs-collect" class="headerlink" title="reduce vs collect"></a>reduce vs collect</h2><p>先看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">justCase</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a-b&quot;</span>;  s<br>    Function&lt;String, Stream&lt;Character&gt;&gt; function = str -&gt; str.chars()  <br>            .parallel()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>);  <br>  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(),  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString(); <span class="hljs-comment">// baba  </span><br>  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .collect(Collector.of(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    StringBuilder::append,  <br>                    StringBuilder::toString)); <span class="hljs-comment">// ab</span><br>                    <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .collect(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString(); <span class="hljs-comment">// ab</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现在 <code>parallel stream</code> 下 <code>reduce()</code> 的输出并不符合我们的预期，先查看 <code>reduce()</code> 的方法注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java">...<br> identity值必须是组合器函数的标识。这意味着对于所有u ，<br>     combiner(identity , u) == u<br> 此外， combiner函数必须与accumulator函数兼容；对于所有u和t ，必须满足以下条件：<br>     combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)<br>...<br><br>&lt;U&gt; U <span class="hljs-title function_">reduce</span><span class="hljs-params">(U identity,  BiFunction&lt;U, ? <span class="hljs-built_in">super</span> T, U&gt; accumulator,  BinaryOperator&lt;U&gt; combiner)</span>;<br></code></pre></td></tr></table></figure><p>对这里的约定进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">justCase</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// combiner(identity , u) == u  </span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">identity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(<span class="hljs-string">&#x27;b&#x27;</span>);  <br>BinaryOperator&lt;StringBuilder&gt; combiner = StringBuilder::append;  <br><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply0</span> <span class="hljs-operator">=</span> combiner.apply(identity, u);  <br>log.debug(String.valueOf(apply0.toString().equals(u.toString()))); <span class="hljs-comment">// true  </span><br><br><br><span class="hljs-comment">// combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)  </span><br><span class="hljs-type">Object</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;  <br>BiFunction&lt;StringBuilder, Object, StringBuilder&gt; acc = StringBuilder::append;  <br>  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply1</span> <span class="hljs-operator">=</span> acc.apply(identity, t);  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply2</span> <span class="hljs-operator">=</span> combiner.apply(u, apply1);  <br>  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply3</span> <span class="hljs-operator">=</span> acc.apply(u, t);  <br><br>log.debug(String.valueOf(apply2.toString().equals(apply3.toString()))); <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现我们的用例其实是符合 <code>reduce()</code> 方法在 javadocs 中的约定的，于是继续查看相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 使用提供的标识、累积和组合函数对该流的元素执行 归约 </span><br>reduce(U identity, BiFunction&lt;U,? <span class="hljs-built_in">super</span> T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)<br><br><span class="hljs-comment">// 对此流的元素执行 可变归约 操作</span><br>collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? <span class="hljs-built_in">super</span> T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)<br></code></pre></td></tr></table></figure><p>会发现这其实是因为 <code>reduce()</code> 只是 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#ReductionOperations">Reduction operations</a> 导致的（而 <code>StringBuilder</code> 是可变对象），在该场景下应该使用  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#MutableReduction">Mutable reduction(可变规约)</a> ，也就是 <code>collect()</code></p><p>实际上仔细查看代码会发现 <code>reduce</code> 和 <code>collect</code> 的累加器 <code>accumulator</code> 定义也并不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// Reduction operations 在累加器中返回处理结果，处理结果的类型不能是可变的</span><br>reduce(... BiFunction&lt;U, ? <span class="hljs-built_in">super</span> T, U&gt; accumulator...)<br><span class="hljs-comment">// Mutable reduction(可变规约) 在累加器中不返回处理结果而是通过修改可变容器本身</span><br>collect(...BiConsumer&lt;R, ? <span class="hljs-built_in">super</span> T&gt; accumulator...) <br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#MutableReduction">Mutable reduction(可变规约)</a></p><p><a href="https://stackoverflow.com/questions/56023452/how-does-reduce-method-work-with-parallel-streams-in-java-8">how-does-reduce-method-work-with-parallel-streams-in-java-8</a></p><blockquote><p>The problem lies in you using Stream::reduce for mutable reduction.<br>You should instead use Stream::collect</p></blockquote><p><a href="https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce/38728166#38728166">java-8-streams-collect-vs-reduce</a></p><blockquote><p>The reason is simply that:</p><ul><li>collect() can only work with mutable result objects.</li><li>reduce() is designed to work with immutable result objects.</li></ul></blockquote><p><a href="https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce/22577274#22577274">java-8-streams-collect-vs-reduce</a></p><blockquote><p>reduce是一个“折叠”操作，它将二元运算符应用于流中的每个元素，其中运算符的第一个参数是前一个应用程序的返回值，第二个参数是当前流元素。<br>collect是一种聚合操作，其中创建“集合”并将每个元素“添加”到该集合中。然后将流中不同部分的集合添加到一起。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
