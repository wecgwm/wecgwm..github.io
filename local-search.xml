<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LC-6244.完美分割的方案数</title>
    <link href="/2022/11/21/LC-6244-%E5%AE%8C%E7%BE%8E%E5%88%86%E5%89%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/"/>
    <url>/2022/11/21/LC-6244-%E5%AE%8C%E7%BE%8E%E5%88%86%E5%89%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/number-of-beautiful-partitions/">leetcode 困难题</a></p><p>给你一个字符串 s ，每个字符是数字 ‘1’ 到 ‘9’ ，再给你两个整数 k 和 minLength 。</p><p>如果对 s 的分割满足以下条件，那么我们认为它是一个 完美 分割：</p><ul><li>s 被分成 k 段互不相交的子字符串。</li><li>每个子字符串长度都 至少 为 minLength 。</li><li>每个子字符串的第一个字符都是一个 质数 数字，最后一个字符都是一个 非质数 数字。质数数字为 ‘2’ ，’3’ ，’5’ 和 ‘7’ ，剩下的都是非质数数字。<br>请你返回 s 的 完美 分割数目。由于答案可能很大，请返回答案对 109 + 7 取余 后的结果。</li></ul><p>一个 子字符串 是字符串中一段连续字符串序列。</p><p>示例1：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">输入：s = <span class="hljs-string">&quot;23542185131&quot;</span>, k = <span class="hljs-number">3</span>, <span class="hljs-keyword">min</span>Length = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：存在 <span class="hljs-number">3</span> 种完美分割方案：<br><span class="hljs-string">&quot;2354 | 218 | 5131&quot;</span><br><span class="hljs-string">&quot;2354 | 21851 | 31&quot;</span><br><span class="hljs-string">&quot;2354218 | 51 | 31&quot;</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> &lt;= k, minLength &lt;= s.length &lt;= <span class="hljs-number">1000</span><br><span class="hljs-attribute">s</span> 每个字符都为数字 &#x27;<span class="hljs-number">1</span>&#x27; 到 &#x27;<span class="hljs-number">9</span>&#x27; 之一。<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>定义 $f(i, j)$ 表示字符串 $S[0..(j -1)]$ 分割 $i$ 份时的满足题目要求的方案数。</p><p>所以 $j$ 如果为一个合法的分割点，需满足 $j$ 为非质数，且 $j - 0 &gt;&#x3D; minLength - 1$。</p><p>而对于 $f(i, j)$ 的求解，我们通过可以枚举上一个分割点来得出，定义其为 $j’$，需满足 $j’$ 为非质数，$j’ + 1$ 为质数，$j - j’ &gt;&#x3D; minLength$。</p><p>那么就可以得到 $f(i, j)$ 为所有符合要求的 $f(i - 1, j’)$ 的总和。</p><p>定义 $f(0,0)$ 为 $1$ ，即空串的 $0$ 个分割算作一种方案，$f(k, n)$ 为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;Character&gt; P = Set.of(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span>  (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">beautifulPartitions</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> minLength)</span> &#123;     <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; k + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> minLength - <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(isP(s.charAt(j)))&#123; <span class="hljs-comment">// j 不是合法的分割点</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 累加符合要求的 j&#x27;，也就是这里的 q</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; q &lt;= j - minLength; q++)&#123; <span class="hljs-comment">// 需要注意这里 j&#x27; 可以为-1，因为 dp 的第二维度能取到 0</span><br>                    <span class="hljs-keyword">if</span>((q == - <span class="hljs-number">1</span> || !isP(s.charAt(q))) &amp;&amp; isP(s.charAt(q + <span class="hljs-number">1</span>)))&#123;<br>                        sum = (sum + dp[i - <span class="hljs-number">1</span>][q + <span class="hljs-number">1</span>]) % MOD;<br>                    &#125;<br>                &#125;<br>                dp[i][j + <span class="hljs-number">1</span>] = sum; <span class="hljs-comment">// 这里是 j + 1。因为 dp[0][0] 为空串分割 0 段</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[k][n];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isP</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span>&#123;<br>        <span class="hljs-keyword">return</span> P.contains(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会发现上面代码的时间复杂度为 $O(N^3)$，会 TLE ，需要进行优化。</p><p>可以发现对于同一个 $i$ 的不同 $j$ ，许多 $j’$ 的枚举是重复的。</p><p>所以可以同时进行 $j$ 和 $j’$ 的枚举，并且利用类似前缀和的思路，记录对于同一个 $i$ 不同 $j’$ 的总和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;Character&gt; P = Set.of(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span>  (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">beautifulPartitions</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> minLength)</span> &#123;     <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; k + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> minLength - <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> j - minLength;<br>                <span class="hljs-keyword">if</span>((q == - <span class="hljs-number">1</span> || !isP(s.charAt(q))) &amp;&amp; isP(s.charAt(q + <span class="hljs-number">1</span>)))&#123;<br>                    sum = (sum + dp[i - <span class="hljs-number">1</span>][q + <span class="hljs-number">1</span>]) % MOD;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(isP(s.charAt(j)))&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i][j + <span class="hljs-number">1</span>] = sum;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[k][n];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isP</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span>&#123;<br>        <span class="hljs-keyword">return</span> P.contains(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-808.分汤</title>
    <link href="/2022/11/21/LC-808-%E5%88%86%E6%B1%A4/"/>
    <url>/2022/11/21/LC-808-%E5%88%86%E6%B1%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/soup-servings/solution/fen-tang-by-leetcode-solution-0yxs/">leetcode 中等题</a></p><p>有 A 和 B 两种类型 的汤。一开始每种类型的汤有 n 毫升。有四种分配操作：</p><ul><li>提供 100ml 的 汤A 和 0ml 的 汤B 。</li><li>提供 75ml 的 汤A 和 25ml 的 汤B 。</li><li>提供 50ml 的 汤A 和 50ml 的 汤B 。</li><li>提供 25ml 的 汤A 和 75ml 的 汤B 。</li></ul><p>当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。</p><p>注意 不存在先分配 100 ml 汤B 的操作。</p><p>需要返回的值： 汤A 先分配完的概率 +  汤A和汤B 同时分配完的概率 &#x2F; 2。返回值在正确答案 $10^{-5}$ 的范围内将被认为是正确的。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: n = <span class="hljs-number">50</span><br>输出: <span class="hljs-number">0.62500</span><br>解释:如果我们选择前两个操作，<span class="hljs-keyword">A</span> 首先将变为空。<br>对于第三个操作，<span class="hljs-keyword">A</span> 和 B 会同时变为空。<br>对于第四个操作，B 首先将变为空。<br>所以 <span class="hljs-keyword">A</span> 变为空的总概率加上 <span class="hljs-keyword">A</span> 和 B 同时变为空的概率的一半是 <span class="hljs-number">0</span>.<span class="hljs-number">25</span> *(<span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">5</span> + <span class="hljs-number">0</span>)= <span class="hljs-number">0</span>.<span class="hljs-number">625</span>。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= n &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span>​​​​​​​<br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在该题的两个解法中，不论是自顶向下的记忆化搜索还是自底向上的动态规划，时间复杂度都是 $O(n^2)$，即使是将 $n$ 除以 $25$ （后面有解释），在该题的数据规模下仍然会 TLE。</p><p>我们可以发现，随着分配次数的增加，汤 A 比汤 B 先分配完的概率或者答案也是增大的。事实上，当 $n &gt;&#x3D; 4475$ 后，这个答案和 $1$ 的误差就已经小于题目容忍的误差了。所以当 $n &lt; 4475$ 时，我们可以通过记忆化搜索或者动态规模得出答案，否则直接返回 $1$ 即可。</p><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>首先，由于数据规模较大以及四种分配操作都是 $25$ 的倍数，因此我们可以将 $n$ 除以 $25$（向上取整），并将四种分配操作变为 $(4, 0),(3, 1),(2, 2),(1, 3)$，且每种操作的概率均为 $0.25$。</p><p>递归求解，当要分给 $A$ 和 $B$ 的汤均小于等于 $0$ 时，依题意返回 $0.5$，当仅 $A$ 小于等于 $0$ 时依题意返回 $1$，仅 $B$ 小于等于 $0$ 时返回 $0$，其他情况递归求解四种情况下的平均值即可。</p><p>同时为了避免重复递归，使用 $cache[i][j]$ 保存 $A$ 剩余 $i$，$B$ 剩余 $j$ 时的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">double</span>[][] cache;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">soupServings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        n= (<span class="hljs-type">int</span>)Math.ceil((<span class="hljs-type">double</span>)n / <span class="hljs-number">25</span>);<br>        <span class="hljs-keyword">if</span>(n &gt;= <span class="hljs-number">179</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(n, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">if</span>(a &lt;= <span class="hljs-number">0</span> &amp;&amp; b &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(b &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cache[a][b] == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> dfs(a - <span class="hljs-number">4</span>, b);<br>            <span class="hljs-type">double</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> dfs(a - <span class="hljs-number">3</span>, b - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">double</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> dfs(a - <span class="hljs-number">2</span>, b - <span class="hljs-number">2</span>);<br>            <span class="hljs-type">double</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dfs(a - <span class="hljs-number">1</span>, b - <span class="hljs-number">3</span>);<br>            cache[a][b] = <span class="hljs-number">0.25</span> * (q + w + e + r);<br>        &#125;<br>        <span class="hljs-keyword">return</span> cache[a][b];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>类似记忆化搜索的思路，可以转成动态规划求解。</p><p>定义 $dp(i, j)$ 表示 $A$ 剩余 $i$ 、 $B$ 剩余 $j$ 时的解，边界情况如同上面所解释的，非边界情况下转移方程为：</p><p>$$<br>\begin{align}<br>&amp;dp(i, j) &#x3D; \frac{1}{4} \times (dp(i - 4, j) + dp(i - 3, j - 1) + dp(i - 2, j - 2) + dp(i - 1, j - 3))\\<br>\end{align}<br>$$</p><p>需要注意的是在这道题中与记忆化搜索相比动态规划会多出一些无效状态的计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">soupServings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        n = (n + <span class="hljs-number">25</span> - <span class="hljs-number">1</span>) / <span class="hljs-number">25</span>; <span class="hljs-comment">// 向上取整</span><br>        <span class="hljs-keyword">if</span>(n &gt;= <span class="hljs-number">179</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">double</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0.5</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n + <span class="hljs-number">1</span>; j++)&#123;<br>                dp[i][j] += dp[Math.max(<span class="hljs-number">0</span>, i - <span class="hljs-number">4</span>)][j] / <span class="hljs-number">4</span>;<br>                dp[i][j] += dp[Math.max(<span class="hljs-number">0</span>, i - <span class="hljs-number">3</span>)][j - <span class="hljs-number">1</span>] / <span class="hljs-number">4</span>;<br>                dp[i][j] += dp[Math.max(<span class="hljs-number">0</span>, i - <span class="hljs-number">2</span>)][Math.max(<span class="hljs-number">0</span>, j - <span class="hljs-number">2</span>)] / <span class="hljs-number">4</span>;<br>                dp[i][j] += dp[i - <span class="hljs-number">1</span>][Math.max(<span class="hljs-number">0</span>, j - <span class="hljs-number">3</span>)] / <span class="hljs-number">4</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6243.到达首都的最少油耗</title>
    <link href="/2022/11/20/LC-6243-%E5%88%B0%E8%BE%BE%E9%A6%96%E9%83%BD%E7%9A%84%E6%9C%80%E5%B0%91%E6%B2%B9%E8%80%97/"/>
    <url>/2022/11/20/LC-6243-%E5%88%B0%E8%BE%BE%E9%A6%96%E9%83%BD%E7%9A%84%E6%9C%80%E5%B0%91%E6%B2%B9%E8%80%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/">leetcode 中等题</a></p><p>给你一棵 n 个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从 0 到 n - 1 ，且恰好有 n - 1 条路。0 是首都。给你一个二维整数数组 roads ，其中 roads[i] &#x3D; [ai, bi] ，表示城市 ai 和 bi 之间有一条 双向路 。</p><p>每个城市里有一个代表，他们都要去首都参加一个会议。</p><p>每座城市里有一辆车。给你一个整数 seats 表示每辆车里面座位的数目。</p><p>城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。</p><p>请你返回到达首都最少需要多少升汽油。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：roads = [[0,1],[0,2],[0,3]], seats = 5<br>输出：3<br>解释：<br>- 代表<span class="hljs-number"> 1 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 2 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 3 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>最少消耗<span class="hljs-number"> 3 </span>升汽油。<br></code></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2<br>输出：7<br>解释：<br>- 代表<span class="hljs-number"> 2 </span>到达城市<span class="hljs-number"> 3 </span>，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 2 </span>和代表<span class="hljs-number"> 3 </span>一起到达城市<span class="hljs-number"> 1 </span>，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 2 </span>和代表<span class="hljs-number"> 3 </span>一起到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 1 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 5 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 6 </span>到达城市<span class="hljs-number"> 4 </span>，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 4 </span>和代表<span class="hljs-number"> 6 </span>一起到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>最少消耗<span class="hljs-number"> 7 </span>升汽油。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：roads </span>=<span class="hljs-string"> [], seats = 1</span><br><span class="hljs-string">输出：0</span><br><span class="hljs-string">解释：没有代表需要从别的城市到达首都。</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> &lt;= n &lt;= <span class="hljs-number">105</span><br><span class="hljs-attribute">roads</span>.length == n - <span class="hljs-number">1</span><br><span class="hljs-attribute">roads</span>[i].length == <span class="hljs-number">2</span><br><span class="hljs-attribute">0</span> &lt;= ai, bi &lt; n<br><span class="hljs-attribute">ai</span> != bi<br><span class="hljs-attribute">roads</span> 表示一棵合法的树。<br><span class="hljs-attribute">1</span> &lt;= seats &lt;= <span class="hljs-number">105</span><br></code></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>车辆可以视为无限的，要使消耗的油最少，可以递归的判断对于每个子节点，汇集到该节点的人一共有多少，那么也就是该节点的子节点数量 $count$，<strong>并且每次都可以取汇集到该节点的所有人到下一个节点最少需要花费的油量</strong> $ceil(\frac{count}{seats})$ 视为该节点的贡献，最后累加所有节点的贡献就为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt;[] g;<br>    <span class="hljs-type">int</span> seats;<br>    <span class="hljs-type">long</span> ans;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumFuelCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] roads, <span class="hljs-type">int</span> seats)</span> &#123;<br>        <span class="hljs-keyword">if</span>(roads.length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.seats = seats;<br>        g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[roads.length + <span class="hljs-number">1</span>];<br>        IntStream.range(<span class="hljs-number">0</span>, roads.length + <span class="hljs-number">1</span>).forEach(i -&gt; g[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] road : roads)&#123;<br>            g[road[<span class="hljs-number">0</span>]].add(road[<span class="hljs-number">1</span>]);<br>            g[road[<span class="hljs-number">1</span>]].add(road[<span class="hljs-number">0</span>]);<br>        &#125;<br>        dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> father)</span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> item : g[p])&#123;<br>            <span class="hljs-keyword">if</span>(item == father)&#123; <span class="hljs-comment">// 题目给的双向边，避免死循环重复遍历</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            size += dfs(item, p);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 0节点不需要计算，所有人都到达了</span><br>            ans += Math.ceil((<span class="hljs-type">double</span>)size / seats); <span class="hljs-comment">// 向上取整等价于 （size + seats - 1) / seats</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>dfs</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-799.香槟塔</title>
    <link href="/2022/11/20/LC-799-%E9%A6%99%E6%A7%9F%E5%A1%94/"/>
    <url>/2022/11/20/LC-799-%E9%A6%99%E6%A7%9F%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/champagne-tower/">leetcode 中等题</a></p><p>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。</p><p><img src="/../img/Snipaste_2022-11-20_20-06-33.png" alt="leetcode"></p><p>现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（ i 和 j 都从0开始）。</p><p>示例1：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">示例 1</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0.00000</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span> <span class="hljs-string">我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入: <span class="hljs-built_in">poured</span>(倾倒香槟总杯数) = <span class="hljs-number">2</span>, <span class="hljs-built_in">query_glass</span>(杯子的位置数) = <span class="hljs-number">1</span>, <span class="hljs-built_in">query_row</span>(行数) = <span class="hljs-number">1</span><br>输出: <span class="hljs-number">0.50000</span><br>解释: 我们在顶层（下标是（<span class="hljs-number">0</span>，<span class="hljs-number">0</span>）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（<span class="hljs-number">1</span>，<span class="hljs-number">0</span>）的玻璃杯和（<span class="hljs-number">1</span>，<span class="hljs-number">1</span>）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。<br></code></pre></td></tr></table></figure><p>示例3:</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: poured = <span class="hljs-number">100000009</span>, query_row = <span class="hljs-number">33</span>, query_glass = <span class="hljs-number">17</span><br>输出: <span class="hljs-number">1.00000</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= poured &lt;= <span class="hljs-number">109</span><br><span class="hljs-symbol">0 </span>&lt;= query_glass &lt;= query_row &lt; <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>首先需要知道除了最上层的杯子，其余所有杯子 $[i, j]$ 的香槟均来自上一层的杯子 $[i - 1, j]$ 和 $[i - 1, j + 1]$，并且当该杯子满后（超过$1$），流出的水会等量的流向下一层 $[i + 1, j]$ 和 $[i + 1, j + 1]$。</p><p>dp，定义 $f(i, j)$ 表示流过该层的香槟总量，那么 $f(0, 0)$ 为 $poured$，可以得到</p><p>$$<br>\begin{align}<br>&amp;f(i + 1, j) +&#x3D; \frac{f(i, j) - 1}{2}\\<br>&amp;f(i + 1, j + 1) +&#x3D; \frac{f(i, j) - 1}{2}\\<br>\end{align}<br>$$</p><p>$min(1, f(queryRow, queryGlass))$ 为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">champagneTower</span><span class="hljs-params">(<span class="hljs-type">int</span> poured, <span class="hljs-type">int</span> query_row, <span class="hljs-type">int</span> query_glass)</span> &#123;<br>        <span class="hljs-type">double</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[query_row + <span class="hljs-number">1</span>][query_row + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = poured;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; query_row; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(dp[i][j] &lt;= <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i + <span class="hljs-number">1</span>][j] += (dp[i][j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] += (dp[i][j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(dp[query_row][query_glass], <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，每层的香槟流量，只依赖于上一层，所以可以用滚动数组的方式进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">champagneTower</span><span class="hljs-params">(<span class="hljs-type">int</span> poured, <span class="hljs-type">int</span> query_row, <span class="hljs-type">int</span> query_glass)</span> &#123;<br>        <span class="hljs-type">double</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[query_row + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = poured;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; query_row; i++)&#123;<br>            <span class="hljs-type">double</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[query_row + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(dp[j] &lt;= <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                temp[j] += (dp[j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                temp[j + <span class="hljs-number">1</span>] += (dp[j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            &#125;<br>            dp = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(dp[query_glass], <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6242.二叉搜索树最近节点查询</title>
    <link href="/2022/11/20/LC-6242-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E8%8A%82%E7%82%B9%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/11/20/LC-6242-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E8%8A%82%E7%82%B9%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/">leetcode 中等题</a></p><p>给你一个 二叉搜索树 的根节点 root ，和一个由正整数组成、长度为 n 的数组 queries 。</p><p>请你找出一个长度为 n 的 二维 答案数组 answer ，其中 answer[i] &#x3D; [mini, maxi] ：</p><p>mini 是树中小于等于 queries[i] 的 最大值 。如果不存在这样的值，则使用 -1 代替。<br>maxi 是树中大于等于 queries[i] 的 最小值 。如果不存在这样的值，则使用 -1 代替。<br>返回数组 answer 。</p><p>示例1：</p><p><img src="/../img/Snipaste_2022-11-20_23-04-47.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]<br>输出：[[2,2],[4,6],[15,-1]]<br>解释：按下面的描述找出并返回查询的答案：<br>- 树中小于等于<span class="hljs-number"> 2 </span>的最大值是<span class="hljs-number"> 2 </span>，且大于等于<span class="hljs-number"> 2 </span>的最小值也是<span class="hljs-number"> 2 </span>。所以第一个查询的答案是 [2,2] 。<br>- 树中小于等于<span class="hljs-number"> 5 </span>的最大值是<span class="hljs-number"> 4 </span>，且大于等于<span class="hljs-number"> 5 </span>的最小值是<span class="hljs-number"> 6 </span>。所以第二个查询的答案是 [4,6] 。<br>- 树中小于等于<span class="hljs-number"> 16 </span>的最大值是<span class="hljs-number"> 15 </span>，且大于等于<span class="hljs-number"> 16 </span>的最小值不存在。所以第三个查询的答案是 [15,-1] 。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">树中节点的数目在范围 <span class="hljs-selector-attr">[2, 105]</span> 内<br><span class="hljs-number">1</span> &lt;= Node<span class="hljs-selector-class">.val</span> &lt;= <span class="hljs-number">106</span><br>n == queries<span class="hljs-selector-class">.length</span><br><span class="hljs-number">1</span> &lt;= n &lt;= <span class="hljs-number">105</span><br><span class="hljs-number">1</span> &lt;= queries<span class="hljs-selector-attr">[i]</span> &lt;= <span class="hljs-number">106</span><br></code></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>需要注意的是题目给的是二叉查找树而不是平衡树，如果直接在树上查找的话，某些数据下树可能会退化成链表导致 TLE。</p><p>中序遍历树得到排序后的数组，再二分查找出 $min_x$ 以及 $max_x$ 即可。</p><p>可以通过两次左闭右开的二分查找分别通过缩小右边界、左边界获得 $min_x$ 和 $max_x$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">closestNodes</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; queries)</span> &#123;<br>        List&lt;Integer&gt; sort = dfs(root, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sort.size();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.size(); i++)&#123;<br>            List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n, target = queries.get(i);<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(sort.get(mid) &lt; target)&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sort.get(mid) &gt;= target)&#123;<br>                    right = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left &lt; n &amp;&amp; sort.get(left) == target)&#123;<br>                cur.add(sort.get(left));<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)&#123;<br>                cur.add(sort.get(left - <span class="hljs-number">1</span>));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.add(-<span class="hljs-number">1</span>);<br>            &#125;<br>            left = <span class="hljs-number">0</span>;<br>            right = n;<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(sort.get(mid) &lt;= target)&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sort.get(mid) &gt; target)&#123;<br>                    right = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; sort.get(left - <span class="hljs-number">1</span>) == target)&#123;<br>                cur.add(sort.get(left - <span class="hljs-number">1</span>));<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left &lt; n)&#123;<br>                cur.add(sort.get(left));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.add(-<span class="hljs-number">1</span>);<br>            &#125;<br>            ans.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; sort)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> sort;<br>        &#125;<br>        dfs(root.left, sort);<br>        sort.add(root.val);<br>        dfs(root.right, sort);<br>        <span class="hljs-keyword">return</span> sort;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然也可以通过缩小右边界一次性得到 $min_x$ 和 $max_x$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">closestNodes</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; queries)</span> &#123;<br>        List&lt;Integer&gt; sort = dfs(root, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sort.size();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.size(); i++)&#123;<br>            List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n, target = queries.get(i);<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(sort.get(mid) &lt; target)&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    right = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left &lt; n &amp;&amp; sort.get(left) == target)&#123;<br>                cur.add(sort.get(left));<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)&#123;<br>                cur.add(sort.get(left - <span class="hljs-number">1</span>));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.add(-<span class="hljs-number">1</span>);<br>            &#125;                       <br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (left &lt; n ? sort.get(left) : -<span class="hljs-number">1</span>);      <br>            cur.add(b);<br>            ans.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; sort)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> sort;<br>        &#125;<br>        dfs(root.left, sort);<br>        sort.add(root.val);<br>        dfs(root.right, sort);<br>        <span class="hljs-keyword">return</span> sort;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缩小左边界一次性得到 $min_x$ 和 $max_x$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 二分查找通过缩小左边界一次性得到 min_x 和 min_y</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">closestNodes</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; queries)</span> &#123;<br>        List&lt;Integer&gt; sort = dfs(root, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sort.size();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.size(); i++)&#123;<br>            List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n, target = queries.get(i);<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(sort.get(mid) &gt; target)&#123;<br>                    right = mid;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> ? sort.get(left - <span class="hljs-number">1</span>) : -<span class="hljs-number">1</span>);<br>            cur.add(a);<br>            <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; sort.get(left - <span class="hljs-number">1</span>) == target)&#123;<br>                cur.add(sort.get(left - <span class="hljs-number">1</span>));<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left &lt; n)&#123;<br>                cur.add(sort.get(left));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.add(-<span class="hljs-number">1</span>);<br>            &#125;<br>            ans.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; sort)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> sort;<br>        &#125;<br>        dfs(root.left, sort);<br>        sort.add(root.val);<br>        dfs(root.right, sort);<br>        <span class="hljs-keyword">return</span> sort;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-792.匹配子序列的单词数</title>
    <link href="/2022/11/18/LC-792-%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
    <url>/2022/11/18/LC-792-%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/number-of-matching-subsequences/">leetcode 中等题</a></p><p>给定字符串 s 和字符串数组 words, 返回  words[i] 中是s的子序列的单词个数 。</p><p>字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。</p><ul><li>例如， “ace” 是 “abcde” 的子序列。</li></ul><p>示例1：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入: s = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>,<span class="hljs-string">&quot;acd&quot;</span>,<span class="hljs-string">&quot;ace&quot;</span>]<br>输出: <span class="hljs-number">3</span><br>解释: 有三个是 s 的子序列的单词: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;acd&quot;</span>, <span class="hljs-string">&quot;ace&quot;</span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入: s = <span class="hljs-string">&quot;dsahjpjauf&quot;</span>, <span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;ahjpjau&quot;</span>,<span class="hljs-string">&quot;ja&quot;</span>,<span class="hljs-string">&quot;ahbwzgqnuk&quot;</span>,<span class="hljs-string">&quot;tnmlanowax&quot;</span>]<br>输出: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1</span> &lt;= s.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">5</span> * <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">words</span>.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">5000</span><br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">words</span>[i].<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">50</span><br><span class="hljs-built_in">words</span>[i]和 s 都只由小写字母组成。<br></code></pre></td></tr></table></figure><h2 id="分桶-二分查找-（贪心）"><a href="#分桶-二分查找-（贪心）" class="headerlink" title="分桶 + 二分查找 （贪心）"></a>分桶 + 二分查找 （贪心）</h2><p>最容易想到的方法就是对于每个 $word$ ，通过双指针的方法和 $s$ 进行匹配，指针 $i$ 和 $j$ 初始时分别指向 $word$ 和 $a$ 的第 $0$ 位字符，如果匹配成功则将两个指针分别向后移动，否则只移动 $j$，如果 $i$ 能匹配结束的话则 $ans$ 加一。</p><p>但是该方法在该题的数据规模下会 TLE，所以需要进行优化。</p><p>一种方法是我们可以将 $s$ 按照每个字符进行分桶，每个桶内存储该字符在 $s$ 内从小到大排列后的索引值。那么对于每个 $word$ 我们都会进行一轮遍历，每一轮都独立维护一个 $next$ 值，并在每次 $i$ 指针后移时，尝试通过二分查找得到当前 $i$ 所指向字符的对应桶内第一个大于 $next$ 的索引值（贪心思路，目的是让每次的 $next$ 都尽量小），然后将 $next$ 更新为该索引值，过程中若不存在大于 $next$ 的索引值则匹配失败，若能匹配结束则 $ans$ 加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numMatchingSubseq</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br>        Map&lt;Character, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            List&lt;Integer&gt; list = map.computeIfAbsent(c, ArrayList::<span class="hljs-keyword">new</span>);<br>            list.add(i);<br>            map.put(c, list);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++)&#123;<br>            <span class="hljs-type">char</span>[] item = words[i].toCharArray();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; item.length; j++)&#123;<br>                List&lt;Integer&gt; list = map.getOrDefault(item[j], <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                <span class="hljs-comment">// 二分查找第一个大于 target 的数</span><br>                <span class="hljs-comment">// 也就是右边界 + 1, 右边界为 left - 1, 右边界 &lt;= target</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = list.size();<br>                <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + right &gt;&gt; <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(list.get(mid) &lt;= next)&#123;<br>                        left = mid + <span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list.get(mid) &gt; next)&#123;<br>                        right = mid;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(left &lt; list.size())&#123;<br>                    next = list.get(left);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似上面的思路，我们也可以对于每个 $word$ 进行逆序遍历，只需要在二分查找时改成找到第一个小于 $i$ 的索引值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numMatchingSubseq</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br>        Map&lt;Character, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            List&lt;Integer&gt; list = map.computeIfAbsent(c, ArrayList::<span class="hljs-keyword">new</span>);<br>            list.add(i);<br>            map.put(c, list);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++)&#123;<br>            <span class="hljs-type">char</span>[] item = words[i].toCharArray();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> item.length - <span class="hljs-number">1</span>; j &gt;=<span class="hljs-number">0</span>; j--)&#123;<br>                List&lt;Integer&gt; list = map.getOrDefault(item[j], <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                <span class="hljs-comment">// 二分查找第一个小于 target 的数</span><br>                <span class="hljs-comment">// 也就是左边界 - 1, 左边界为 left, 左边界 &gt;= target</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = list.size();<br>                <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + right &gt;&gt; <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(list.get(mid) &lt; next)&#123;<br>                        left = mid + <span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list.get(mid) &gt;= next)&#123;<br>                        right = mid;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; left - <span class="hljs-number">1</span> &lt; list.size())&#123;<br>                    next = list.get(left - <span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分桶-多指针"><a href="#分桶-多指针" class="headerlink" title="分桶 + 多指针"></a>分桶 + 多指针</h2><p>上面的做法的思路是对 $s$ 按字符进行分桶，从而加速每一个 $word$ 与 $s$ 之间的匹配速度，相当于每个 $word$ 都会独立匹配一次。</p><p>而另一种做法的思路是将 $s$ 同时与所有 $word$ 进行匹配。具体来说每一个 $word$ 都有着独立的指针 $i$ ，并且初始值为 0，那么对每一个 $word$ 按照当前匹配到的字符，也就是各自 $i$ 指针指向的字符进行分桶。那么我们就可以直接遍历 $s$，每次只需要将 $j$ 所指向字符的对应桶内的所有 $word$ 拿出来并将它们的 $i$ 指针往后移动一位，然后重新维护桶即可，而若当前取出的 $word$ 对应的 $i$ 已经到达结尾，则 $ans$ 加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numMatchingSubseq</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt;[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>            bucket[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; ++i) &#123;<br>            bucket[words[i].charAt(<span class="hljs-number">0</span>) - <span class="hljs-string">&#x27;a&#x27;</span>].offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, <span class="hljs-number">0</span>&#125;);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> bucket[c - <span class="hljs-string">&#x27;a&#x27;</span>].size();<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span>[] item = bucket[c - <span class="hljs-string">&#x27;a&#x27;</span>].poll();<br>                <span class="hljs-keyword">if</span> (item[<span class="hljs-number">1</span>] == words[item[<span class="hljs-number">0</span>]].length() - <span class="hljs-number">1</span>) &#123;<br>                    ++ans;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ++item[<span class="hljs-number">1</span>];<br>                    bucket[words[item[<span class="hljs-number">0</span>]].charAt(item[<span class="hljs-number">1</span>]) - <span class="hljs-string">&#x27;a&#x27;</span>].offer(item);<br>                &#125;<br>                --size;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-891.子序列宽度之和</title>
    <link href="/2022/11/18/LC-891-%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/11/18/LC-891-%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/sum-of-subsequence-widths/">leetcode 困难题</a></p><p>一个序列的 宽度 定义为该序列中<strong>最大元素和最小元素的差值</strong>。</p><p>给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 1e9 + 7 取余 后的结果。</p><p>子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,1,3]</span><br>输出：6<br>解释：子序列为 <span class="hljs-comment">[1]</span>, <span class="hljs-comment">[2]</span>, <span class="hljs-comment">[3]</span>, <span class="hljs-comment">[2,1]</span>, <span class="hljs-comment">[2,3]</span>, <span class="hljs-comment">[1,3]</span>, <span class="hljs-comment">[2,1,3]</span> 。<br>相应的宽度是 0, 0, 0, 1, 1, 2, 2 。<br>宽度之和是 6 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">105</span><br><span class="hljs-symbol">1 </span>&lt;= nums[i] &lt;= <span class="hljs-number">105</span><br></code></pre></td></tr></table></figure><h2 id="考虑每个元素的贡献"><a href="#考虑每个元素的贡献" class="headerlink" title="考虑每个元素的贡献"></a>考虑每个元素的贡献</h2><p>考虑到数据范围，肯定是无法通过求具体的子序列来得到答案的。</p><p>我们可以考虑每个元素对答案的贡献来得到最终的答案。并且由于宽度为序列中最大元素和最小元素的差值，那么也就是说每个元素只有在作为某个序列的最小值或者最大值时，才会在该序列中对答案有贡献。容易想到先对数组进行排序，那么排序后就能可以得到以某个 $nums[i]$ 为最大值的序列一共有 $2^i$ 个，因为左边的每个元素都可以选或者不选，即一共会有 $2 \times 2 \times 2 … \times 2$ 个；同理右边就有 $2 ^{j-i-1}$ 个以 $num[i]$ 作为最小值的序列。</p><p>需要注意的是，根据题意，长度为 1 的序列是没有贡献的，所以 $nums[i]$ 的左边不能全部不选，右边也不能全部不选，也就是说，以 $nums[i]$ 作为最大值或最小值的序列数量均需要分别减一。</p><p>那么就可以得到，每个元素对答案的贡献为 $nums[i] \times (2^i - 1 - (2^{j-i-1} - 1) )$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumSubseqWidths</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span>[] pow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        pow[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            pow[i] = pow[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> % MOD;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            ans = (ans + (nums[i] * (pow[i] - <span class="hljs-number">1</span> - pow[n - i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)))% MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(ans % MOD);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>脑筋急转弯/找规律</tag>
      
      <tag>贡献法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-775.全局倒置与局部倒置</title>
    <link href="/2022/11/16/LC-775-%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/"/>
    <url>/2022/11/16/LC-775-%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/global-and-local-inversions/">leetcode 中等题</a></p><p>给你一个长度为 n 的整数数组 nums ，表示由范围 [0, n - 1] 内所有整数组成的一个排列。</p><p>全局倒置 的数目等于满足下述条件不同下标对 (i, j) 的数目：</p><ul><li>0 &lt;&#x3D; i &lt; j &lt; n</li><li>nums[i] &gt; nums[j]</li></ul><p>局部倒置 的数目等于满足下述条件的下标 i 的数目：</p><ul><li>0 &lt;&#x3D; i &lt; n - 1</li><li>nums[i] &gt; nums[i + 1]</li></ul><p>当数组 nums 中 全局倒置 的数量等于 局部倒置 的数量时，返回 true ；否则，返回 false 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,0,2]<br>输出：true<br>解释：有<span class="hljs-number"> 1 </span>个全局倒置，和<span class="hljs-number"> 1 </span>个局部倒置。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,0]<br>输出：false<br>解释：有<span class="hljs-number"> 2 </span>个全局倒置，和<span class="hljs-number"> 1 </span>个局部倒置。<br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">n</span> == nums.length<br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-number">0</span> &lt;= nums[i] &lt; <span class="hljs-built_in">n</span><br>nums 中的所有整数 互不相同<br>nums 是范围 [<span class="hljs-number">0</span>, <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>] 内所有数字组成的一个排列<br></code></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>这道题最容易且方便的做法是，逆序遍历且维护一个 $[i + 2, n]$ 的最小值，如果当前元素大于该最小值返回 $false$ ，如果顺利遍历结束返回 $true$ 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIdealPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> nums[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">3</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; min)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;         <br>            <span class="hljs-comment">// 判断后再更新 min，相当于维护的是 [i + 2, n] 的最小值 </span><br>            min = Math.min(min, nums[i + <span class="hljs-number">1</span>]); <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>但是对于求 <a href="https://zh.m.wikipedia.org/zh-hans/%E9%80%86%E5%BA%8F%E5%AF%B9">逆序对</a> 更加通用的做法是使用 <a href="https://www.acwing.com/blog/content/80/">树状数组</a>。</p><p>首先我们需要构造一个原数组元素到排名的映射，因为这里的 $0 &lt;&#x3D; nums[i] &lt; n$，所以可以使用数组，更加通用的做法是使用 $Map$。</p><p>构建完映射之后只需要顺序遍历原数组（当然逆序也行，只需要修改下查询的方式），再通过查询树状数组的前缀和，就能够得到前面元素比当前元素排名更大的数量，也就是逆序对的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIdealPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 构造 nums[i] 到 排名 的一个映射，更通用的做法是用 Map&lt;&gt;</span><br>        <span class="hljs-type">int</span>[] sort = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        System.arraycopy(nums, <span class="hljs-number">0</span>, sort, <span class="hljs-number">0</span>, n);<br>        Arrays.sort(sort);<br>        <span class="hljs-type">int</span>[] rank = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            rank[sort[i - <span class="hljs-number">1</span>]] = i;<br>        &#125;<br>        <span class="hljs-comment">// 遍历原数组，统计并更新逆序对数量</span><br>        <span class="hljs-type">FenwickTree</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FenwickTree</span>(nums.length);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">local</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, global = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rank[nums[i]];<br>            global += t.query(n) - t.query(r); <span class="hljs-comment">// 逆序对数量/前缀和/前面元素比当前元素排名大的数量</span><br>            t.update(r, <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 局部倒置</span><br>            <span class="hljs-keyword">if</span>(i != n - <span class="hljs-number">1</span> &amp;&amp; nums[i] &gt; nums[i + <span class="hljs-number">1</span>])&#123;<br>                local += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> local == global;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FenwickTree</span>&#123;<br>        <span class="hljs-type">int</span>[] c;<br><br>        FenwickTree(<span class="hljs-type">int</span> size)&#123;<br>            c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size + <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> updateValue)</span>&#123;<br>            <span class="hljs-keyword">while</span>(index &lt; c.length)&#123;<br>                c[index] += updateValue;<br>                index += lowbit(index);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(index &gt; <span class="hljs-number">0</span>)&#123;<br>                ans += c[index];<br>                index -= lowbit(index); <br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>            <span class="hljs-keyword">return</span> x &amp; -x;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>同样由于这里的 $0 &lt;&#x3D; nums[i] &lt; n$，所以其实可以省去排序的步骤，直接将树状数组的大小初始化为 $n$ 即可。</p><p>另外需要注意的是由于树状数组的第 $0$ 位并不存储元素（因为 $lowbit(0) &#x3D; 0$，存储的话会导致循环条件要特殊处理），但是 $nums[i]$ 是会取到 $0$ 的，所以我们每次加入树状数组时再手动加上 $1$ 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIdealPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">FenwickTree</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FenwickTree</span>(nums.length);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">local</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, global = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> nums[i] + <span class="hljs-number">1</span>;      <br>            global += t.query(n) - t.query(item);<br>            t.update(item, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(i != n - <span class="hljs-number">1</span> &amp;&amp; nums[i] &gt; nums[i + <span class="hljs-number">1</span>])&#123;<br>                local += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> local == global;<br>    &#125;<br>    <span class="hljs-comment">// FenwickTree 代码同上</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-805.数组的均值分割</title>
    <link href="/2022/11/14/LC-805-%E6%95%B0%E7%BB%84%E7%9A%84%E5%9D%87%E5%80%BC%E5%88%86%E5%89%B2/"/>
    <url>/2022/11/14/LC-805-%E6%95%B0%E7%BB%84%E7%9A%84%E5%9D%87%E5%80%BC%E5%88%86%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/split-array-with-same-average/">leetcode 困难题</a></p><p>给定你一个整数数组 nums</p><p>我们要将 nums 数组中的每个元素移动到 A 数组 或者 B 数组中，使得 A 数组和 B 数组不为空，并且 average(A) &#x3D;&#x3D; average(B) 。</p><p>如果可以完成则返回true ， 否则返回 false  。</p><p>注意：对于数组 arr ,  average(arr) 是 arr 的所有元素除以 arr 长度的和。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: nums = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>]<br>输出: true<br>解释: 我们可以将数组分割为 [<span class="hljs-number">1,4,5,8</span>] 和 [<span class="hljs-number">2,3,6,7</span>], 他们的平均值都是<span class="hljs-number">4</span>.<span class="hljs-number">5</span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [3,1]</span><br><span class="hljs-section">输出: false</span><br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">30</span><br><span class="hljs-symbol">0 </span>&lt;= nums[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设我们移动了 $k$ 个元素到数组 $A$ 中，移动了 $k_2$ 或者说 $n-k$ 个元素到数组 $B$ 中，分割后的数组为 $A$ 和 $B$，且${sum}(A)$， ${sum}(B)$， ${sum}(nums)$ 分别表示数组 $A$， $B$， $nums$ 的元素和，由于数组 $A$，$B$ 的平均值相等，可以推出：</p><p>$$<br>\begin{align}<br>&amp;\frac{sum(A)}{k} &#x3D; \frac{sum(B)}{n-k}\\<br>\Leftrightarrow &amp; sum(A) \times n - sum(A) \times k &#x3D; sum(B) \times k\\<br>\Leftrightarrow &amp; sum(A) \times n &#x3D; (sum(B) + sum(A)) \times k\\<br>\Leftrightarrow &amp; sum(A) \times n &#x3D; (sum(nums)) \times k\\<br>\Leftrightarrow &amp; \frac{sum(A)}{k} &#x3D; \frac{sum(nums)}{n}\\<br>\end{align}<br>$$</p><p>也就是说如果存在子数组 $A$，$B$ 的平均值相等，则该平均值必然还会等于 $nums$ 的平均值。</p><p><strong>并且我们只需要求出是否存在一个子数组的平均值等于原数组平均值即可</strong>，因为如果存在一个子数组平均值等于原数组平均值的话：<br>$$<br>\begin{align}<br>&amp;\frac{sum(nums)}{n} &#x3D; \frac{sum(A)}{k}\\<br>\Leftrightarrow &amp; \frac{sum(A) + sum(B)}{k + k_2} &#x3D; \frac{sum(A)}{k}\\<br>\Leftrightarrow &amp; \frac{sum(A) + sum(B)}{k_2} &#x3D; \frac{sum(A) \times (k + k_2)}{k \times k_2}\\<br>\Leftrightarrow &amp; \frac{sum(B)}{k_2} &#x3D; \frac{sum(A) \times (k + k_2) - (sum(A) \times k)}{k \times k_2}\\<br>\Leftrightarrow &amp; \frac{sum(B)}{k_2} &#x3D; \frac{sum(A) \times k_2 }{k \times k_2}\\<br>\Leftrightarrow &amp; \frac{sum(B)}{k_2} &#x3D; \frac{sum(A)}{k}\\<br>\end{align}<br>$$<br>可以得出剩余元素组成的子数组的平均值也为原数组平均值。</p><p>那么问题变成求是否存在子数组平均值等于原数组，容易想到的思路是枚举每个子数组，此时一共有 $2^n$ 种方案（每个元素取或不取），由于题目中 <code>n</code> 最大是 <code>30</code>，会 TLE。</p><p>我们可以使用折半查找的方法，将时间复杂度降低到 $O(2^\frac{n}{2})$。</p><p>我们将数组 $nums$ 分成左右两部分，那么子数组 $A$ 可能存在三种情况：</p><ul><li>子数组 $A$ 完全在数组 $nums$ 的左半部分；</li><li>子数组 $A$ 完全在数组 $nums$ 的右半部分；</li><li>子数组 $A$ 一部分在数组 $nums$ 的左半部分，一部分在数组 $nums$ 的右半部分。</li></ul><p>我们分两次来处理数组，每次处理一部分。<br>如果是前两种情况比较好处理，我们只需要在处理对应部分数组时计算平均值，再与原数组的平均值比较即可。</p><p>但如果是第三种情况，则要等我们在处理右半部分时，回过头来通过某种方式搜索左边是否存在符合我们预期的方案（无法简单的通过在哈希表中保存总和来求，因为还和左边数组取了几个有关系），即会花费额外的时间（可能TLE）又难实现。</p><p>所以我们可以将数组 ${nums}$ 中的每个元素减去 $nums$ 的平均值，这样数组的平均值则变为 <code>0</code>。那么此时题目中的问题则变为：能否从 $nums$ 中找出若干个元素组成集合 $A$，使得 $A$ 的元素之和为 <code>0</code>。</p><p>但是如果直接减去 $\frac{sum(nums)}{n}$ 会引进浮点数，如果在 <code>Java</code> 中直接使用 <code>double</code> 进行运算，会因为浮点数的误差出现WA，所以更好的方案是先将 $nums$ 中的每个元素乘以 $n$ 后再减去数组总和，也就是：<br>$$<br>\begin{align}<br>&amp;nums[i] &#x3D; nums[i] - \frac{sum(nums)}{n}\\<br>\Rightarrow &amp;nums[i] &#x3D; nums[i] \times n - \frac{sum(nums) \times n}{n}\\<br>\end{align}<br>$$<br>这样就不会出现浮点数了。</p><p>这样处理后，如果是第一、二种情况，我们只需要在遍历时判断当前方案总和是否等于 $0$ 即可，如果是就直接返回。对于第三种情况，我们也只需要在遍历左边部分时额外再把当前方案的总和保存到哈希表中，然后在遍历右边部分数组的时候，如果当前总和是 $curSum$ ，判断哈希表是否存在 $-curSum$ 即可。</p><p>另外需要注意的是，我们不能同时选择左右两边的所有元素，这样数组 $B$ 就为空了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">splitArraySameAverage</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, m = nums.length / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            nums[i] = nums[i] * n - sum; <span class="hljs-comment">// 避免浮点数</span><br>        &#125;<br>        Set&lt;Integer&gt; exist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; m); i++)&#123; <span class="hljs-comment">// 2 ^（n/2）个方案</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                <span class="hljs-keyword">if</span>((i &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 当前位为 1 代表当前位被选到了，例如 011 代表该轮只选择第一个和第二个元素</span><br>                    curSum += nums[j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(curSum == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            exist.add(curSum);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m; i &lt; n; i++) &#123;<br>            rSum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; (n - m)); i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>((i &amp; (<span class="hljs-number">1</span> &lt;&lt; (j - m))) != <span class="hljs-number">0</span>)&#123;<br>                    curSum += nums[j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(curSum == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(curSum != rSum &amp;&amp; exist.contains(-curSum))&#123; <span class="hljs-comment">// 第一个判断是因为不能同时选择左右两边的所有元素</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>折半搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6236.不重叠回文子字符串的最大数目</title>
    <link href="/2022/11/13/LC-6236-%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/11/13/LC-6236-%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/">leetcode 困难题</a></p><p>给你一个字符串 s 和一个 正 整数 k 。</p><p>从字符串 s 中选出一组满足下述条件且 不重叠 的子字符串：</p><ul><li>每个子字符串的长度 至少 为 k 。</li><li>每个子字符串是一个 回文串 。<br>返回最优方案中能选择的子字符串的 最大 数目。</li></ul><p>子字符串 是字符串中一个连续的字符序列。</p><p><strong>字符串之间互不重叠，也就是说对于任意两个子字符串 s[i..j] 和 s[x..y] ，要么 j &lt; x 要么 i &gt; y 。</strong></p><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abaccdbbd&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：可以选择 <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abaccdbbd&quot;</span> 中斜体加粗的子字符串。<span class="hljs-string">&quot;aba&quot;</span> 和 <span class="hljs-string">&quot;dbbd&quot;</span> 都是回文，且长度至少为 <span class="hljs-attr">k</span> = <span class="hljs-number">3</span> 。<br>可以证明，无法选出两个以上的有效子字符串。<br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">提示：<br><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> k &lt;<span class="hljs-operator">=</span> s.length &lt;<span class="hljs-operator">=</span> <span class="hljs-number">2000</span><br>s 仅由小写英文字母组成<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>我们可以通过两次动态规划得出结果，其中第一次动态规划处理出某个子串 <code>s(i, j)</code> 是否为回文串，第二次动态规划处理如何划分得到最多的不重叠子字符串。</p><hr><p>第一次 <code>dp</code>，定义 <code>f(i, j)</code> 表示子串 <code>s(i, j)</code> 是否为回文串，那么可以得到转移方程：</p><p><code>f(i, j) = s[i] == s[j]</code>，当 <code>j - i &lt;= 1</code> 时</p><p><code>f(i, j) = f(i + 1, j - 1) &amp;&amp; (s[i] == s[j])</code>，当 <code>j - i &gt; 1</code> 时</p><hr><p>第二次 <code>dp</code>，定义 <code>f(i)</code> 表示 <code>s(0, i)</code> 的最多不重叠回文子串数量，那么 <code>f(n)</code> 为答案。</p><p>对于某个 <code>f(i)</code>，可以分两种情况讨论：</p><p>如果 <code>s[i]</code> 不在任意回文子串内的话，那么 <code>f(i) = f(i - 1)</code>，可以作为 <code>f(i)</code> 的初始值。</p><p>如果 <code>s[i]</code> 在某个回文子串内时，枚举左端点 <code>left</code>，可以得到：<br><code>当 s(left, i) 为回文串，f(i) = Max(f(i), f(left - 1) + 1)</code>，其中<code>left</code> 取值范围为 <code>i - left + 1 &gt;= k</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPalindromes</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] c = s.toCharArray();<br>        <span class="hljs-type">boolean</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n + <span class="hljs-number">1</span>; j++)&#123;<br>                <span class="hljs-keyword">if</span>(c[i - <span class="hljs-number">1</span>] == c[j - <span class="hljs-number">1</span>] &amp;&amp; (j - i &lt;= <span class="hljs-number">1</span> || g[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]))&#123;<br>                    g[i][j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            f[i] = f[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// i不参与</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i - k + <span class="hljs-number">1</span>; left &gt;= <span class="hljs-number">1</span>; left--)&#123;<br>                <span class="hljs-keyword">if</span>(g[left][i])&#123;<br>                    f[i] = Math.max(f[i], f[left - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-790.多米诺和托米诺平铺</title>
    <link href="/2022/11/12/LC-790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/"/>
    <url>/2022/11/12/LC-790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/domino-and-tromino-tiling/">leetcode 中等题</a></p><p>有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。<br><img src="/../img/1668239955779.jpg"></p><p>给定整数 n ，返回可以铺满 2 x n 的面板的方法的数量。返回对 10e9 + 7 取模 的值。</p><p><strong>注意下图中的 1-3 方案，是白色瓷砖而不是没铺满，不要产生误解</strong></p><p><img src="/../img/1668239825809.jpg"></p><h2 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h2><ul><li>f(1) &#x3D; 1</li><li>f(2) &#x3D; 2</li><li>f(3) &#x3D; 5</li><li>f(4) &#x3D; 11 &#x3D; 5 * 2 + 1 &#x3D; f(3) * 2 + f(1)</li><li>f(5) &#x3D; 24 &#x3D; 11 * 2 + 2 &#x3D; f(4) * 2 + f(2)</li></ul><p>得出 <code>f(i) = 2 * (f - i) + f(i - 3)</code>，其中 <code>i &gt; 3</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">10</span>];<br>        f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        f[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; i &lt;= n; i++)&#123;<br>            f[i] = (((<span class="hljs-number">2</span> * f[i - <span class="hljs-number">1</span>]) % MOD) + f[i - <span class="hljs-number">3</span>]) % MOD;<br>        &#125;        <br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="找规律-滚动数组"><a href="#找规律-滚动数组" class="headerlink" title="找规律 + 滚动数组"></a>找规律 + 滚动数组</h2><p>可以发现最多会往前依赖到 <code>i - 3</code>，那么只需要保存最近的三个结果即可。</p><p>但这里为了方便（抖机灵），保存了 <code>4</code> 个结果。因为对 <code>2</code> 的 <code>n</code> 次方的取模运算，可以转换成对 <code>n - 1</code> 的与运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br>        f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        f[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> i &amp; <span class="hljs-number">3</span>, pre = i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">3</span>, magic = i - <span class="hljs-number">3</span> &amp; <span class="hljs-number">3</span>;<br>            f[cur] = (((<span class="hljs-number">2</span> * f[pre]) % MOD) + f[magic]) % MOD;<br>        &#125;        <br>        <span class="hljs-keyword">return</span> f[n &amp; <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种类型的题目由于结果固定，且数据范围有限，还能用第一种解法 + 打表对结果进行保存，由于做法类似就不在这里列出了。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>定义 <code>dp[i][j]</code> 为： 在第 <code>i</code> 列前面的正方形都被瓷砖覆盖，当前第 <code>i</code> 列状态为 <code>j</code> 时的方案数。那么第 <code>i</code> 列的正方形有四种（即 <code>j</code> 取值范围）被覆盖的情况：</p><p>第 <code>i</code> 列为空，<code>j</code> 为 <code>0</code>；</p><p>第 <code>i</code> 列上方格子为空，<code>j</code>为 <code>1</code>；</p><p>第 <code>i</code> 列下方格子为空，<code>j</code>为 <code>2</code>；</p><p>第 <code>i</code> 列为满，<code>j</code>为 <code>3</code>。</p><p>那么状态转移如下:</p><p><img src="/../img/20221112170609.png" alt="https://leetcode.cn/problems/domino-and-tromino-tiling/solution/duo-mi-nuo-he-tuo-mi-nuo-ping-pu-by-leet-7n0j/"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>            dp[i][<span class="hljs-number">1</span>] = (dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) % MOD;<br>            dp[i][<span class="hljs-number">2</span>] = (dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % MOD;<br>            dp[i][<span class="hljs-number">3</span>] = (((dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]) % MOD + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % MOD + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][<span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划-滚动数组"><a href="#动态规划-滚动数组" class="headerlink" title="动态规划 + 滚动数组"></a>动态规划 + 滚动数组</h2><p>类似于 <code>找规律 + 滚动数组</code> 的优化，<code>dp[i]</code>只往前依赖于 <code>dp[i - 1]</code>，所以可以把数组的第一维优化成 <code>2</code>。</p><p>稍微要注意的是，由于 <code>0、1、2、3</code> 状态之间存在相互依赖，所以无法优化成一维数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">4</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span>  <span class="hljs-operator">=</span> i &amp; <span class="hljs-number">1</span>, pre = i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>;<br>            dp[cur][<span class="hljs-number">0</span>] = dp[pre][<span class="hljs-number">3</span>];<br>            dp[cur][<span class="hljs-number">1</span>] = (dp[pre][<span class="hljs-number">0</span>] + dp[pre][<span class="hljs-number">2</span>]) % MOD;<br>            dp[cur][<span class="hljs-number">2</span>] = (dp[pre][<span class="hljs-number">0</span>] + dp[pre][<span class="hljs-number">1</span>]) % MOD;<br>            dp[cur][<span class="hljs-number">3</span>] = (((dp[pre][<span class="hljs-number">0</span>] + dp[pre][<span class="hljs-number">3</span>]) % MOD + dp[pre][<span class="hljs-number">1</span>]) % MOD + dp[pre][<span class="hljs-number">2</span>]) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n &amp; <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;<br>        &#125;;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br>        &#125;;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                ans = mul(matrix, ans);<br>            &#125;<br>            matrix = mul(matrix, matrix);<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 应该等价</span><br>        <span class="hljs-comment">// int[] first = new int[]&#123;0, 0, 0, 1&#125;;</span><br>        <span class="hljs-comment">// return ans[3][0] * first[0] + ans[3][1] * first[1] + ans[3][2] * first[2] + ans[3][3] * first[3];</span><br>        <span class="hljs-keyword">return</span> ans[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] mul(<span class="hljs-type">int</span>[][] a, <span class="hljs-type">int</span>[][] b)&#123;<br>        <span class="hljs-type">int</span>[][] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length][a.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; a.length; j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; a.length; k++)&#123;<br>                    ret[i][j] = (<span class="hljs-type">int</span>)((ret[i][j] + (<span class="hljs-type">long</span>) a[i][k] * b[k][j]) % MOD);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>矩阵快速幂</tag>
      
      <tag>动态规划</tag>
      
      <tag>脑筋急转弯/找规律</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.NULL-The-Missing-Semester-of-Your-CS-Education</title>
    <link href="/2022/11/11/6.NULL-The-Missing-Semester-of-Your-CS-Education/"/>
    <url>/2022/11/11/6.NULL-The-Missing-Semester-of-Your-CS-Education/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://missing.csail.mit.edu/">The Missing Semester of Your CS Education</a></p><p>该课程主要是教如何更高效的使用命令行、编辑器、Git 等工具。</p></blockquote><h2 id="Lecture-1-Course-overview-the-shell"><a href="#Lecture-1-Course-overview-the-shell" class="headerlink" title="Lecture 1 - Course overview + the shell"></a>Lecture 1 - Course overview + the shell</h2><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><ul><li>&gt; 将一个命令&#x2F;程序的输出流重定向到一个 <strong>文件</strong>， &lt; 相反。&gt;&gt; 和 &lt;&lt; 用做追加</li><li>管道符 <code>|</code> 与 &gt; 不同的是，目标可以是 <strong>命令&#x2F;程序</strong></li><li>单引号：所见即所得</li><li>双引号：所见非所得，它会先把变量解析之后，再输出</li></ul><h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><p>这一节练习比较简单，所以其他的省略。</p><ul><li>Write the following into that file, one line at a time:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs file">#!/bin/bash<br>curl --head --silent https://missing.csail.mit.edu<br></code></pre></td></tr></table></figure>The first line might be tricky to get working. It’s helpful to know that # starts a comment in Bash, and ! has a special meaning even within double-quoted (“) strings. Bash treats single-quoted strings (‘) differently: they will do the trick in this case. See the Bash quoting manual page for more information.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;#!/bin/bash&#x27;</span> &gt;&gt; semester<br><span class="hljs-built_in">echo</span> curl --<span class="hljs-built_in">head</span> --silent https://missing.csail.mit.edu  &gt;&gt; semester<br></code></pre></td></tr></table></figure></li><li>Use | and &gt; to write the “last modified” date output by semester into a file called last-modified.txt in your home directory.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./semester | grep last-modified | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&quot; &quot;</span> -f 2- &gt; last-modified.txt<br></code></pre></td></tr></table></figure></li></ul><h2 id="Lecture-2-Shell-Tools-and-Scripting"><a href="#Lecture-2-Shell-Tools-and-Scripting" class="headerlink" title="Lecture 2 - Shell Tools and Scripting"></a>Lecture 2 - Shell Tools and Scripting</h2><h3 id="Notes-1"><a href="#Notes-1" class="headerlink" title="Notes"></a>Notes</h3><ul><li>To assign variables in bash, use the syntax foo&#x3D;bar and access the value of the variable with $foo. Note that foo &#x3D; bar will not work since it is interpreted as calling the foo program with arguments &#x3D; and bar. In general, in shell scripts the space character will perform argument splitting. This behavior can be confusing to use at first, so always check for that.</li><li>$_ 上条命令的最后一个参数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># e.g.</span><br><span class="hljs-variable">$mkdir</span> <span class="hljs-built_in">test</span><br><span class="hljs-variable">$cd</span> <span class="hljs-variable">$_</span><br></code></pre></td></tr></table></figure></li><li>$? 上条命令的错误代码（返回值）</li><li>$0 脚本名字，$1 到 $9 为 bash 脚本的第一个到第九个参数</li><li>$? 错误代码, 0正常1错误</li><li>花括号{} - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># e.g.</span><br><span class="hljs-variable">$mkdir</span> &#123;foo,bar&#125;<br><span class="hljs-variable">$mkdir</span> &#123;foo,bar&#125;/&#123;a,b,c&#125;<br><span class="hljs-variable">$mkdir</span> foo/x bar/y<br><span class="hljs-variable">$diff</span> &#123;foo,bar&#125;   <br>Common subdirectories: foo/a and bar/a<br>Common subdirectories: foo/b and bar/b<br>Common subdirectories: foo/c and bar/c<br>Only <span class="hljs-keyword">in</span> foo: x<br>Only <span class="hljs-keyword">in</span> bar: y<br></code></pre></td></tr></table></figure></li><li>当您通过 $( ls ) 这样的方式来执行 ls 这个命令时，它的输出结果会替换掉 $( ls ) 。例如，如果执行 for file in $(ls) ，shell首先将调用ls ，然后遍历得到的这些返回值。</li><li>&lt;() 进程替换（process substitution）， &lt;( ls ) 会执行 ls 并将结果输出到一个临时文件中，并将 &lt;( ls ) 替换成临时文件名。这在我们希望返回值 <strong>通过文件而不是STDIN传递</strong> 时很有用。例如， diff &lt;(ls foo) &lt;(ls bar) 会显示文件夹 foo 和 bar 中文件的区别。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># e.g.</span><br><span class="hljs-variable">$cat</span> &lt;(<span class="hljs-built_in">ls</span> foo) &lt;(<span class="hljs-built_in">ls</span> bar)<br>a<br>b<br>c<br>x<br>a<br>b<br>c<br>y<br><span class="hljs-variable">$diff</span> &lt;(<span class="hljs-built_in">ls</span> bar) &lt;(<span class="hljs-built_in">ls</span> foo)<br>4c4<br>&lt; y<br>---<br>&gt; x<br><br></code></pre></td></tr></table></figure></li><li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 ? 和 * 来匹配一个或任意个字符。例如，对于文件foo, foo1, foo2, foo10 和 bar, rm foo?这条命令会删除foo1 和 foo2 ，而rm foo* 则会删除除了bar之外的所有文件。</li><li>find<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># e.g. 删除全部扩展名为.tmp 的文件</span><br>find . -name <span class="hljs-string">&#x27;*.tmp&#x27;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">rm</span> &#123;&#125; \;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Exercises-1"><a href="#Exercises-1" class="headerlink" title="Exercises"></a>Exercises</h3><ul><li><p>Write bash functions marco and polo that do the following. Whenever you execute marco the current working directory should be saved in some manner, then when you execute polo, no matter what directory you are in, polo should cd you back to the directory where you executed marco. For ease of debugging you can write the code in a file marco.sh and (re)load the definitions to your shell by executing source marco.sh.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing  <span class="hljs-built_in">cat</span> marco.sh   <br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-function"><span class="hljs-title">marco</span></span>()&#123;<br>    <span class="hljs-built_in">pwd</span> &gt; /tmp/missing/save-path.log<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">polo</span></span>()&#123;<br>    p=$(<span class="hljs-built_in">cat</span> /tmp/missing/save-path.log)<br>    <span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$p</span>&quot;</span><br>&#125;<br><br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing  <span class="hljs-built_in">cd</span> /usr/local/dev<br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /usr/local/dev  <span class="hljs-built_in">source</span> /tmp/missing/marco.sh <br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /usr/local/dev  marco    <br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /usr/local/dev  <span class="hljs-built_in">cat</span> /tmp/missing/save-path.log <br>/usr/local/dev<br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /usr/local/dev  <span class="hljs-built_in">cd</span> /                          <br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /  polo          <br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /usr/local/dev  <br></code></pre></td></tr></table></figure></li><li><p>Say you have a command that fails rarely. In order to debug it you need to capture its output but it can be time consuming to get a failure run. Write a bash script that runs the following script until it fails and captures its standard output and error streams to files and prints everything at the end. Bonus points if you can also report how many runs it took for the script to fail.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  <span class="hljs-built_in">cat</span> call.sh  <br><span class="hljs-comment">#!/usr/bin/env bash</span><br>count=1<br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span><br>    ./mock &amp;&gt;&gt; out.log<br>    <span class="hljs-keyword">if</span> [[ $? -ne 0 ]]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">cat</span> out.log<br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$count</span>&quot;</span><br>        <span class="hljs-built_in">break</span><br>    <span class="hljs-keyword">fi</span><br>    ((count++))<br><span class="hljs-keyword">done</span><br><br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  ./call.sh <br>119<br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  <span class="hljs-built_in">cat</span> out.log<br>...<br>Everything went according to plan<br>Everything went according to plan<br>Everything went according to plan<br>Something went wrong<br>The error was using magic numbers<br></code></pre></td></tr></table></figure></li><li><p>Your task is to write a command that recursively finds all HTML files in the folder and makes a zip with them. Note that your command should work even if the files have spaces (hint: check -d flag for xargs).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  <span class="hljs-built_in">mkdir</span> &#123;a,b&#125;    <br>⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  <span class="hljs-built_in">touch</span>  &#123;a,b&#125;/&#123;1,2.html,3.html&#125;                  <br>⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  <span class="hljs-built_in">touch</span> &#123;a,b&#125;/&#123;4\ 4.html,5\ 5.html&#125;<br>⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  find . -name <span class="hljs-string">&quot;*.html&quot;</span> -print0 | xargs -0 zip -r 1.zip<br><span class="hljs-comment"># or</span><br>⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  find . -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*.html&quot;</span> | xargs -d <span class="hljs-string">&#x27;\n&#x27;</span>  tar -cvzf html.zip<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-864.获取所有钥匙的最短路径</title>
    <link href="/2022/11/10/LC-864-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/11/10/LC-864-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/shortest-path-to-get-all-keys/">leetcode 困难题</a></p><p>给定一个二维网格 grid ，其中：</p><ul><li>‘.’ 代表一个空房间</li><li>‘#’ 代表一堵</li><li>‘@’ 是起点</li><li>小写字母代表钥匙</li><li>大写字母代表锁</li></ul><p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p><p>假设 k 为 钥匙&#x2F;锁 的个数，且满足 1 &lt;&#x3D; k &lt;&#x3D; 6，字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p><p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。</p><p>示例1：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">grid</span> = [<span class="hljs-string">&quot;@.a.#&quot;</span>,<span class="hljs-string">&quot;###.#&quot;</span>,<span class="hljs-string">&quot;b.A.B&quot;</span>]<br>输出：<span class="hljs-number">8</span><br>解释：目标是获得所有钥匙，而不是打开所有锁。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">grid</span> = [<span class="hljs-string">&quot;@..aA&quot;</span>,<span class="hljs-string">&quot;..B#.&quot;</span>,<span class="hljs-string">&quot;....b&quot;</span>]<br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: grid = [&quot;@Aa&quot;]</span><br><span class="hljs-section">输出: -1</span><br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">m == grid.length<br>n == grid[i].length<br><span class="hljs-number">1</span> &lt;= m, n &lt;= <span class="hljs-number">30</span><br>grid[i][j] 只含有 <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;#&#x27;</span>, <span class="hljs-string">&#x27;@&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>-<span class="hljs-string">&#x27;f&#x27;</span> 以及 <span class="hljs-string">&#x27;A&#x27;</span>-<span class="hljs-string">&#x27;F&#x27;</span><br>钥匙的数目范围是 [<span class="hljs-number">1</span>, <span class="hljs-number">6</span>] <br>每个钥匙都对应一个 不同 的字母<br>每个钥匙正好打开一个对应的锁<br></code></pre></td></tr></table></figure><h2 id="BFS-状态压缩"><a href="#BFS-状态压缩" class="headerlink" title="BFS + 状态压缩"></a>BFS + 状态压缩</h2><p>对于最短路径我们可以通过 <a href="https://oi-wiki.org/graph/bfs/">BFS</a> 求出，并且因为钥匙最多只有 6 把，所以可以通过一个 <code>int</code> 来记录当前路径获得钥匙的情况 (称为 <code>state</code>)，对应位数为 1 时代表已经取得对应钥匙。</p><p>需要注意的是，不同于普通的 <code>BFS</code>：在确定访问状态时，不能仅仅通过坐标 <code>x, y</code> 来确定，还要加入状态，也就是说通过 <code>x, y, state</code> 来确定一个访问状态。</p><p>这是因为比如说经过某个房间 <code>a</code> 后，在房间 <code>b</code> 拿到一把新锁，接着又因为碰到墙壁或者其他未拿到钥匙的锁需要原路返回，重新经过了 <code>a</code>，那么这显然是一条新的有效路径（因为拿到了 <code>b</code> 的锁），所以我们还需要加入钥匙 <code>state</code> 来确定访问状态。反之如果坐标和钥匙 <code>state</code> 都相同，就是无效的路径，无需重新入队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathAllKeys</span><span class="hljs-params">(String[] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">keyCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stratx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, starty = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 初始化图、统计钥匙数量、记录起点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            g[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[m];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> grid[i].charAt(j);<br>                g[i][j] = c;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= sub &amp;&amp; sub &lt;= <span class="hljs-number">23</span>)&#123;<br>                    keyCount++;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;@&#x27;</span>)&#123;<br>                    stratx = i;<br>                    starty = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// Deque for BFS</span><br>        Deque&lt;<span class="hljs-type">int</span>[]&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        deque.offerLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;stratx, starty, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-comment">// 通过 `[x][y][state]` 来确定访问状态，并且记录下此时的路径距离，初始化为 -1 表示未访问过</span><br>        <span class="hljs-type">int</span>[][][] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m][<span class="hljs-number">1</span> &lt;&lt; keyCount];<br>        IntStream.range(<span class="hljs-number">0</span>, n).forEach(i -&gt; IntStream.range(<span class="hljs-number">0</span>, m).forEach(j -&gt; Arrays.fill(vis[i][j], - <span class="hljs-number">1</span>)));<br>        vis[stratx][starty][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            <span class="hljs-type">int</span>[] cur = deque.pollFirst();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> vis[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]][cur[<span class="hljs-number">2</span>]] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; help.length; i++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>] + help[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>] + help[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(!checkIndex(x, y, n, m) || g[x][y] == <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> g[x][y];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">if</span>(c != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;@&#x27;</span> &amp;&amp; (c &amp; <span class="hljs-number">32</span>) == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 锁</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">need</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;A&#x27;</span>);<br>                    <span class="hljs-keyword">if</span>((state &amp; need) != need)&#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(c != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; (c &amp; <span class="hljs-number">32</span>) == <span class="hljs-number">32</span>)&#123; <br>                    <span class="hljs-comment">// 钥匙</span><br>                    state |= (<span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;a&#x27;</span>));<br>                    <span class="hljs-keyword">if</span>(getCurKeyCount(state) == keyCount)&#123;<br>                        <span class="hljs-keyword">return</span> d;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(vis[x][y][state] == -<span class="hljs-number">1</span>)&#123;<br>                    vis[x][y][state] = d;<br>                    deque.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x, y, state&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> xLimit, <span class="hljs-type">int</span> yLimit)</span>&#123;<br>        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; xLimit &amp;&amp; y &lt; yLimit;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCurKeyCount</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(state &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>((state &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                count++;<br>            &#125;<br>            state = state &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>状态压缩</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about-windows</title>
    <link href="/2022/11/10/about-windows/"/>
    <url>/2022/11/10/about-windows/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前 <code>windows</code> 使用的比较多，在日常使用中会重复遇到一些问题，但总是解决后过段时间就忘了，所以在此记录下来。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>需要知道的是，<code>cmd</code> 和 <code>PowerShell</code> 打印某个环境变量的方式是不同的</p><ul><li>cmd<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">echo</span> <span class="hljs-variable">%Path%</span><br></code></pre></td></tr></table></figure></li><li>PowerShell<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-variable">$env:path</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="刷新环境变量"><a href="#刷新环境变量" class="headerlink" title="刷新环境变量"></a>刷新环境变量</h3><p><a href="https://github.com/chocolatey/choco">choco</a> 内置的 <code>refreshenv</code> 可以帮助我们在不重启终端的情况下方便的刷新环境变量。</p><p>需要注意的是虽然旧版命令行可以通过重启终端的手段刷新环境变量，但在 <a href="https://github.com/microsoft/terminal">win11 默认的 terminal</a> 中由于 <a href="https://github.com/microsoft/terminal/issues/1125">某些问题</a> 导致无法确保重启终端能够刷新环境变量。在这种时候，使用 <code>choco</code> 中的 <code>refreshenv</code> 几乎就是必须的了。</p><ul><li><p>cmd</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">refreshenv<br></code></pre></td></tr></table></figure></li><li><p>可能会发现在 <code>PowerShell</code> 中使用该命令并没有生效，这是因为还要进行 <a href="https://docs.chocolatey.org/en-us/troubleshooting#why-does-choco-tab-not-work-for-me">some additional work</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Uncategorized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6232.最小移动总距离</title>
    <link href="/2022/11/08/LC-6232-%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%80%BB%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/11/08/LC-6232-%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%80%BB%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/minimum-total-distance-traveled/">leetcode 困难题</a></p><p>X 轴上有一些机器人和工厂。给你一个整数数组 robot ，其中 robot[i] 是第 i 个机器人的位置。再给你一个二维整数数组 factory ，其中 factory[j] &#x3D; [positionj, limitj] ，表示第 j 个工厂的位置在 positionj ，且第 j 个工厂最多可以修理 limitj 个机器人。</p><p>每个机器人所在的位置 互不相同 。每个工厂所在的位置也 互不相同 。注意一个机器人可能一开始跟一个工厂在 相同的位置 。</p><p>所有机器人一开始都是坏的，他们会沿着设定的方向一直移动。设定的方向要么是 X 轴的正方向，要么是 X 轴的负方向。当一个机器人经过一个没达到上限的工厂时，这个工厂会维修这个机器人，且机器人停止移动。</p><p>任何时刻，你都可以设置 部分 机器人的移动方向。你的目标是最小化所有机器人总的移动距离。</p><p>请你返回所有机器人移动的最小总距离。测试数据保证所有机器人都可以被维修。</p><p>注意：</p><p>所有机器人移动速度相同。<br>如果两个机器人移动方向相同，它们永远不会碰撞。<br>如果两个机器人迎面相遇，它们也不会碰撞，它们彼此之间会擦肩而过。<br>如果一个机器人经过了一个已经达到上限的工厂，机器人会当作工厂不存在，继续移动。<br>机器人从位置 x 到位置 y 的移动距离为 |y - x| 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：robot = [0,4,6], factory = [[2,2],[6,2]]<br>输出：4<br>解释：如上图所示：<br>- 第一个机器人从位置<span class="hljs-number"> 0 </span>沿着正方向移动，在第一个工厂处维修。<br>- 第二个机器人从位置<span class="hljs-number"> 4 </span>沿着负方向移动，在第一个工厂处维修。<br>- 第三个机器人在位置<span class="hljs-number"> 6 </span>被第二个工厂维修，它不需要移动。<br>第一个工厂的维修上限是<span class="hljs-number"> 2 </span>，它维修了<span class="hljs-number"> 2 </span>个机器人。<br>第二个工厂的维修上限是<span class="hljs-number"> 2 </span>，它维修了<span class="hljs-number"> 1 </span>个机器人。<br>总移动距离是 |2 - 0| + |2 - 4| + |6 - 6| =<span class="hljs-number"> 4 </span>。没有办法得到比<span class="hljs-number"> 4 </span>更少的总移动距离。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：robot = [1,-1], factory = [[-2,1],[2,1]]<br>输出：2<br>解释：如上图所示：<br>- 第一个机器人从位置<span class="hljs-number"> 1 </span>沿着正方向移动，在第二个工厂处维修。<br>- 第二个机器人在位置 -1 沿着负方向移动，在第一个工厂处维修。<br>第一个工厂的维修上限是<span class="hljs-number"> 1 </span>，它维修了<span class="hljs-number"> 1 </span>个机器人。<br>第二个工厂的维修上限是<span class="hljs-number"> 1 </span>，它维修了<span class="hljs-number"> 1 </span>个机器人。<br>总移动距离是 |2 - 1| + |(-2) - (-1)| =<span class="hljs-number"> 2 </span>。没有办法得到比<span class="hljs-number"> 2 </span>更少的总移动距离。<br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span> &lt;= robot<span class="hljs-selector-class">.length</span>, factory<span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">100</span><br>factory<span class="hljs-selector-attr">[j]</span><span class="hljs-selector-class">.length</span> == <span class="hljs-number">2</span><br>-<span class="hljs-number">109</span> &lt;= robot<span class="hljs-selector-attr">[i]</span>, positionj &lt;= <span class="hljs-number">109</span><br><span class="hljs-number">0</span> &lt;= limitj &lt;= robot<span class="hljs-selector-class">.length</span><br>测试数据保证所有机器人都可以被维修。<br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>有一个关键的结论：</p><blockquote><p>设两个机器人的位置分别为 r1, r2，且 r1 &lt; r2 ，机器人去的工厂的位置为 f1,f2 ，则 f1 必然小于 f2 ，因为如果 f1 &gt; f2 的话，交换这两个机器人去的工厂，移动距离就变小了。</p></blockquote><p>因此我们可以先对机器人和工厂按照位置从小到大排序，那么每个工厂要修复的机器人就将是连续的一段。</p><hr><p><strong>在以下几种解法中，我们统一设 f(i, j) 的含义为第 j 个及其右侧的工厂，修理第 i 个及其右侧的机器人时的最小距离，那么 f(0, 0) 就是题目所求。</strong></p><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>一种解法是递归 + 记忆化搜索。</p><p>对于某个 <code>f(i, j)</code>，我们枚举出第 <code>j</code> 个工厂修任意个机器人的可能（比如修 <code>k</code> 个），同时设修这 <code>k</code> 个机器人所花费的距离为 <code>d(k)</code>，那么只需要取所有 <code>f(i + k + 1, j + 1) + d(k)</code> 的最小值，就是我们要求的 <code>f(i, j)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">long</span>[][] cache;<br>    List&lt;Integer&gt; robot;<br>    <span class="hljs-type">int</span>[][] factory;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTotalDistance</span><span class="hljs-params">(List&lt;Integer&gt; robot, <span class="hljs-type">int</span>[][] factory)</span> &#123;<br>        Collections.sort(robot);<br>        Arrays.sort(factory, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">this</span>.robot = robot;<br>        <span class="hljs-built_in">this</span>.factory = factory;<br>        <span class="hljs-built_in">this</span>.cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[robot.size()][factory.length];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// cache[i][j] 表示第 i 个及其右侧的工厂，修理第 j 个及其右侧的机器人时的最小距离</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= robot.size())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j &gt;= factory.length)&#123;<br>            <span class="hljs-keyword">return</span> Long.MAX_VALUE; <span class="hljs-comment">// Integer.MAX_VALUE 不够大</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(cache[i][j] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> cache[i][j];<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> dfs(i, j + <span class="hljs-number">1</span>); <span class="hljs-comment">// 初始化为当前工厂不修理任何机器人</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; factory[j][<span class="hljs-number">1</span>] &amp;&amp; i + k &lt; robot.size(); k++)&#123;<br>            d +=  Math.abs(robot.get(i + k) - factory[j][<span class="hljs-number">0</span>]); <span class="hljs-comment">// d(a)</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> dfs(i + k + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> temp == Long.MAX_VALUE ? Long.MAX_VALUE : temp + d; <span class="hljs-comment">//防止溢出</span><br>            min = Math.min(min, next);<br>        &#125;<br>        cache[i][j] = min;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><p>根据 <code>记忆化搜索</code> 的解法，我们容易发现前面工厂的状态总是依赖于后面工厂的状态，所以我们只需要逆序遍历 <code>factory</code> 就可以实现动态规划，简略的方程如下：</p><p><code>f(i, j) = min( f(i + k + 1, j + 1) + d(k) ) </code>（ <code>k</code> 取值范围为 <code>[0, factory[i][1]] - 1</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTotalDistance</span><span class="hljs-params">(List&lt;Integer&gt; robot, <span class="hljs-type">int</span>[][] factory)</span> &#123;<br>        Collections.sort(robot);<br>        Arrays.sort(factory, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> robot.size(), fs = factory.length;<br>        <span class="hljs-comment">// dp[i][j] 表示第 i 个及其右侧的工厂，修理第 j 个及其右侧的机器人时的最小距离</span><br>        <span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[rs][fs + <span class="hljs-number">1</span>];<br>        IntStream.range(<span class="hljs-number">0</span>, dp.length).forEach(index -&gt; Arrays.fill(dp[index], Long.MAX_VALUE));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> fs - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rs; i++)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> dp[i][j + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 初始化为一个都不修</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= factory[j][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &amp;&amp; i + k &lt; rs; k++)&#123;<br>                    d += Math.abs(robot.get(i + k) - factory[j][<span class="hljs-number">0</span>]);<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> i + k == rs - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : dp[i + k + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] ;<br>                    <span class="hljs-keyword">if</span>(next != Long.MAX_VALUE)&#123;<br>                        min = Math.min(min, next + d);<br>                    &#125;<br>                &#125;<br>                dp[i][j] = min;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h3><p>就像背包问题一样，我们可以发现工厂 <code>j</code> 只会依赖于工厂 <code>j + 1</code> 的状态，即实际上我们只需要保留最新的工厂状态，可以利用滚动数组进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTotalDistance</span><span class="hljs-params">(List&lt;Integer&gt; robot, <span class="hljs-type">int</span>[][] factory)</span> &#123;<br>        Collections.sort(robot);<br>        Arrays.sort(factory, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> robot.size(), fs = factory.length;<br>        <span class="hljs-comment">// dp[i][j] 表示第 i 个及其右侧的工厂，修理第 j 个及其右侧的机器人时的最小距离</span><br>        <span class="hljs-type">long</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[rs + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, Long.MAX_VALUE);<br>        dp[rs] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> fs - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rs; i++)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> dp[i]; <span class="hljs-comment">// 一个都不修</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= factory[j][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &amp;&amp; i + k &lt; rs; k++)&#123;<br>                    d += Math.abs(robot.get(i + k) - factory[j][<span class="hljs-number">0</span>]);<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> dp[i + k + <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>(next != Long.MAX_VALUE)&#123;<br>                        min = Math.min(min, next + d);<br>                    &#125;<br>                &#125;<br>                dp[i] = min;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6231.雇佣K位工人的总代价</title>
    <link href="/2022/11/06/LC-6231-%E9%9B%87%E4%BD%A3K%E4%BD%8D%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%80%BB%E4%BB%A3%E4%BB%B7/"/>
    <url>/2022/11/06/LC-6231-%E9%9B%87%E4%BD%A3K%E4%BD%8D%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%80%BB%E4%BB%A3%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/total-cost-to-hire-k-workers/">leetcode 中等题</a></p><p>给你一个下标从 0 开始的整数数组 costs ，其中 costs[i] 是雇佣第 i 位工人的代价。</p><p>同时给你两个整数 k 和 candidates 。我们想根据以下规则恰好雇佣 k 位工人：</p><p>总共进行 k 轮雇佣，且每一轮恰好雇佣一位工人。<br>在每一轮雇佣中，从最前面 candidates 和最后面 candidates 人中选出代价最小的一位工人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。<br>比方说，costs &#x3D; [3,2,7,7,1,2] 且 candidates &#x3D; 2 ，第一轮雇佣中，我们选择第 4 位工人，因为他的代价最小 [3,2,7,7,1,2] 。<br>第二轮雇佣，我们选择第 1 位工人，因为他们的代价与第 4 位工人一样都是最小代价，而且下标更小，[3,2,7,7,2] 。注意每一轮雇佣后，剩余工人的下标可能会发生变化。<br>如果剩余员工数目不足 candidates 人，那么下一轮雇佣他们中代价最小的一人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。<br>一位工人只能被选择一次。<br>返回雇佣恰好 k 位工人的总代价。</p><p>示例1：<br>输入：costs &#x3D; [17,12,10,2,7,2,11,20,8], k &#x3D; 3, candidates &#x3D; 4<br>输出：11<br>解释：我们总共雇佣 3 位工人。总代价一开始为 0 。</p><ul><li>第一轮雇佣，我们从 [17,12,10,2,,2,11,20,8] 中选择。最小代价是 2 ，有两位工人，我们选择下标更小的一位工人，即第 3 位工人。总代价是 0 + 2 &#x3D; 2 。</li><li>第二轮雇佣，我们从 [17,12,10,7,2,11,20,8] 中选择。最小代价是 2 ，下标为 4 ，总代价是 2 + 2 &#x3D; 4 。</li><li>第三轮雇佣，我们从 [17,12,10,7,11,20,8] 中选择，最小代价是 7 ，下标为 3 ，总代价是 4 + 7 &#x3D; 11 。注意下标为 3 的工人同时在最前面和最后面 4 位工人中。<br>总雇佣代价是 11 。</li></ul><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= costs.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= costs[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= k, candidates &lt;= costs.length<br></code></pre></td></tr></table></figure><h2 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h2><p>通过两个最小堆模拟 <code>最前面 candidates 和最后面 candidates 个人</code> 即可，具体来说每次取出两个堆的最小值，接着继续尝试维护堆直到 <code>k</code> 轮选人结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">totalCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] costs, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> candidates)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> costs.length;<br>        Comparator&lt;<span class="hljs-type">int</span>[]&gt; cmp = (a, b) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];<br>        &#125;;<br>        <span class="hljs-comment">// 实际上不需要比较下标，可以改成 PriorityQueue&lt;Integer&gt;</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; front = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(cmp); <br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(cmp);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; candidates &amp;&amp; left &lt;= right; i++)&#123; <span class="hljs-comment">// candidates 个人</span><br>            front.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[left], left++&#125;);<br>            <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            tail.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[right], right--&#125;);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(k-- &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span>[] f = front.peek();<br>            <span class="hljs-type">int</span>[] t = tail.peek();<br>            <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span> || (f != <span class="hljs-literal">null</span> &amp;&amp; f[<span class="hljs-number">0</span>] &lt;= t[<span class="hljs-number">0</span>]))&#123;<br>                ans += front.poll()[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">if</span>(left &lt;= right)&#123;<br>                    front.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[left], left++&#125;);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans += tail.poll()[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">if</span>(left &lt;= right)&#123;<br>                    tail.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[right], right--&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6230.长度为K子数组中的最大和</title>
    <link href="/2022/11/06/LC-6230-%E9%95%BF%E5%BA%A6%E4%B8%BAK%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <url>/2022/11/06/LC-6230-%E9%95%BF%E5%BA%A6%E4%B8%BAK%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/">leetcode 中等题</a></p><p>给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和：</p><p>子数组的长度是 k，且<br>子数组中的所有元素 各不相同 。<br>返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。</p><p>子数组 是数组中一段连续非空的元素序列。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,5,4,2,9,9,9], k = 3<br>输出：15<br>解释：nums 中长度为<span class="hljs-number"> 3 </span>的子数组是：<br>- [1,5,4] 满足全部条件，和为<span class="hljs-number"> 10 </span>。<br>- [5,4,2] 满足全部条件，和为<span class="hljs-number"> 11 </span>。<br>- [4,2,9] 满足全部条件，和为<span class="hljs-number"> 15 </span>。<br>- [2,9,9] 不满足全部条件，因为元素<span class="hljs-number"> 9 </span>出现重复。<br>- [9,9,9] 不满足全部条件，因为元素<span class="hljs-number"> 9 </span>出现重复。<br>因为<span class="hljs-number"> 15 </span>是满足全部条件的所有子数组中的最大子数组和，所以返回<span class="hljs-number"> 15 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [4,4,4], k = 3<br>输出：0<br>解释：nums 中长度为<span class="hljs-number"> 3 </span>的子数组是：<br>- [4,4,4] 不满足全部条件，因为元素<span class="hljs-number"> 4 </span>出现重复。<br>因为不存在满足全部条件的子数组，所以返回<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= k &lt;= nums.length &lt;= <span class="hljs-number">1e5</span><br><span class="hljs-symbol">1 </span>&lt;= nums[i] &lt;= <span class="hljs-number">1e5</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一开始看到数据范围时候，第一反应就是不能用 <code>O(N^2)</code> 时间复杂度实现。</p><p>当时确实想到了滑动窗口，但是却觉得滑动窗口需要 <code>O(N^2)</code> 的时间复杂度（太蠢了）。</p><p>直到后面才发现滑动窗口的时间复杂度就是 <code>O(N)</code>，因为不管嵌套了几次内层循环，左右指针都是单调的从 <code>0-&gt;(n - 1)</code> 递增，即总共的循环次数只会有 <code>n</code> 次，所以时间复杂度是满足要求的。</p><h2 id="滑动窗口-Set"><a href="#滑动窗口-Set" class="headerlink" title="滑动窗口 + Set"></a>滑动窗口 + Set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumSubarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Set&lt;Integer&gt; exist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n &amp;&amp; j &lt; n; j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightItem</span> <span class="hljs-operator">=</span> nums[j];<br>            <span class="hljs-keyword">while</span>(exist.contains(rightItem))&#123;<br>                <span class="hljs-comment">// 存在重复元素, 移动左指针，直到重复元素被移除了</span><br>                exist.remove(nums[i]);<br>                curSum -= nums[i++];<br>            &#125;<br>            curSum += rightItem;<br>            exist.add(rightItem);<br>            <span class="hljs-keyword">if</span>(exist.size() &gt; k)&#123;<br>                exist.remove(nums[i]);<br>                curSum -= nums[i++];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(exist.size() == k)&#123;<br>                ans = Math.max(ans, curSum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O（N）：左右指针单调的从 <code>0-&gt;(n - 1)</code> 递增，循环次数总共只会有 <code>n</code> 次</li><li>空间复杂度：O（K）</li></ul><h2 id="滑动窗口-Map"><a href="#滑动窗口-Map" class="headerlink" title="滑动窗口 + Map"></a>滑动窗口 + Map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumSubarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Map&lt;Integer, Integer&gt; cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= k - <span class="hljs-number">1</span>; j++)&#123;<br>            cnt.put(nums[j], cnt.getOrDefault(nums[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            curSum += nums[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt.size() == k)&#123;<br>            ans = Math.max(ans, curSum);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = k; j &lt; n; i++, j++)&#123;<br>            curSum -= nums[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> cnt.get(nums[i - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span>(value == <span class="hljs-number">1</span>)&#123;<br>                cnt.remove(nums[i - <span class="hljs-number">1</span>]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cnt.put(nums[i - <span class="hljs-number">1</span>], value - <span class="hljs-number">1</span>);<br>            &#125;<br>            curSum += nums[j];<br>            cnt.put(nums[j], cnt.getOrDefault(nums[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(cnt.size() == k)&#123;<br>                ans = Math.max(ans, curSum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O（N）</li><li>空间复杂度：O（K）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-375.猜数字大小II</title>
    <link href="/2022/11/05/LC-375-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8FII/"/>
    <url>/2022/11/05/LC-375-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8FII/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/">leetcode 中等题</a></p><p>我们正在玩一个猜数游戏，游戏规则如下：</p><p>我从 1 到 n 之间选择一个数字。</p><ol><li>你来猜我选了哪个数字。</li><li>如果你猜到正确的数字，就会赢得游戏 。</li><li>如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。</li><li>每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。</li></ol><p>给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2<br>输出：1<br>解释：有两个可能的数字<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 2 </span>。<br>- 你可以先猜<span class="hljs-number"> 1 </span>。<br>    - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。<br>    - 如果我的数字更大，那么这个数字一定是<span class="hljs-number"> 2 </span>。你猜测数字为<span class="hljs-number"> 2 </span>并赢得游戏，总费用为 $1 。<br>最糟糕的情况下，你需要支付 $1 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">0</span><br>解释：只有一个可能的数字，所以你可以直接猜 <span class="hljs-number">1</span> 并赢得游戏，无需支付任何费用。<br></code></pre></td></tr></table></figure><p>提示:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= n &lt;= <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h2 id="递归-TLE"><a href="#递归-TLE" class="headerlink" title="递归(TLE)"></a>递归(TLE)</h2><p>枚举所有选择，以及对应答案的所有可能，稳 TLE，需要优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt;= end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++)&#123;<br>            <span class="hljs-comment">// 无法决策答案是哪个数，只能取最差情况，因为要确保获胜</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Math.max(dfs(start, i - <span class="hljs-number">1</span>), dfs(i + <span class="hljs-number">1</span>, end)) + i;<br>            <span class="hljs-comment">// 可以决策要猜哪个数，取最好的情况</span><br>            ans = Math.min(ans, cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>容易发现计算的结果其实只跟区间的开始以及结束有关（即 dfs 的入参），同时又因为数据范围只有 1-200 ，所以可以通过一个二维数组 <code>cache</code> 来保存计算过的结果来避免重复计算，<code>cache[i][j]</code> 表示 i 到 j 范围的数确保获胜的最小现金数， <code>cache[1][n]</code> 为题目所求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] cache;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt;= end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cache[start][end] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> cache[start][end];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++)&#123;<br>            <span class="hljs-comment">// 无法决策答案是哪个数，只能取最差情况，因为要确保获胜</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Math.max(dfs(start, i - <span class="hljs-number">1</span>), dfs(i + <span class="hljs-number">1</span>, end)) + i;<br>            <span class="hljs-comment">// 可以决策要猜哪个数，取最好的情况</span><br>            ans = Math.min(ans, cur);<br>        &#125;<br>        cache[start][end] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间-DP"><a href="#区间-DP" class="headerlink" title="区间 DP"></a>区间 DP</h2><p>我们发现在求解 <code>[start, end]</code> 区间时，假设当前选择的数是 <code>i</code>，那么只会依赖区间 <code>[start, i - 1]</code> 和 <code>[ i + 1, end]</code>，同时还具有以下几点性质：</p><ol><li>每次在求解某个区间的结果时，只会依赖更小的区间</li><li><code>f(start, end)</code> 下某个 <code>i</code> 最小成本 &#x3D; <code>max(f(start, i - 1), f(i + 1, end)) + i</code></li><li>如果 <code>start == end</code>，那么最小成本为 0，如果 <code>start + 1 == end</code>, 那么最小成本为 <code>start</code></li></ol><p>由第 1 点可知在求解区间需要逆推，从 <code>[n - 2, n]</code> 开始扩散区间直到求出 <code>[1, n]</code>，整个过程如下：</p><p><code>[n - 2, n - 2 + 2] -&gt; [n - 3, n - 1] -&gt; [n - 3, n] -&gt; ... -&gt; [1, n]</code> </p><p>而由第 3 点我们可以先得到所有 <code>start + 1 &lt;= end</code> 的区间结果，那么在求解其他所有区间的过程中就可以通过第 2 点的式子以及第 3 点的结果逐步得出所有区间的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>             dp[i][i + <span class="hljs-number">1</span>] = i; <span class="hljs-comment">// 初始化所有 start + 1 &lt;= end 区间的结果</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--)&#123; <span class="hljs-comment">// 从小区间开始逐渐扩散</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">2</span>; j &lt;= n; j++)&#123; <br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i; x &lt;= j; x++)&#123; <span class="hljs-comment">// 枚举猜的数</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Math.max(dp[i][x - <span class="hljs-number">1</span>], dp[x + <span class="hljs-number">1</span>][j]) + x; <span class="hljs-comment">// 无法决策答案是哪个数，只能取最差情况，因为要确保获胜</span><br>                    cur = Math.min(cur, t); <span class="hljs-comment">// 取枚举出来的猜某个数的最好结果</span><br>                &#125;<br>                dp[i][j] = cur;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][n];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-10-I.斐波那契数列</title>
    <link href="/2022/11/04/LC-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <url>/2022/11/04/LC-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">leetcode 简单题</a></p><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>,   <span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(N)</span></span> = <span class="hljs-built_in">F</span>(N - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(N - <span class="hljs-number">2</span>), 其中 N &gt; <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007）</p><h2 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1E9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (a + b) % MOD; <br>            a = b;<br>            b = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>对于数列递推问题，可以使用矩阵快速幂进行加速，矩阵快速幂的时间复杂度能够突破线性达到 <code>O(logN)</code>。</p><p><a href="https://oi-wiki.org/math/binary-exponentiation/">OI-WIKI-快速幂</a>　　<a href="https://oi-wiki.org/math/linear-algebra/matrix/#%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95">OI-WIKI-矩阵乘法</a>　　<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247488198&idx=1&sn=8272ca6b0ef6530413da4a270abb68bc&chksm=fd9cb9d9caeb30cf6c2defab0f5204adc158969d64418916e306f6bf50ae0c38518d4e4ba146&token=1067450240&lang=zh_CN#rd">宫水三叶-矩阵快速幂</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1E9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">long</span>[][] matrix = &#123;<br>                &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>                &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;<br>        &#125;;<br>        <span class="hljs-type">long</span>[][] ans = &#123;<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br>        &#125;; <span class="hljs-comment">// 矩阵中的1，对角线为1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((k &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>                ans = mul(matrix, ans); <span class="hljs-comment">// 快速幂，将对应二进制位为 1 时的整系数幂乘起来</span><br>            &#125;<br>            matrix = mul(matrix, matrix);<br>            k &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(ans[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] % MOD); <span class="hljs-comment">// 实际上为 ans[0][0] * f(1) + ans[0][1] * f(0)</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span>[][] mul(<span class="hljs-type">long</span>[][] matrix1, <span class="hljs-type">long</span>[][] matrix2) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix1.length;<br>        <span class="hljs-type">long</span>[][] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                ret[i][j] = (((matrix1[i][<span class="hljs-number">0</span>] * matrix2[<span class="hljs-number">0</span>][j]) % MOD) + ((matrix1[i][<span class="hljs-number">1</span>] * matrix2[<span class="hljs-number">1</span>][j]) % MOD)) % MOD; <span class="hljs-comment">// 同余</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>矩阵快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-464.我能赢吗</title>
    <link href="/2022/11/03/LC-464-%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97/"/>
    <url>/2022/11/03/LC-464-%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/can-i-win/submissions/">leetcode 中等题</a></p><p>两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过  100 的玩家，即为胜者。</p><p>两位玩家不能使用重复的整数 </p><p>给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家是否能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。</p><p>示例 1:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：maxChoosableInteger = 10, desiredTotal = 11<br>输出：false<br>解释：<br>无论第一个玩家选择哪个整数，他都会失败。<br>第一个玩家可以选择从<span class="hljs-number"> 1 </span>到<span class="hljs-number"> 10 </span>的整数。<br>如果第一个玩家选择 1，那么第二个玩家只能选择从<span class="hljs-number"> 2 </span>到<span class="hljs-number"> 10 </span>的整数。<br>第二个玩家可以通过选择整数 10（那么累积和为<span class="hljs-number"> 11 </span>&gt;= desiredTotal），从而取得胜利.<br>同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">maxChoosableInteger</span> = <span class="hljs-number">10</span>, <span class="hljs-attr">desiredTotal</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">maxChoosableInteger</span> = <span class="hljs-number">10</span>, <span class="hljs-attr">desiredTotal</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= maxChoosableInteger &lt;= <span class="hljs-number">20</span><br><span class="hljs-symbol">0 </span>&lt;= desiredTotal &lt;= <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><h2 id="递归-TLE"><a href="#递归-TLE" class="headerlink" title="递归 (TLE)"></a>递归 (TLE)</h2><p>最无脑的做法是直接递归, 用一个 <code>List</code> 来模拟选数的情况，每次选走一个数时 <code>remove</code> 掉对应元素即可，但同时因为要找到最优决策，所以不能改变原集合，只能改变拷贝的 <code>List</code>（如果直接对原集合 <code>remove</code> ，递归结束后不好还原，重新 <code>add</code> 会添加到集合末尾，那整个 for 循环遍历集合就不正确了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canIWin</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> dest)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(IntStream.rangeClosed(<span class="hljs-number">1</span>, n).boxed().collect(Collectors.toList()), dest);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; list, <span class="hljs-type">int</span> dest)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-keyword">if</span>(item &gt;= dest)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            List&lt;Integer&gt; copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list);<br>            copy.remove(i);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> dfs(copy, dest - item);<br>            <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="状态压缩-记忆化搜索"><a href="#状态压缩-记忆化搜索" class="headerlink" title="状态压缩 + 记忆化搜索"></a>状态压缩 + 记忆化搜索</h2><p>上面方案有问题的地方在于直接使用了 <code>List</code> 模拟选数过程，而整个递归过程是存在很多重复计算的，使用 <code>List</code> 无法进行记忆化搜索。</p><p>所以容易发现从一开始使用 <code>List</code> 就是一个 <strong>错误的思路</strong> 。</p><p>由于 n 数据范围为 20，且每个数只能被选择一次，所以我们可以 <strong>用一个 int (32位)</strong> 来表示选数的情况（<code>状态压缩</code>），对应二进制为 1 代表已被选择，否则代表未被选择。这种方案的好处在于很容易就能实现 <code>记忆化搜索</code>，不管是用 <code>int[1 &lt;&lt; 20]</code> 又或者是 <code>Map&lt;Integer, Integer&gt;</code> 。</p><p>整体实现的逻辑还是和上面的版本一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>]; <span class="hljs-comment">// int 的第 n 位为 1 代表 n - 1 被选择</span><br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canIWin</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> dest)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt; dest) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 依题意平手算先出手的玩家输</span><br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, dest) == <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> state, <span class="hljs-type">int</span> dest)</span>&#123;<br>        <span class="hljs-keyword">if</span>(cache[state] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> cache[state];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(((state &gt;&gt; (i - <span class="hljs-number">1</span>)) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">// 玩家不能重复使用整数</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i &gt;= dest)&#123;<br>                <span class="hljs-keyword">return</span> cache[state] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dfs((state | (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>))), dest - i) == -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> cache[state] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cache[state] = -<span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串哈希</title>
    <link href="/2022/11/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <url>/2022/11/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<br><a href="https://oi-wiki.org/string/hash/">OI-WIKI-# 字符串哈希</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247489813&idx=1&sn=7f3bc18ca390d85b17655f7164d8e660">宫水三叶-# 字符串哈希入门</a><br><a href="https://leetcode.cn/problems/repeated-dna-sequences/">Leetcode-187重复的 DNA 序列</a></p></blockquote><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>具体来说，哈希函数最重要的性质可以概括为下面两条：</p><ol><li><p>在 Hash 函数值不一样的时候，两个字符串一定不一样；</p></li><li><p>在 Hash 函数值一样的时候，两个字符串不一定一样（哈希冲突&#x2F;碰撞。但大概率一样，且我们当然希望它们总是一样的）。</p></li></ol><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>我们需要关注的是什么？</p><p>时间复杂度和 Hash 的准确率。</p><p>通常我们采用的是<strong>多项式 Hash</strong>的方法，对于一个长度为 L 的字符串 s 来说，我们可以这样定义多项式 Hash 函数：</p><p><img src="/img/20221001012815.png"></p><p>这种情况下，对于字符串 xyz ，其哈希函数值为 xb^2 + yb + z。</p><p>对于该 Hash 函数的参考实现如下(（效率低下的版本，实际使用时一般不会这么写）)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">233</span>; <br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll; <br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_hash</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span> </span>&#123; <br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123; <br>res = (ll)(res * B + s[i]) % M; <br>&#125; <br><span class="hljs-keyword">return</span> res; <br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">const</span> string&amp; t)</span> </span>&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">get_hash</span>(s) == <span class="hljs-built_in">get_hash</span>(t); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多次询问子串哈希"><a href="#多次询问子串哈希" class="headerlink" title="多次询问子串哈希"></a>多次询问子串哈希</h2><p>单次计算一个字符串的哈希值复杂度是 O(n)，其中 n 为串长，与暴力匹配没有区别，如果需要多次询问一个字符串的子串的哈希值，每次重新计算效率会非常低下。</p><p>一般采取的方法是对整个字符串先 <strong>预处理出每个前缀的哈希值(设该数组为H)</strong> ，将哈希值看成一个 b 进制的数对 m 取模的结果，这样的话可以做到快速求出子串的哈希。</p><p>首先对于F(s[1, i]) ，即原串长度为 i 的前缀（即子串s[1, i]）的哈希值 <strong>(即H[i])</strong> ，按照定义为</p><p><strong>F(s[1, i])  &#x3D; s[1] * b^ (i - 1) + s[2] * b ^ (i - 2) + … + s[i - 1] * b +s[i]</strong> </p><p>现在，我们想要用类似前缀和的方式快速求出子串 s[L, R] 的哈希值即 F(s[L, R])，按照定义哈希值为</p><p><strong>F(s[L, R])  &#x3D; s[L] * b^ (R - L) + s[L + 1] * b ^ (R - L - 1) + … + s[R - 1] * b +s[R]</strong></p><p>对比观察上述两个式子，可以发现 <code>式2</code> 其实可以由 <code>式1</code> 得出，即<br><strong>F(s[L, R])  &#x3D; F(s[1, R]) - F(s[1, L-1]) * b ^ (r - L + 1)</strong> </p><p>那么即字串 S[L, R] 的哈希值等于 H[R] - H[L-1] * B ^ (R - L +1)</p><p>而 B ^ (r - L + 1)  又可以通过 O(n) 的预处理出次方数组，以实现 O(1) 的回答每次询问</p><p>实现，<a href="https://leetcode.cn/problems/repeated-dna-sequences/">Leetcode187</a>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-number">131313</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] POWER = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M]; <span class="hljs-comment">// 次方数组  </span><br>  <br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findRepeatedDnaSequences</span><span class="hljs-params">(String s)</span> &#123;  <br>        <span class="hljs-type">int</span>[] hashTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length() + <span class="hljs-number">1</span>];  <br>        POWER[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++)&#123;  <br>            <span class="hljs-comment">// 预处理前缀哈希数组  </span><br>            hashTable[i] = hashTable[i - <span class="hljs-number">1</span>] * B + s.charAt(i - <span class="hljs-number">1</span>) % M;  <br>            <span class="hljs-comment">// 预处理次方数组</span><br>            POWER[i] = POWER[i - <span class="hljs-number">1</span>] * B;  <br>        &#125;  <br>        Map&lt;Integer, Integer&gt; countMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length() - <span class="hljs-number">10</span> + <span class="hljs-number">1</span>; i++)&#123;  <br>            <span class="hljs-comment">// 子串哈希等于 h(r) - h(l - 1) * b ^ (r - l + 1)            </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hashTable[i + <span class="hljs-number">9</span> + <span class="hljs-number">1</span>] - hashTable[i] * POWER[i + <span class="hljs-number">9</span> - i + <span class="hljs-number">1</span>];  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> countMap.merge(hash, <span class="hljs-number">0</span>, (oldValue, __) -&gt; ++oldValue);  <br>            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">1</span>)&#123;  <br>                ans.add(s.substring(i, i + <span class="hljs-number">10</span>));  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> ans;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collector-and-Stream.reduce()</title>
    <link href="/2022/11/03/Collector-and-Stream.reduce()/"/>
    <url>/2022/11/03/Collector-and-Stream.reduce()/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://leetcode.cn/problems/reformat-phone-number/">删除字符串中的破折号和空字符</a></p><blockquote><p>当然，最简洁的方式是<br>        String s &#x3D; number.replace(“ “, “”).replace(“-“, “”);<br>但这里暂时忽略这种方案，只是为了指出该背景</p></blockquote><p>一种较复杂的方案是使用 Stream，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">justCase</span><span class="hljs-params">(String str)</span>&#123;  <br>    <span class="hljs-keyword">return</span> str.chars()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>)<br>            .collect(Collector.of(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    (__, ___) -&gt; &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;un support parallel stream&quot;</span>);&#125;,<br>                    StringBuilder::toString));  <br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，要将字符数组重新收集成 <code>String</code> 的合理做法应该只有使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">.collect(supplier,  accumulator,  combiner);<br><span class="hljs-comment">// or</span><br>.collect(Collector.of());  <br></code></pre></td></tr></table></figure><p>其余做法例如 <code>mapToObj(String::valueOf).collect(joining)</code> 会频繁创建 String；<br>而 <code>reduce</code> 严格来讲既不是<strong>可变规约</strong>也没有简洁多少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">justCase</span><span class="hljs-params">(String str)</span>&#123;  <br>    <span class="hljs-keyword">return</span>  str.chars().parallel()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>)  <br>            .reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(),  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString();  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实例化-CollectorImpl"><a href="#实例化-CollectorImpl" class="headerlink" title="实例化 CollectorImpl"></a>实例化 CollectorImpl</h2><blockquote><p>这里只对 <code>Collector</code> 做该话题下的简单介绍，详细知识见 javadocs</p></blockquote><p>Collector 接口由四个抽象函数指定，这些函数协同工作以将条目累积到可变结果容器中，并可选择对结果执行最终转换。他们是：</p><ul><li>supplier() ：创建一个新的结果容器</li><li>accumulator() ：将新数据元素合并到结果容器中</li><li>combiner()：将两个结果容器合并为一个（  ）</li><li>finisher() ：对容器执行可选的最终转换</li></ul><p><code>Collector</code> 接口在 JDK 中的实现类位于 <code>Collectors.CollectorImpl</code><br>而实例化  <code>CollectorImpl</code> 有两种途径：</p><ul><li>通过 <code>Collectors</code> 类预定义的例如 <code>Collectors.toList()</code> 等静态工厂方法实例化</li><li>通过 <code>Collector</code> 接口中暴露出的两种 <code>Collector.of</code> 方法实例化：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collector</span>&lt;T, A, R&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T, R&gt; Collector&lt;T, R, R&gt; <span class="hljs-title function_">of</span><br><br><span class="hljs-params">(Supplier&lt;R&gt; supplier,  </span><br><span class="hljs-params">                                          BiConsumer&lt;R, T&gt; accumulator,  </span><br><span class="hljs-params">                                          BinaryOperator&lt;R&gt; combiner,  </span><br><span class="hljs-params">                                          Characteristics... characteristics)</span> <br>                                          <br>                                          &#123;...&#125;<br>                                          <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T, A, R&gt; Collector&lt;T, A, R&gt; <span class="hljs-title function_">of</span><br>    <br><span class="hljs-params">(Supplier&lt;A&gt; supplier,  </span><br><span class="hljs-params">                                             BiConsumer&lt;A, T&gt; accumulator,  </span><br><span class="hljs-params">                                             BinaryOperator&lt;A&gt; combiner,  </span><br><span class="hljs-params">                                             Function&lt;A, R&gt; finisher,  </span><br><span class="hljs-params">                                             Characteristics... characteristics)</span><br><br>                                             &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>可以看到，<code>Collector</code> 接口只提供了两种重载用于实例化 <code>CollectorImpl</code><br>并且这两种重载都必须传入 <code>supplier</code> 、<code>accmulator</code> 以及 <code>combiner</code>，前两个参数很好理解，毕竟 <code>CollectorImpl</code> 不好对此提供默认的实现<br>但是对于组合器  <code>combiner</code>，<strong>由于组合器只有在执行并发规约时会使用到</strong>，也就是说，对于上面场景下的收集器（即不考虑使用并发流的场景），提供一个 <code>combiner</code> 并没有实际意义</p><h2 id="为什么必须提供-combiner"><a href="#为什么必须提供-combiner" class="headerlink" title="为什么必须提供 combiner"></a>为什么必须提供 combiner</h2><p>在<a href="https://stackoverflow.com/questions/24308146/why-is-a-combiner-needed-for-reduce-method-that-converts-type-in-java-8/24316429#24316429">该问题中</a>，发现这种操作在 <code>Scala</code> 中被称为<code>foldLeft</code>。需要注意的是，Java 的库函数中并没有提供等效于 <code>foldLeft</code> 的实现。</p><blockquote><p>在上面的回答中提到：<br>Finally, Java doesn’t provide <code>foldLeft</code> and <code>foldRight</code> operations because they imply a particular ordering of operations that is inherently sequential. This clashes with the design principle stated above of providing APIs that support sequential and parallel operation equally.<br>最后，Java 不提供<code>foldLeft</code>and<code>foldRight</code>操作，因为它们暗示了一种特定的操作顺序，这种顺序本质上是顺序的。这与上述提供同样支持顺序和并行操作的 API 的设计原则相冲突。</p></blockquote><p>虽然该说法有一定说服力，但还是继续搜索了为什么 Java 没有提供 <code>foldLeft</code>，试图继续理解所提到的<code>设计原则</code>。<br>但是结果却找到了<a href="https://bugs.openjdk.org/browse/JDK-8292845">JDK-8292845</a>和<a href="https://bugs.openjdk.org/browse/JDK-8292845">JDK-8292845</a>，但在这两个增强请求中，却没有对相关<code>设计原则</code>进行讨论，而是计划会在将来对此进行实现。</p><p>也许在不久的将来，就会有一种更合理的 folding operations 可以替换上方看似不合理的实现</p><h2 id="reduce-vs-collect"><a href="#reduce-vs-collect" class="headerlink" title="reduce vs collect"></a>reduce vs collect</h2><p>先看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">justCase</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a-b&quot;</span>;  s<br>    Function&lt;String, Stream&lt;Character&gt;&gt; function = str -&gt; str.chars()  <br>            .parallel()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>);  <br>  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(),  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString(); <span class="hljs-comment">// baba  </span><br>  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .collect(Collector.of(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    StringBuilder::append,  <br>                    StringBuilder::toString)); <span class="hljs-comment">// ab</span><br>                    <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .collect(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString(); <span class="hljs-comment">// ab</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现在 <code>parallel stream</code> 下 <code>reduce()</code> 的输出并不符合我们的预期，先查看 <code>reduce()</code> 的方法注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java">...<br> identity值必须是组合器函数的标识。这意味着对于所有u ，<br>     combiner(identity , u) == u<br> 此外， combiner函数必须与accumulator函数兼容；对于所有u和t ，必须满足以下条件：<br>     combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)<br>...<br><br>&lt;U&gt; U <span class="hljs-title function_">reduce</span><span class="hljs-params">(U identity,  BiFunction&lt;U, ? <span class="hljs-built_in">super</span> T, U&gt; accumulator,  BinaryOperator&lt;U&gt; combiner)</span>;<br></code></pre></td></tr></table></figure><p>对这里的约定进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">justCase</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// combiner(identity , u) == u  </span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">identity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(<span class="hljs-string">&#x27;b&#x27;</span>);  <br>BinaryOperator&lt;StringBuilder&gt; combiner = StringBuilder::append;  <br><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply0</span> <span class="hljs-operator">=</span> combiner.apply(identity, u);  <br>log.debug(String.valueOf(apply0.toString().equals(u.toString()))); <span class="hljs-comment">// true  </span><br><br><br><span class="hljs-comment">// combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)  </span><br><span class="hljs-type">Object</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;  <br>BiFunction&lt;StringBuilder, Object, StringBuilder&gt; acc = StringBuilder::append;  <br>  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply1</span> <span class="hljs-operator">=</span> acc.apply(identity, t);  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply2</span> <span class="hljs-operator">=</span> combiner.apply(u, apply1);  <br>  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply3</span> <span class="hljs-operator">=</span> acc.apply(u, t);  <br><br>log.debug(String.valueOf(apply2.toString().equals(apply3.toString()))); <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现我们的用例其实是符合 <code>reduce()</code> 方法在 javadocs 中的约定的，于是继续查看相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 使用提供的标识、累积和组合函数对该流的元素执行 归约 </span><br>reduce(U identity, BiFunction&lt;U,? <span class="hljs-built_in">super</span> T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)<br><br><span class="hljs-comment">// 对此流的元素执行 可变归约 操作</span><br>collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? <span class="hljs-built_in">super</span> T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)<br></code></pre></td></tr></table></figure><p>会发现这其实是因为 <code>reduce()</code> 只是 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#ReductionOperations">Reduction operations</a> 导致的（而 <code>StringBuilder</code> 是可变对象），在该场景下应该使用  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#MutableReduction">Mutable reduction(可变规约)</a> ，也就是 <code>collect()</code></p><p>实际上仔细查看代码会发现 <code>reduce</code> 和 <code>collect</code> 的累加器 <code>accumulator</code> 定义也并不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// Reduction operations 在累加器中返回处理结果，处理结果的类型不能是可变的</span><br>reduce(... BiFunction&lt;U, ? <span class="hljs-built_in">super</span> T, U&gt; accumulator...)<br><span class="hljs-comment">// Mutable reduction(可变规约) 在累加器中不返回处理结果而是通过修改可变容器本身</span><br>collect(...BiConsumer&lt;R, ? <span class="hljs-built_in">super</span> T&gt; accumulator...) <br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#MutableReduction">Mutable reduction(可变规约)</a></p><p><a href="https://stackoverflow.com/questions/56023452/how-does-reduce-method-work-with-parallel-streams-in-java-8">how-does-reduce-method-work-with-parallel-streams-in-java-8</a></p><blockquote><p>The problem lies in you using Stream::reduce for mutable reduction.<br>You should instead use Stream::collect</p></blockquote><p><a href="https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce/38728166#38728166">java-8-streams-collect-vs-reduce</a></p><blockquote><p>The reason is simply that:</p><ul><li>collect() can only work with mutable result objects.</li><li>reduce() is designed to work with immutable result objects.</li></ul></blockquote><p><a href="https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce/22577274#22577274">java-8-streams-collect-vs-reduce</a></p><blockquote><p>reduce是一个“折叠”操作，它将二元运算符应用于流中的每个元素，其中运算符的第一个参数是前一个应用程序的返回值，第二个参数是当前流元素。<br>collect是一种聚合操作，其中创建“集合”并将每个元素“添加”到该集合中。然后将流中不同部分的集合添加到一起。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
