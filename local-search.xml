<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LC1687.从仓库到码头运输箱子</title>
    <link href="/2022/12/08/LC1687-%E4%BB%8E%E4%BB%93%E5%BA%93%E5%88%B0%E7%A0%81%E5%A4%B4%E8%BF%90%E8%BE%93%E7%AE%B1%E5%AD%90/"/>
    <url>/2022/12/08/LC1687-%E4%BB%8E%E4%BB%93%E5%BA%93%E5%88%B0%E7%A0%81%E5%A4%B4%E8%BF%90%E8%BE%93%E7%AE%B1%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/">leetcode 困难题</a></p><p>你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有 箱子数目的限制 和 总重量的限制 。</p><p>给你一个箱子数组 boxes 和三个整数 portsCount, maxBoxes 和 maxWeight ，其中 boxes[i] &#x3D; [ports​​i​, weighti] 。</p><p>ports​​i 表示第 i 个箱子需要送达的码头， weightsi 是第 i 个箱子的重量。<br>portsCount 是码头的数目。<br>maxBoxes 和 maxWeight 分别是卡车每趟运输箱子数目和重量的限制。<br>箱子需要按照 数组顺序 运输，同时每次运输需要遵循以下步骤：</p><p>卡车从 boxes 队列中按顺序取出若干个箱子，但不能违反 maxBoxes 和 maxWeight 限制。<br>对于在卡车上的箱子，我们需要 按顺序 处理它们，卡车会通过 一趟行程 将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 额外行程 ，箱子也会立马被卸货。<br>卡车上所有箱子都被卸货后，卡车需要 一趟行程 回到仓库，从箱子队列里再取出一些箱子。<br>卡车在将所有箱子运输并卸货后，最后必须回到仓库。</p><p>请你返回将所有箱子送到相应码头的 最少行程 次数。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6<br>输出：6<br>解释：最优策略如下：<br>- 卡车首先运输第一个箱子，到达码头<span class="hljs-number"> 1 </span>，然后回到仓库，总共<span class="hljs-number"> 2 </span>趟行程。<br>- 卡车运输第二、第三、第四个箱子，到达码头<span class="hljs-number"> 3 </span>，然后回到仓库，总共<span class="hljs-number"> 2 </span>趟行程。<br>- 卡车运输第五个箱子，到达码头<span class="hljs-number"> 2 </span>，回到仓库，总共<span class="hljs-number"> 2 </span>趟行程。<br>总行程数为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 6 </span>。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= boxes.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= portsCount, maxBoxes, maxWeight &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= ports​​i &lt;= portsCount<br><span class="hljs-symbol">1 </span>&lt;= weightsi &lt;= maxWeight<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>以下前缀和或 $dp$ 数组为了方便下标都从 $1$ 开始到 $n$ 结束。</p><p>定义 $w$ 为重量前缀和数组；$diff$ 为“相邻不相等码头”前缀和数组，即 $diff[j]$ 表示 $[0, j]$ 区间箱子的相邻不相等码头的和。</p><p>利用 $diff$ 可以 $O(1)$ 的求出一趟车的最小行程，设该趟车第一个箱子为 $x$ ，最后一个箱子为 $y$ ，那么该趟的最小行程为 $diff[y] - diff[x] + 2$，其中 $2$ 是因为汽车离开仓库和返回仓库所消耗行程。</p><p>定义 $dp[i]$ 表示 $[0, i - 1]$ 区间箱子的最少行程数，$i - 1$ 显然为某趟车的最后一个箱子下标，那么 $dp[n]$ 为答案。</p><p>具体转移过程如下，对于每个 $dp[i]$，枚举上一趟车最后一个箱子的可能性 $dp[j]$，那么其在 $boxes$ 中的下标为 $j - 1$ ，也就是说 $j$ 为该趟车第一个箱子，简略的转移方程为： </p><p>$$<br>\begin{align}<br>&amp;dp(i) &#x3D; max(dp[j] + diff[i - 1] - diff[j] + 2) 　　　　　　　max(0, i - maxBoxes) &lt;&#x3D; j &lt; i\\<br>\end{align}<br>$$</p><p>该解法时间复杂度为 $O(N^2)$ ，会 TLE 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">boxDelivering</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] boxes, <span class="hljs-type">int</span> portsCount, <span class="hljs-type">int</span> maxBoxes, <span class="hljs-type">int</span> maxWeight)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> boxes.length;<br>        <span class="hljs-type">int</span>[] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 实际运算中，这里 n 下标并没有用到</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            w[i] = w[i - <span class="hljs-number">1</span>] + boxes[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            diff[i] = i == n || boxes[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == boxes[i][<span class="hljs-number">0</span>] ? diff[i - <span class="hljs-number">1</span>] : diff[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// dp[i] 表示 i 个箱子的最少行程数</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, Integer.MAX_VALUE);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, i - maxBoxes); j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(w[i] - w[j] &gt; maxWeight)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i] = Math.min(dp[i], dp[j] + diff[i - <span class="hljs-number">1</span>] - diff[j] + <span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划-单调队列"><a href="#动态规划-单调队列" class="headerlink" title="动态规划 + 单调队列"></a>动态规划 + 单调队列</h2><p>观察上面的转移过程可知，内层循环实际上是在 $[max(0, i - maxBoxes), i - 1]$ 窗口内找到一个满足要求的 $dp[j] - diff[j]$ 最小值，所以我们可以利用单调队列来实现 $O(1)$ 获取最小值。</p><p>每个下标最多进队一次出队一次，内层最多总共循环 $n$ 次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">boxDelivering</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] boxes, <span class="hljs-type">int</span> portsCount, <span class="hljs-type">int</span> maxBoxes, <span class="hljs-type">int</span> maxWeight)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> boxes.length;<br>        <span class="hljs-type">int</span>[] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            w[i] = w[i - <span class="hljs-number">1</span>] + boxes[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            diff[i] = i == n || boxes[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == boxes[i][<span class="hljs-number">0</span>] ? diff[i - <span class="hljs-number">1</span>] : diff[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// dp[i] 表示 i 个箱子的最少行程数</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        deque.offerLast(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; (i - deque.peekFirst() &gt; maxBoxes || w[i] - w[deque.peekFirst()] &gt; maxWeight))&#123;<br>                deque.pollFirst();<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> deque.peekFirst(); <span class="hljs-comment">// If NPE, there is no legal solution.</span><br>            dp[i] = dp[min] + diff[i - <span class="hljs-number">1</span>] - diff[min] + <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; (dp[i] - diff[i] &lt; dp[deque.peekLast()] - diff[deque.peekLast()]))&#123;<br>                deque.pollLast();<br>            &#125;<br>            deque.offerLast(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1775.通过最少操作次数使数组的和相等</title>
    <link href="/2022/12/08/LC-1775-%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89/"/>
    <url>/2022/12/08/LC-1775-%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/">leetcode 中等题</a></p><p>给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。</p><p>每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。</p><p>请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。</p><p>示例1：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">3</span><br>解释：你可以通过 <span class="hljs-number">3</span> 次操作使 <span class="hljs-symbol">nums1</span> 中所有数的和与 <span class="hljs-symbol">nums2</span> 中所有数的和相等。以下数组下标都从 <span class="hljs-number">0</span> 开始。<br>- 将 <span class="hljs-symbol">nums2</span>[<span class="hljs-number">0</span>] 变为 <span class="hljs-number">6</span> 。 <span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] 。<br>- 将 <span class="hljs-symbol">nums1</span>[<span class="hljs-number">5</span>] 变为 <span class="hljs-number">1</span> 。 <span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] 。<br>- 将 <span class="hljs-symbol">nums1</span>[<span class="hljs-number">2</span>] 变为 <span class="hljs-number">2</span> 。 <span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] 。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums1.length, nums2.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= nums1[i], nums2[i] &lt;= <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>设两个数组的和为 $sum1$ 、$sum2$，两者的差为 $diff$ 。</p><p>并且为了不失一般性，我们使 $nums1$ 的和始终是大于 $nums2$ 的。</p><p>因为需要通过最少次数使两个数组和相等，也就是使 $diff$ 尽快小于 $0$。那么为了更快的减少 $diff$ ，显然我们只能令 $nums1$ 中的某个数 $x$ 变成 $max(1, x - diff))$，这样一来 $x$ 对 $diff$ 贡献即为 $x - max(1, x - diff)$，同样为了更快的减少 $diff$ ，我们要尽可能的从更大贡献值的 $x$ 开始操作；对于 $num2$ 也同理，近似的改成相反操作即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        Map&lt;Integer, Integer&gt; count1 = Arrays.stream(nums1).boxed().collect(Collectors.toMap(Function.identity(), k -&gt; <span class="hljs-number">1</span>, Integer::sum));<br>        Map&lt;Integer, Integer&gt; count2 = Arrays.stream(nums2).boxed().collect(Collectors.toMap(Function.identity(), k -&gt; <span class="hljs-number">1</span>, Integer::sum));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> Arrays.stream(nums1).sum() - Arrays.stream(nums2).sum();<br>        <span class="hljs-keyword">if</span>(diff &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 为了统一, 让 count1 始终大于 count2</span><br>            diff = -diff;<br>            Map&lt;Integer, Integer&gt; tempMap = count1;<br>            count1 = count2;<br>            count2 = tempMap;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(diff &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> ans;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> count1.entrySet().stream().filter(e -&gt; e.getValue() &gt; <span class="hljs-number">0</span>).map(Map.Entry::getKey).mapToInt(Integer::valueOf).max().orElseThrow();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> count2.entrySet().stream().filter(e -&gt; e.getValue() &gt; <span class="hljs-number">0</span>).map(Map.Entry::getKey).mapToInt(Integer::valueOf).min().orElseThrow();<br>            <span class="hljs-keyword">while</span>(max - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">6</span> - min &amp;&amp; diff &gt; <span class="hljs-number">0</span> &amp;&amp; count1.getOrDefault(max, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">1</span>, max - diff);<br>                <span class="hljs-keyword">if</span>(max == to)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                diff -= max - to;<br>                count1.compute(max, (key, old) -&gt; --old);<br>                count1.compute(to, (key, old) -&gt; old == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : ++old);<br>                ans++;<br>                max = count1.entrySet().stream().filter(e -&gt; e.getValue() &gt; <span class="hljs-number">0</span>).map(Map.Entry::getKey).mapToInt(Integer::valueOf).max().orElseThrow();<br>            &#125;<br>            <span class="hljs-keyword">while</span>(max - <span class="hljs-number">1</span> &lt; <span class="hljs-number">6</span> - min &amp;&amp; diff &gt; <span class="hljs-number">0</span> &amp;&amp; count2.getOrDefault(min, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> Math.min(<span class="hljs-number">6</span>, min + diff);<br>                <span class="hljs-keyword">if</span>(min == to)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                diff -= to - min;<br>                count2.compute(min, (key, old) -&gt; --old);<br>                count2.compute(to, (key, old) -&gt; old == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : ++old);<br>                ans++;<br>                min = count2.entrySet().stream().filter(e -&gt; e.getValue() &gt; <span class="hljs-number">0</span>).map(Map.Entry::getKey).mapToInt(Integer::valueOf).min().orElseThrow();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ans == temp)&#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表优化"><a href="#哈希表优化" class="headerlink" title="哈希表优化"></a>哈希表优化</h2><p>上面的解法代码过于复杂，我们可以通过哈希表来存储不同元素对于 $diff$ 的贡献，这样一来只需要从大到小遍历贡献值以减少 $diff$ 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        Map&lt;Integer, Integer&gt; count1 = Arrays.stream(nums1).boxed().collect(Collectors.toMap(Function.identity(), k -&gt; <span class="hljs-number">1</span>, Integer::sum));<br>        Map&lt;Integer, Integer&gt; count2 = Arrays.stream(nums2).boxed().collect(Collectors.toMap(Function.identity(), k -&gt; <span class="hljs-number">1</span>, Integer::sum));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> Arrays.stream(nums1).sum() - Arrays.stream(nums2).sum();<br>        <span class="hljs-keyword">if</span>(diff &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 让 count1 始终大于 count2</span><br>            diff = -diff;<br>            Map&lt;Integer, Integer&gt; tempMap = count1;<br>            count1 = count2;<br>            count2 = tempMap;<br>        &#125;<br>        <span class="hljs-type">int</span>[] d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">7</span>]; <span class="hljs-comment">// 通过哈希表存储贡献值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>; i &gt;= <span class="hljs-number">2</span>; i--)&#123;<br>            d[i] += count1.getOrDefault(i, <span class="hljs-number">0</span>);<br>            d[i] += count2.getOrDefault(<span class="hljs-number">7</span> - i, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>; i &gt;= <span class="hljs-number">2</span> &amp;&amp; diff &gt; <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curCount</span> <span class="hljs-operator">=</span> Math.min(d[i], (diff + i - <span class="hljs-number">2</span>) / (i - <span class="hljs-number">1</span>)); <span class="hljs-comment">// 后者是 diff / (i - 1) 的向上取整</span><br>            ans += curCount;<br>            diff -= curCount * (i - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> diff &lt;= <span class="hljs-number">0</span> ? ans : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1774.最接近目标价格的甜点成本</title>
    <link href="/2022/12/04/LC-1774-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E4%BB%B7%E6%A0%BC%E7%9A%84%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC/"/>
    <url>/2022/12/04/LC-1774-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E4%BB%B7%E6%A0%BC%E7%9A%84%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/closest-dessert-cost/">leetcode 中等题</a></p><p>你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。而制作甜点需要遵循以下几条规则：</p><ul><li>必须选择 一种 冰激凌基料。</li><li>可以添加 一种或多种 配料，也可以不添加任何配料。</li><li>每种类型的配料 最多两份 。</li></ul><p>给你以下三个输入：</p><ul><li>baseCosts ，一个长度为 n 的整数数组，其中每个 baseCosts[i] 表示第 i 种冰激凌基料的价格。</li><li>toppingCosts，一个长度为 m 的整数数组，其中每个 toppingCosts[i] 表示 一份 第 i 种冰激凌配料的价格。</li><li>target ，一个整数，表示你制作甜点的目标价格。<br>你希望自己做的甜点总成本尽可能接近目标价格 target 。</li></ul><p>返回最接近 target 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：baseCosts = [1,7], toppingCosts = [3,4], target = 10<br>输出：10<br>解释：考虑下面的方案组合（所有下标均从<span class="hljs-number"> 0 </span>开始）：<br>- 选择<span class="hljs-number"> 1 </span>号基料：成本 7<br>- 选择<span class="hljs-number"> 1 </span>份<span class="hljs-number"> 0 </span>号配料：成本<span class="hljs-number"> 1 </span>x<span class="hljs-number"> 3 </span>= 3<br>- 选择<span class="hljs-number"> 0 </span>份<span class="hljs-number"> 1 </span>号配料：成本<span class="hljs-number"> 0 </span>x<span class="hljs-number"> 4 </span>= 0<br>总成本：7 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 0 </span>=<span class="hljs-number"> 10 </span>。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">n</span> == baseCosts.length<br><span class="hljs-attribute">m</span> == toppingCosts.length<br><span class="hljs-attribute">1</span> &lt;= n, m &lt;= <span class="hljs-number">10</span><br><span class="hljs-attribute">1</span> &lt;= baseCosts[i], toppingCosts[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-attribute">1</span> &lt;= target &lt;= <span class="hljs-number">104</span><br></code></pre></td></tr></table></figure><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>对每一种基料利用回溯模拟每个方案的成本。对于每个基料，每种配料存在三种可能：不加入\加入一次\加入两次。并且显然当某个方案的成本超出了 $target$ 时，可以不再往下搜索，因为继续往下差距只会继续拉大。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] toppingCosts;<br>    <span class="hljs-type">int</span> target;<br>    <span class="hljs-type">int</span> ans;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closestCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] baseCosts, <span class="hljs-type">int</span>[] toppingCosts, <span class="hljs-type">int</span> target)</span> &#123;<br>       ans = Arrays.stream(baseCosts).min().getAsInt();<br>       <span class="hljs-built_in">this</span>.toppingCosts = toppingCosts;<br>       <span class="hljs-built_in">this</span>.target = target;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> item : baseCosts)&#123;<br>           dfs(<span class="hljs-number">0</span>, item); <br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> curCost)</span>&#123;<br>        <span class="hljs-keyword">if</span>(Math.abs(target - ans) &lt; Math.abs(target - curCost) &amp;&amp; target &lt; curCost)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Math.abs(target - ans) == Math.abs(target - curCost))&#123;<br>            ans = Math.min(ans, curCost);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Math.abs(target - ans) &gt; Math.abs(target - curCost))&#123;<br>            ans = curCost;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p == toppingCosts.length)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(p + <span class="hljs-number">1</span>, curCost);<br>        dfs(p + <span class="hljs-number">1</span>, curCost + toppingCosts[p]);<br>        dfs(p + <span class="hljs-number">1</span>, curCost + (toppingCosts[p] * <span class="hljs-number">2</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举-二分查找左边界"><a href="#枚举-二分查找左边界" class="headerlink" title="枚举 + 二分查找左边界"></a>枚举 + 二分查找左边界</h2><p>每种配料最多可以选两次，我们可以把每种配料看作存在两份，类似 $[top1, top2, top1, top2]$ ，那么对于某种方案，就可以视为拆分后每个配料只存在两种情况，加入或者不加入。接着我们可以枚举其中一半的拆分后配料的子集和，然后通过二分查找得到使总和最接近 $target$ 的另一半配料的成本和。</p><p>稍微要注意的是，这里我们通过二分查找搜索的是左边界，也就是说最接近的下标只可能是 $\{left, left - 1\}$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] toppingCosts;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">inf</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closestCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] baseCosts, <span class="hljs-type">int</span>[] toppingCosts, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.toppingCosts = toppingCosts;<br>        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        Collections.sort(arr);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> inf;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : baseCosts) &#123;<br>            <span class="hljs-comment">// 枚举子集和</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : arr) &#123;<br>                <span class="hljs-comment">// 二分查找</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> search(target - x - y);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;i, i - <span class="hljs-number">1</span>&#125;) &#123;<br>                    <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; arr.size()) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">curCost</span> <span class="hljs-operator">=</span> x + y + arr.get(j);<br>                        <span class="hljs-keyword">if</span> (Math.abs(ans - target) &gt; Math.abs(curCost - target) <br>                        || (Math.abs(ans - target) == Math.abs(curCost - target) &amp;&amp; ans &gt; curCost)) &#123;<br>                            ans = curCost;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= toppingCosts.length) &#123;<br>            arr.add(t);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(i + <span class="hljs-number">1</span>, t);<br>        dfs(i + <span class="hljs-number">1</span>, t + toppingCosts[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = arr.size();<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (arr.get(mid) &lt; x) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举-二分查找右边界"><a href="#枚举-二分查找右边界" class="headerlink" title="枚举 + 二分查找右边界"></a>枚举 + 二分查找右边界</h2><p>类似的，可以使用二分查找右边界的方法进行搜索，此时最接近的下标只可能是 $\{left - 1, left\}$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java">...<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closestCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] baseCosts, <span class="hljs-type">int</span>[] toppingCosts, <span class="hljs-type">int</span> target)</span> &#123;<br>                ...<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;i, i + <span class="hljs-number">1</span>&#125;) &#123;<br>                ...<br>    &#125;<br>...<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = arr.size();<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (arr.get(mid) &gt; x) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left - <span class="hljs-number">1</span>;<br>    &#125;<br>...<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>将问题转换成某个成本是否存在可行方案的问题，然后选择最接近目标的成本即可，此时问题转换成了 <code>01背包</code>。</p><p>$dp[i]$ 为 $true$ 表示 $i$ 成本存在可行方案，初始化为 $false$ 表示不存在。</p><p>当某个基料已经大于 $target$ 时，这种情况不应该选择配料，因为选择配料只会使差距更大，并且大于 target 的合法成本只需要保留最小的一份即可，所以背包容量设为 $target$ 即可。</p><p>并且由于单独选择基料是合法的，所以如果存在 $base[x] &#x3D; i$ ，那么 $dp[i] &#x3D; true$。</p><p>接下来类似 <code>01背包</code> 枚举配料的选择，由于每个配料最多选择两次，所以类似上面二分查找的解法，将每种配料视为存在两种。</p><p>任意一个合法方案加一份配料也为合法方案，所以当前配料成本为 $y$ 时，对于开销 $c$ ，转移方程为：</p><p>$$<br>\begin{align}<br>&amp;dp(c)　 |&#x3D;　dp(c - y)　　　　　　　　　　　　　　　　　　　 c &gt; y\\<br>\end{align}<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closestCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] base, <span class="hljs-type">int</span>[] top, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[target + <span class="hljs-number">5</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : base) &#123; <br>            <span class="hljs-keyword">if</span> (x &gt; target) ans = Math.min(ans, x); <span class="hljs-comment">// 只选基料</span><br>            <span class="hljs-keyword">else</span> dp[x] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : top) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123; <span class="hljs-comment">// 拆分成两份</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                    <span class="hljs-keyword">if</span> (dp[j] &amp;&amp; j + x &gt; target) ans = Math.min(ans, j + x); <span class="hljs-comment">// 大于 target 的合法成本只需要保留最小的一份即可</span><br>                    <span class="hljs-keyword">if</span> (j &gt; x) dp[j] |= dp[j - x];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> target; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span>(target - i &gt; ans - target)&#123;<br>                <span class="hljs-comment">// 剩余的只会比 ans 差距更大</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i]) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>回溯</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-895.最大频率栈</title>
    <link href="/2022/11/30/LC-895-%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/"/>
    <url>/2022/11/30/LC-895-%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximum-frequency-stack/">leetcode 困难题</a></p><p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。</p><p>实现 FreqStack 类:</p><ul><li>FreqStack() 构造一个空的堆栈。</li><li>void push(int val) 将一个整数 val 压入栈顶。</li><li>int pop() 删除并返回堆栈中出现频率最高的元素。<ul><li>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</li></ul></li></ul><p>示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;FreqStack&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>],<br>[[],[<span class="hljs-number">5</span>],[<span class="hljs-number">7</span>],[<span class="hljs-number">5</span>],[<span class="hljs-number">7</span>],[<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>],[],[],[],[]]<br>输出：[null,null,null,null,null,null,null,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-number">0</span> &lt;= val &lt;= <span class="hljs-number">109</span><br><span class="hljs-built_in">push</span> 和 <span class="hljs-built_in">pop</span> 的操作数不大于 <span class="hljs-number">2</span> * <span class="hljs-number">104</span>。<br>输入保证在调用 <span class="hljs-built_in">pop</span> 之前堆栈中至少有一个元素。<br></code></pre></td></tr></table></figure><h2 id="哈希表-大根堆"><a href="#哈希表-大根堆" class="headerlink" title="哈希表 + 大根堆"></a>哈希表 + 大根堆</h2><p>比较复杂的做法是使用哈希表 $indexListMap$ 维护元素和出现过的下标集合之间的映射关系，再使用大根堆维护元素之间的排序关系：出现频率更高的在队列首部，频率相同时取下标更大的。</p><p>缺点是由于相同元素在优先队列中只存储一次，所以每次 $push$ 或者 $pop$ 操作的时候都需要将当前元素从有限队列中移除后再重新加入，因为此时优先关系可能会发生变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FreqStack</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, List&lt;Integer&gt;&gt; indexListMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;<br>        List&lt;Integer&gt; index1 = indexListMap.get(a);<br>        List&lt;Integer&gt; index2 = indexListMap.get(b);<br>        <span class="hljs-keyword">if</span>(index1.size() != index2.size())&#123;<br>            <span class="hljs-keyword">return</span> index2.size() - index1.size();<br>        &#125;<br>        <span class="hljs-keyword">return</span> index2.get(index2.size() - <span class="hljs-number">1</span>) - index1.get(index1.size() - <span class="hljs-number">1</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(indexListMap.containsKey(val))&#123;<br>            maxHeap.remove(val);<br>            indexListMap.get(val).add(index++);<br>            maxHeap.offer(val);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;  <br>        List&lt;Integer&gt; indexList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(List.of(index++));<br>        indexList.add(index++);<br>        indexListMap.put(val, indexList);<br>        maxHeap.offer(val);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> maxHeap.poll();<br>        List&lt;Integer&gt; index = indexListMap.get(val);<br>        <span class="hljs-keyword">if</span>(index.size() == <span class="hljs-number">1</span>)&#123;<br>            indexListMap.remove(val);<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>        index.remove(index.size() - <span class="hljs-number">1</span>);<br>        maxHeap.offer(val);<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表-大根堆-优化"><a href="#哈希表-大根堆-优化" class="headerlink" title="哈希表 + 大根堆 优化"></a>哈希表 + 大根堆 优化</h2><p>更简单的做法是哈希表只维护元素和出现频率之间的关系，使用大根堆存储一个三元组 ${val, index, cnt}$ 分别代表元素本身、当前下标、当前频率，排序规则同上。</p><p>由于优先队列保存了完整的数据，即每个元素出现了几次就会出现在队列中几次，所以效率更高代码也更简洁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FreqStack</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Integer&gt; COUNT_MAP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// int&#123;val, index, cnt&#125;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; MAX = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b[<span class="hljs-number">2</span>] != a[<span class="hljs-number">2</span>] ? b[<span class="hljs-number">2</span>] - a[<span class="hljs-number">2</span>] : b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>]);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> COUNT_MAP.compute(val, (key, old) -&gt; old == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : ++old);<br>        MAX.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;val, index++, count&#125;);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] a = MAX.poll();<br>        COUNT_MAP.compute(a[<span class="hljs-number">0</span>], (key, count) -&gt; --count);<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表-栈"><a href="#哈希表-栈" class="headerlink" title="哈希表 + 栈"></a>哈希表 + 栈</h2><p>在上面的做法中，由于我们使用到了优先队列，所以每次入队和出队时间复杂度都为 $log(N)$ 。</p><p>另一种做法同样是使用哈希表维护元素和出现频率之间的关系，但是不再使用优先队列而是使用另一个哈希表来维护每种出现频率和对应的栈之间的关系，即会有多个栈。</p><p>稍微要注意的是，假设某个元素出现了 $5$ 次，那么在频率为 $1,2,3,4,5$ 的栈中都会有该元素，所以每当最大的栈为空时，我们只需要将最大栈的变量减一即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FreqStack</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Integer&gt; freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Deque&lt;Integer&gt;&gt; groupStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> freq.compute(val, (key, old) -&gt; old == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : ++old);<br>        groupStack.compute(x, (key, old) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(old == <span class="hljs-literal">null</span>)&#123;<br>                old = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>            &#125;<br>            old.push(val);<br>            <span class="hljs-keyword">return</span> old;<br>        &#125;);<br>        max = Math.max(max, x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        Deque&lt;Integer&gt; stack = groupStack.get(max);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> stack.pop();<br>        <span class="hljs-keyword">if</span>(stack.isEmpty())&#123;<br>            max--; <span class="hljs-comment">// 如果某个元素出现了 5 次，那么在频率为 1,2,3,4,5 的栈中都会有该元素</span><br>        &#125;<br>        freq.compute(val, (key, old) -&gt; --old);<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表-List"><a href="#哈希表-List" class="headerlink" title="哈希表 + List"></a>哈希表 + List</h2><p>类似上一种做法，可以使用哈希表加上 $List$ 来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FreqStack</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Integer&gt; freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Deque&lt;Integer&gt;&gt; stackList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> freq.getOrDefault(val, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(x == stackList.size())&#123;<br>            stackList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;());<br>        &#125;<br>        stackList.get(x).push(val);<br>        freq.put(val, x + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        Deque&lt;Integer&gt; last = stackList.get(stackList.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> last.pop();<br>        <span class="hljs-keyword">if</span>(last.isEmpty())&#123;<br>            stackList.remove(stackList.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>        freq.compute(val, (__, old) -&gt; --old);<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-115.不同的子序列</title>
    <link href="/2022/11/29/LC-115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/11/29/LC-115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/distinct-subsequences/">leetcode 困难题</a></p><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p>示例1：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;rabbbit&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;rabbit&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>如下图所示, 有 <span class="hljs-number">3</span> 种可以从 s 中得到 <span class="hljs-string">&quot;rabbit&quot;</span> 的方案。<br>rabbbit<br>rabbbit<br>rabbbit<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">0</span> &lt;= s.<span class="hljs-built_in">length</span>, t.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">1000</span><br>s 和 t 由英文字母组成<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>定义 $dp[i][j]$ 表示子串 $s[0…i]$ 中子序列 $t[0…j]$ 出现的个数。</p><p>令 $dp$ 从 $0$ 开始，表示空串。并且当 $j &#x3D; 0$ 时，$dp[i][0]$ 为 $1$ ，因为空字符串是任何字符串的子序列。其他情况下：</p><p>$$<br>\begin{align}<br>&amp;dp(i, j) &#x3D; dp(i - 1, j)　　　　　　　　　　　　 　 s[i - 1] \ne t[j - 1] \\<br>&amp;dp(i, j) &#x3D; dp(i - 1, j) + dp(i - 1, j - 1)　　　　 s[i - 1] &#x3D; t[j - 1] \\<br>\end{align}<br>$$</p><p>$dp[n][m]$ 为答案，$n$ 和 $m$ 分别为两个字符串的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-comment">// dp[i][j] 表示子串 s[0...i] 中子序列 t[0...j] 出现的个数</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">if</span>(s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] += dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><p>每一层只依赖上一层的结果，逆序遍历即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= <span class="hljs-number">1</span>; j--)&#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                    dp[j] += dp[j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-813.最大平均值和的分组</title>
    <link href="/2022/11/28/LC-813-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/"/>
    <url>/2022/11/28/LC-813-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/largest-sum-of-averages/">leetcode 中等题</a></p><p>给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成 最多 k 个相邻的非空子数组 。 分数 由每个子数组内的平均值的总和构成。</p><p>注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。</p><p>返回我们所能得到的最大 分数 是多少。答案误差在 $10^{-6}$ 内被视为是正确的。</p><p>示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: nums = [<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>], k = <span class="hljs-number">3</span><br>输出: <span class="hljs-number">20.00000</span><br>解释: <br>nums 的最优分组是[<span class="hljs-number">9</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">9</span>]. 得到的分数是 <span class="hljs-number">9</span> + (<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span>) / <span class="hljs-number">3</span> + <span class="hljs-number">9</span> = <span class="hljs-number">20.</span> <br>我们也可以把 nums 分成[<span class="hljs-number">9</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>]. <br>这样的分组得到的分数为 <span class="hljs-number">5</span> + <span class="hljs-number">2</span> + <span class="hljs-number">6</span> = <span class="hljs-number">13</span>, 但不是最大值.<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">100</span><br><span class="hljs-symbol">1 </span>&lt;= nums[i] &lt;= <span class="hljs-number">104</span><br><span class="hljs-symbol">1 </span>&lt;= k &lt;= nums.length<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>定义 $dp[i][j]$ 表示子数组 $[0…i]$ 分成 $j$ 段的最大分数。<br>为了方便，令 $i$ 和 $j$ 从 $1$ 开始，简略的状态转移方程如下:</p><p>$$<br>\begin{align}<br>&amp;dp(i, j) &#x3D; \frac{sum(nums[0] … nums[i - 1])}{i}　　　　　　　　　　　　　　　　　　　 j &#x3D; 1\\<br>&amp;dp(i, j) &#x3D; max\{dp(x, j - 1) + \frac{sum(nums[x + 1] … nums[i])}{i - x}\}　　　　 1 &lt;j ,　j - 1 &lt;&#x3D; x &lt; i \\<br>\end{align}<br>$$</p><p>$dp[n][k]$ 为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">largestSumOfAverages</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// dp[i][j] 表示i区间分j组的最大分数</span><br>        <span class="hljs-type">double</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n + <span class="hljs-number">1</span>][k + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k; j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">1</span>)&#123;<br>                    dp[i][j] = ((<span class="hljs-type">double</span>)preSum[i] - preSum[<span class="hljs-number">0</span>]) / i;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> j - <span class="hljs-number">1</span>; p &lt; i; p++)&#123;<br>                    <span class="hljs-type">double</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> dp[p][j - <span class="hljs-number">1</span>] + ((<span class="hljs-type">double</span>)preSum[i] - preSum[p]) / (i - (p + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>); <br>                    dp[i][j] = Math.max(dp[i][j], temp);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><p>类似01背包，可以进行滚动数组优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">largestSumOfAverages</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// dp[i][j] 表示i区间分j组的最大分数</span><br>        <span class="hljs-type">double</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k; j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt;= <span class="hljs-number">1</span>; i--)&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">1</span>)&#123;<br>                    dp[i] = ((<span class="hljs-type">double</span>)preSum[i] - preSum[<span class="hljs-number">0</span>]) / i;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> j - <span class="hljs-number">1</span>; p &lt; i; p++)&#123;<br>                    <span class="hljs-type">double</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> dp[p] + ((<span class="hljs-type">double</span>)preSum[i] - preSum[p]) / (i - (p + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>); <br>                    dp[i] = Math.max(dp[i], temp);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6248.统计中位数为K的子数组</title>
    <link href="/2022/11/28/LC-6248-%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/11/28/LC-6248-%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/count-subarrays-with-median-k/">leetcode 困难题</a></p><p>给你一个长度为 n 的数组 nums ，该数组由从 1 到 n 的 不同 整数组成。另给你一个正整数 k 。</p><p>统计并返回 num 中的 中位数 等于 k 的非空子数组的数目。</p><p>注意：</p><ul><li>数组的中位数是按 递增 顺序排列后位于 中间 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 左 的那个元素。<ul><li>例如，[2,3,1,4] 的中位数是 2 ，[8,4,3,5,1] 的中位数是 4 。</li></ul></li><li>子数组是数组中的一个连续部分。</li></ul><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,1,4,5]</span>, k = 4<br>输出：3<br>解释：中位数等于 4 的子数组有：<span class="hljs-comment">[4]</span>、<span class="hljs-comment">[4,5]</span> 和 <span class="hljs-comment">[1,4,5]</span> 。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">n</span> == nums.length<br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-number">1</span> &lt;= nums[i], k &lt;= <span class="hljs-built_in">n</span><br>nums 中的整数互不相同<br></code></pre></td></tr></table></figure><h2 id="等价转换"><a href="#等价转换" class="headerlink" title="等价转换"></a>等价转换</h2><p>由于是求中位数等于 $k$ 的子数组的个数，所以可以 <strong>把数组中大于 $k$ 的元素转换成 $1$ ，小于的转换成 $-1$ 。</strong>经过该转换后就可以利用类似前缀和的方式进行求解。并且由于该数组是一个数列，那么就只需要找到 $k$ 后通过用前缀和的做法向左右扩散即可。</p><p>具体来说，找到 $k$ 的位置后，选一个方向计算前缀和，并将该方向每个子数组的结果通过哈希表统计起来；然后遍历另一个方向，每次得出前缀和后，设其为 $preSum$，通过判断哈希表是否存在 $-preSum$ （偶数个数情况）和 $-preSum + 1$ （奇数个数情况），如果存在的话就可以加上对应的个数。当然，由题意可知如果是 $0$ 或者 $1$ 的话，直接将 $ans + 1$ 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(p++ &lt; n)&#123;<br>            <span class="hljs-keyword">if</span>(nums[p] == k)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        Map&lt;Integer, Integer&gt; sumCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 左边前缀和</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            sum[i] = i + <span class="hljs-number">1</span> &lt; n ? sum[i + <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>;<br>            sum[i] += nums[i] &gt; k ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>            sumCount.compute(sum[i], (key, old) -&gt; old == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span>: ++old);<br>        &#125;<br>        ans += sumCount.getOrDefault(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) + sumCount.getOrDefault(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 右边前缀和</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p + <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            sum[i] = i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> ? sum[i - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>;w<br>            sum[i] += nums[i] &gt; k ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(sum[i] == <span class="hljs-number">0</span> || sum[i] == <span class="hljs-number">1</span>)&#123;<br>                ans++;<br>            &#125;<br>            ans += sumCount.getOrDefault(-sum[i], <span class="hljs-number">0</span>);<br>            ans += sumCount.getOrDefault(-sum[i] + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>等价转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6251.统计回文子序列数目</title>
    <link href="/2022/11/28/LC-6251-%E7%BB%9F%E8%AE%A1%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/11/28/LC-6251-%E7%BB%9F%E8%AE%A1%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/count-palindromic-subsequences/">leetcode 困难题</a></p><p>给你数字字符串 s ，请你返回 s 中长度为 5 的 回文子序列 数目。由于答案可能很大，请你将答案对 $10^9 + 7$ 取余 后返回。</p><p>提示：</p><p>如果一个字符串从前往后和从后往前读相同，那么它是 回文字符串 。<br>子序列是一个字符串中删除若干个字符后，不改变字符顺序，剩余字符构成的字符串。</p><p>示例1：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;103301&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：<br>总共有 <span class="hljs-number">6</span> 长度为 <span class="hljs-number">5</span> 的子序列：<span class="hljs-string">&quot;10330&quot;</span> ，<span class="hljs-string">&quot;10331&quot;</span> ，<span class="hljs-string">&quot;10301&quot;</span> ，<span class="hljs-string">&quot;10301&quot;</span> ，<span class="hljs-string">&quot;13301&quot;</span> ，<span class="hljs-string">&quot;03301&quot;</span> 。<br>它们中有两个（都是 <span class="hljs-string">&quot;10301&quot;</span>）是回文的。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> &lt;= s.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-attribute">s</span> 只包含数字字符。<br></code></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>由于题目要求的子序列限定了长度必须为 $5$，那么我们可以通过枚举回文子序列的中心点来得出结果。</p><p>因为 $s$ 只包含数字字符，可知中心点的每侧字符只有 $10 \times 10$ 种可能（如果只包含字母的话就是 $24 \times 24$ 种可能），那么我们可以通过类似前缀和的方式进行枚举即可得到结果。</p><p>具体来说，我们预先通过一个 $right[10][10]$ 保存该数组所有长度为 $2$ 的子序列组合的个数、$rightCount[10]$ 保存每个不同字符的出现个数。然后 $i$ 从 $0$ 开始遍历，每次将当前字符的可能性从 $right[10][10]$ 和 $right[10]$ 中撤销，并累加到 $left[10][10]$ 和 $leftCount$ 中，再遍历所有 $left[10][10]$ ，那么通过乘法原理可知，以当前字符为中心的回文子序列个数就为每个 $left[a][b] \times right[b][a]$ 的总和。</p><p>题目给出 $n$ 范围为 $10^4$，内层最多循环 $10 \times 10$ 次，计算量为 $10^6$ ，不会 TLE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPalindromes</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>        <span class="hljs-type">int</span>[] rightCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">9</span>; j++)&#123;<br>                right[s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>][j] += rightCount[j];<br>            &#125;<br>            rightCount[s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>        <span class="hljs-type">int</span>[] leftCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            rightCount[item - <span class="hljs-string">&#x27;0&#x27;</span>]--;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">9</span>; j++)&#123;<br>                right[item - <span class="hljs-string">&#x27;0&#x27;</span>][j] -= rightCount[j];<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; a &lt;= <span class="hljs-number">9</span>; a++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; b &lt;= <span class="hljs-number">9</span>; b++)&#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> ans;<br>                    ans = (ans % MOD + ((<span class="hljs-type">long</span>)left[a][b] * right[b][a]) % MOD) % MOD;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">9</span>; j++)&#123;<br>                left[j][item - <span class="hljs-string">&#x27;0&#x27;</span>] += leftCount[j];<br>            &#125;<br>            leftCount[item - <span class="hljs-string">&#x27;0&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(ans % MOD);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举-动态规划"><a href="#枚举-动态规划" class="headerlink" title="枚举 + 动态规划"></a>枚举 + 动态规划</h2><p>另一种做法是枚举出长度为 $5$ 的回文串的所有可能，再将字符串中这些回文子序列出现的次数累加起来就是答案。</p><p>枚举出所有回文串需要循环 $10 \times 10 \times 10$ 次，求子序列出现次数计算量为 $5 \times 10^4$，总计算量为 $5 \times 10^7$ ，不会 TLE。</p><p><a href="https://wecgwm.github.io/2022/11/29/LC-115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/">LC-115：枚举某个子序列在字符串中出现次数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPalindromes</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">9</span>; j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= <span class="hljs-number">9</span>; k++)&#123;<br>                    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(i).append(j).append(k).append(j).append(i);<br>                    ans = (ans + help(s, sb.toString())) % MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(ans % MOD);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">help</span><span class="hljs-params">(String s, String t)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">if</span>(s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = (dp[i][j] + dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-882.细分图中的可到达节点</title>
    <link href="/2022/11/26/LC-882-%E7%BB%86%E5%88%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9/"/>
    <url>/2022/11/26/LC-882-%E7%BB%86%E5%88%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/">leetcode 困难题</a></p><p>给你一个无向图（原始图），图中有 n 个节点，编号从 0 到 n - 1 。你决定将图中的每条边 细分 为一条节点链，每条边之间的新节点数各不相同。</p><p>图用由边组成的二维数组 edges 表示，其中 edges[i] &#x3D; [ui, vi, cnti] 表示原始图中节点 ui 和 vi 之间存在一条边，cnti 是将边 细分 后的新节点总数。注意，cnti &#x3D;&#x3D; 0 表示边不可细分。</p><p>要 细分 边 [ui, vi] ，需要将其替换为 (cnti + 1) 条新边，和 cnti 个新节点。新节点为 x1, x2, …, xcnti ，新边为 [ui, x1], [x1, x2], [x2, x3], …, [xcnti+1, xcnti], [xcnti, vi] 。</p><p>现在得到一个 新的细分图 ，请你计算从节点 0 出发，可以到达多少个节点？如果节点间距离是 maxMoves 或更少，则视为 可以到达 。</p><p>给你原始图和 maxMoves ，返回 新的细分图中从节点 0 出发 可到达的节点数 。</p><p>示例1：<br><img src="/../img/Snipaste_2022-11-26_22-18-03.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：edges = <span class="hljs-string">[[0,1,10],[0,2,1],[1,2,2]]</span>, maxMoves = <span class="hljs-number">6</span>, n = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">13</span><br>解释：边的细分情况如上图所示。<br>可以到达的节点已经用黄色标注出来。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">0</span> &lt;= edges.length &lt;= <span class="hljs-built_in">min</span>(<span class="hljs-built_in">n</span> * (<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>, <span class="hljs-number">104</span>)<br>edges[i].length == <span class="hljs-number">3</span><br><span class="hljs-number">0</span> &lt;= ui &lt; vi &lt; <span class="hljs-built_in">n</span><br>图中 不存在平行边<br><span class="hljs-number">0</span> &lt;= cnti &lt;= <span class="hljs-number">104</span><br><span class="hljs-number">0</span> &lt;= maxMoves &lt;= <span class="hljs-number">109</span><br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>将 $cnt_i$ 看成类似权值，再通过 <a href="https://oi-wiki.org/graph/shortest-path/#dijkstra-%E7%AE%97%E6%B3%95">Dijkstra</a> 算法得到每个原始点到 $0$ 的最短路径即可。</p><p>需要注意的有两点：</p><ol><li>计算距离的时候要使用 $cnt + 1$ ，因为还要加上原始节点的消耗。</li><li>得到最短路径后，计算 <code>可达点</code> 总数时需要将 <code>原始节点</code> 和 <code>拆分节点</code> 分开来计算避免重复计算原始点。对于原始节点，当 $d[i]$ 小于 $maxMoves$ 时，即为可达；而对于拆分节点，通过遍历所有边得出，对于某条边 $e(u, v)$ ，该边的可达的拆分点显然为经过 $u$ 点可达的拆分点与经过 $v$ 点可达的拆分点交集，设两者数量分别为 $u_x$ 和 $v_x$ 、该边拆分点总数为 $all$，那么该边可达的拆分点总数即为 $min(all, u_x + v_x)$ ，注意这里的 $min(all, )$ 相当于去了重。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reachableNodes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> maxMoves, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// Build graph</span><br>        List&lt;<span class="hljs-type">int</span>[]&gt;[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        Arrays.setAll(g, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; edges.length; i++)&#123;<br>            g[edges[i][<span class="hljs-number">0</span>]].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;edges[i][<span class="hljs-number">1</span>], edges[i][<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>&#125;); <span class="hljs-comment">// +1, 因为还要算上原始点的距离</span><br>            g[edges[i][<span class="hljs-number">1</span>]].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>&#125;);<br>        &#125;<br>        <span class="hljs-comment">// dijkstra</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; min = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>        min.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-type">int</span>[] d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(d, Integer.MAX_VALUE);<br>        d[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        Set&lt;Integer&gt; visit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(!min.isEmpty())&#123;<br>            <span class="hljs-type">int</span>[] top = min.poll();<br>            <span class="hljs-keyword">if</span>(!visit.add(top[<span class="hljs-number">0</span>]))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] p : g[top[<span class="hljs-number">0</span>]])&#123;<br>                <span class="hljs-keyword">if</span>(d[p[<span class="hljs-number">0</span>]] &gt; d[top[<span class="hljs-number">0</span>]] + p[<span class="hljs-number">1</span>])&#123;<br>                    d[p[<span class="hljs-number">0</span>]] = d[top[<span class="hljs-number">0</span>]] + p[<span class="hljs-number">1</span>];<br>                    min.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;p[<span class="hljs-number">0</span>], d[p[<span class="hljs-number">0</span>]]&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 原始点和拆分点分开来算</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> item : d)&#123;<br>            <span class="hljs-keyword">if</span>(item &lt;= maxMoves)&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] e : edges)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, maxMoves - d[e[<span class="hljs-number">0</span>]]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, maxMoves - d[e[<span class="hljs-number">1</span>]]);<br>            ans += Math.min(e[<span class="hljs-number">2</span>], a + b);<br>        &#125;<br>        <span class="hljs-keyword">return</span>  ans;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>堆</tag>
      
      <tag>图</tag>
      
      <tag>最短路径</tag>
      
      <tag>Dijkstra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-795.区间子数组个数</title>
    <link href="/2022/11/24/LC-795-%E5%8C%BA%E9%97%B4%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/11/24/LC-795-%E5%8C%BA%E9%97%B4%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/">leetcode 中等题</a></p><p>给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。</p><p>示例1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[2,1,4,3]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：满足条件的三个子数组：<span class="hljs-selector-attr">[2]</span>, <span class="hljs-selector-attr">[2, 1]</span>, <span class="hljs-selector-attr">[3]</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span>&lt;= nums[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br><span class="hljs-symbol">0 </span>&lt;= left &lt;= right &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>显然符合题意的子数组必然不包含任意的 $nums[i] &gt; right$，并且必须包含一个 $left &lt;&#x3D; nums[i] &lt;&#x3D; right$。 </p><p>我们初始化左右指针都指向 $0$ ，右指针每次后移一位。<strong>并统计以右指针为子数组右端点且符合题意的子数组个数。</strong></p><p>具体遍历时，分以下三种情况进行处理</p><ul><li>如果当前元素 $left &lt;&#x3D; nums[i] &lt;&#x3D; right$，我们只需要将答案累加 $right - left + 1$ 即可。并且同时维护一个 $lastMatch$，代表最后一个遇到的符合大于 $left$ 小于 $right$ 的元素下标，将其更新为当前下标。</li><li>如果当前元素 $nums[i] &lt; left$ ，我们就需要找到左边第一个满足 $left &lt;&#x3D; nums[i] &lt;&#x3D; right$ 的下标，也就是 $lastMatch$，则显然以 $[lastMatch…right]$ 段任意元素作为左端点的子数组都不符合要求；而对于 $[left…lastMatch]$ 段，每个子数组都至少存在一个 $lastMatch$ 是符合要求的，所以我们将答案累加 $lastMatch - left + 1$ 。</li><li>如果当前元素 $nums &gt; right$ ，我们只需要将左指针移动到 $i + 1$ 并将 $lastMatch$ 置为 $-1$ 即可，因为包含该元素的任意子数组都不符合题目要求。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarrayBoundedMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lastMatch = -<span class="hljs-number">1</span>, n = nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">leftPoint</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightPoint = <span class="hljs-number">0</span>; rightPoint &lt; n; rightPoint++)&#123;<br>            <span class="hljs-keyword">if</span>(left &lt;= nums[rightPoint]  &amp;&amp; nums[rightPoint] &lt;= right)&#123;<br>                lastMatch = rightPoint;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[rightPoint] &gt; right)&#123;<br>                lastMatch = -<span class="hljs-number">1</span>;<br>                leftPoint = rightPoint + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(lastMatch != - <span class="hljs-number">1</span>)&#123;<br>                ans += lastMatch - leftPoint + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>前面双指针的做法相当于每次求解以遍历到的当前元素作为右端点的合法子数组数量，另一种方法则是求解以当前元素作为子数组最大值的合法子数组数量。</p><p>容易想到，我们利用单调栈维护出每个元素左边第一个大于当前元素的下标 $left[i]$、右边第一个大于当前元素的下标 $right[i]$。</p><p>那么该范围内以该元素作为子数组最大值的数量就等价于包含该元素的子数组数量，也就是 $(i - left[i]) \times (right[i] - i)$。</p><p>需要注意的是，由于数组中存在重复元素，我们在找第一个大于当前元素的下标时，可能存在每个重复元素都越过了彼此，由此产生重复统计。所以我们可以将某一侧的条件改为大于等于，实现类似半闭半开的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarrayBoundedMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] leftMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] rightMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Deque&lt;Integer&gt; monoStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!monoStack.isEmpty() &amp;&amp; nums[i] &gt;= nums[monoStack.peekLast()])&#123;<br>                monoStack.pollLast();<br>            &#125;<br>            leftMax[i] =monoStack.isEmpty() ? -<span class="hljs-number">1</span> : monoStack.peekLast();<br>            monoStack.offerLast(i);<br>        &#125;<br>        monoStack.clear();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(!monoStack.isEmpty() &amp;&amp; nums[i] &gt; nums[monoStack.peekLast()])&#123;<br>                monoStack.pollLast();<br>            &#125;<br>            rightMax[i] = monoStack.isEmpty() ? n : monoStack.peekLast();<br>            monoStack.offerLast(i);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; right || nums[i] &lt; left)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            ans += (i - leftMax[i]) * (rightMax[i] - i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>多指针</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-878.第N个神奇数字</title>
    <link href="/2022/11/22/LC-878-%E7%AC%ACN%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97/"/>
    <url>/2022/11/22/LC-878-%E7%AC%ACN%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/nth-magical-number/">leetcode 困难题</a></p><p>一个正整数如果能被 a 或 b 整除，那么它是神奇的。</p><p>给定三个整数 n , a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案 对 109 + 7 取模 后的值。</p><p>示例1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：n = <span class="hljs-number">1</span>, <span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：n = <span class="hljs-number">4</span>, <span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= n &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br><span class="hljs-symbol">2 </span>&lt;= a, b &lt;= <span class="hljs-number">4</span> * <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="容斥原理-二分查找"><a href="#容斥原理-二分查找" class="headerlink" title="容斥原理 + 二分查找"></a>容斥原理 + 二分查找</h2><p>这道题容易想到的做法是多指针，两个指针分别指向 $a$ 和 $b$ 的某个倍数，并通过不断比较找到第 $n$ 个数，该做法的时间复杂度为 $O(N)$，在该题的数据规模下显然会 TLE。</p><p>容易想到的优化方法是通过二分查找找到第 $n$ 个数，但是需要解决的问题是<strong>如何确定某个数 $i$ 前面的神奇数字的数量</strong>，将该数量设为 $x$。</p><p>可以发现每个神奇数字必然满足以下三种情况之一：</p><ul><li>为 $a$ 的倍数</li><li>为 $b$ 的倍数</li><li>为 $lcm(a, b)$ 的倍数</li></ul><p>显然通过容斥定理可以得出：<br>$x$ &#x3D; $i$ 前面的数为 $a$ 的倍数的数量 + $i$ 前面的数为 $b$ 的倍数的数量 - $i$ 前面的数为 $lcm(a, b)$ 的倍数的数量</p><p>也就是</p><p>$x &#x3D; \lfloor \frac{i}{a} \rfloor + \lfloor \frac{i}{b} \rfloor - \lfloor \frac{i}{lcm} \rfloor$</p><p>答案为二分查找的左边界，也就是第一个满足的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> lcm;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthMagicalNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Math.min(a, b);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Long.MAX_VALUE;<br>        <span class="hljs-built_in">this</span>.a = a;<br>        <span class="hljs-built_in">this</span>.b = b;<br>        <span class="hljs-built_in">this</span>.lcm = lcm(a, b);<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(get(mid) &lt; n)&#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (l % MOD);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> mid)</span>&#123;<br>        <span class="hljs-keyword">return</span> (mid / a) + (mid / b) - (mid / lcm);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> (a * b) / gcd(a, b);<br>    &#125; <br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>类似的，也可以转化成</p><p>$x &#x3D; \lceil \frac{i}{a} \rceil + \lceil \frac{i}{b} \rceil - \lceil \frac{i}{lcm} \rceil$</p><p>此时答案为右边界，也就是最后一个满足的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> lcm;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthMagicalNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Math.min(a, b);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Long.MAX_VALUE;<br>        <span class="hljs-built_in">this</span>.a = a;<br>        <span class="hljs-built_in">this</span>.b = b;<br>        <span class="hljs-built_in">this</span>.lcm = lcm(a, b);<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(get(mid) &gt; n)&#123;<br>                r = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ((l - <span class="hljs-number">1</span>) % MOD);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> mid)</span>&#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> mid;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>)(Math.ceil(temp / a) + Math.ceil(temp / b) - Math.ceil(temp / lcm));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> (a * b) / gcd(a, b);<br>    &#125; <br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二分查找</tag>
      
      <tag>脑筋急转弯/找规律</tag>
      
      <tag>容斥原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6244.完美分割的方案数</title>
    <link href="/2022/11/21/LC-6244-%E5%AE%8C%E7%BE%8E%E5%88%86%E5%89%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/"/>
    <url>/2022/11/21/LC-6244-%E5%AE%8C%E7%BE%8E%E5%88%86%E5%89%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/number-of-beautiful-partitions/">leetcode 困难题</a></p><p>给你一个字符串 s ，每个字符是数字 ‘1’ 到 ‘9’ ，再给你两个整数 k 和 minLength 。</p><p>如果对 s 的分割满足以下条件，那么我们认为它是一个 完美 分割：</p><ul><li>s 被分成 k 段互不相交的子字符串。</li><li>每个子字符串长度都 至少 为 minLength 。</li><li>每个子字符串的第一个字符都是一个 质数 数字，最后一个字符都是一个 非质数 数字。质数数字为 ‘2’ ，’3’ ，’5’ 和 ‘7’ ，剩下的都是非质数数字。<br>请你返回 s 的 完美 分割数目。由于答案可能很大，请返回答案对 109 + 7 取余 后的结果。</li></ul><p>一个 子字符串 是字符串中一段连续字符串序列。</p><p>示例1：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">输入：s = <span class="hljs-string">&quot;23542185131&quot;</span>, k = <span class="hljs-number">3</span>, <span class="hljs-keyword">min</span>Length = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：存在 <span class="hljs-number">3</span> 种完美分割方案：<br><span class="hljs-string">&quot;2354 | 218 | 5131&quot;</span><br><span class="hljs-string">&quot;2354 | 21851 | 31&quot;</span><br><span class="hljs-string">&quot;2354218 | 51 | 31&quot;</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> &lt;= k, minLength &lt;= s.length &lt;= <span class="hljs-number">1000</span><br><span class="hljs-attribute">s</span> 每个字符都为数字 &#x27;<span class="hljs-number">1</span>&#x27; 到 &#x27;<span class="hljs-number">9</span>&#x27; 之一。<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>定义 $f(i, j)$ 表示字符串 $S[0..(j -1)]$ 分割 $i$ 份时的满足题目要求的方案数。</p><p>所以 $j$ 如果为一个合法的分割点，需满足 $j$ 为非质数，且 $j - 0 &gt;&#x3D; minLength - 1$。</p><p>而对于 $f(i, j)$ 的求解，我们通过可以枚举上一个分割点来得出，定义其为 $j’$，需满足 $j’$ 为非质数，$j’ + 1$ 为质数，$j - j’ &gt;&#x3D; minLength$。</p><p>那么就可以得到 $f(i, j)$ 为所有符合要求的 $f(i - 1, j’)$ 的总和。</p><p>定义 $f(0,0)$ 为 $1$ ，即空串的 $0$ 个分割算作一种方案，$f(k, n)$ 为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;Character&gt; P = Set.of(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span>  (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">beautifulPartitions</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> minLength)</span> &#123;     <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; k + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> minLength - <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(isP(s.charAt(j)))&#123; <span class="hljs-comment">// j 不是合法的分割点</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 累加符合要求的 j&#x27;，也就是这里的 q</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; q &lt;= j - minLength; q++)&#123; <span class="hljs-comment">// 需要注意这里 j&#x27; 可以为-1，因为 dp 的第二维度能取到 0</span><br>                    <span class="hljs-keyword">if</span>((q == - <span class="hljs-number">1</span> || !isP(s.charAt(q))) &amp;&amp; isP(s.charAt(q + <span class="hljs-number">1</span>)))&#123;<br>                        sum = (sum + dp[i - <span class="hljs-number">1</span>][q + <span class="hljs-number">1</span>]) % MOD;<br>                    &#125;<br>                &#125;<br>                dp[i][j + <span class="hljs-number">1</span>] = sum; <span class="hljs-comment">// 这里是 j + 1。因为 dp[0][0] 为空串分割 0 段</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[k][n];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isP</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span>&#123;<br>        <span class="hljs-keyword">return</span> P.contains(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会发现上面代码的时间复杂度为 $O(N^3)$，会 TLE ，需要进行优化。</p><p>可以发现对于同一个 $i$ 的不同 $j$ ，许多 $j’$ 的枚举是重复的。</p><p>所以可以同时进行 $j$ 和 $j’$ 的枚举，并且利用类似前缀和的思路，记录对于同一个 $i$ 不同 $j’$ 的总和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;Character&gt; P = Set.of(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span>  (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">beautifulPartitions</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> minLength)</span> &#123;     <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; k + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> minLength - <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> j - minLength;<br>                <span class="hljs-keyword">if</span>((q == - <span class="hljs-number">1</span> || !isP(s.charAt(q))) &amp;&amp; isP(s.charAt(q + <span class="hljs-number">1</span>)))&#123;<br>                    sum = (sum + dp[i - <span class="hljs-number">1</span>][q + <span class="hljs-number">1</span>]) % MOD;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(isP(s.charAt(j)))&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i][j + <span class="hljs-number">1</span>] = sum;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[k][n];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isP</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span>&#123;<br>        <span class="hljs-keyword">return</span> P.contains(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># root at wecgwm in /home/yichen [1:42:51]</span><br>→ <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-808.分汤</title>
    <link href="/2022/11/21/LC-808-%E5%88%86%E6%B1%A4/"/>
    <url>/2022/11/21/LC-808-%E5%88%86%E6%B1%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/soup-servings/solution/fen-tang-by-leetcode-solution-0yxs/">leetcode 中等题</a></p><p>有 A 和 B 两种类型 的汤。一开始每种类型的汤有 n 毫升。有四种分配操作：</p><ul><li>提供 100ml 的 汤A 和 0ml 的 汤B 。</li><li>提供 75ml 的 汤A 和 25ml 的 汤B 。</li><li>提供 50ml 的 汤A 和 50ml 的 汤B 。</li><li>提供 25ml 的 汤A 和 75ml 的 汤B 。</li></ul><p>当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。</p><p>注意 不存在先分配 100 ml 汤B 的操作。</p><p>需要返回的值： 汤A 先分配完的概率 +  汤A和汤B 同时分配完的概率 &#x2F; 2。返回值在正确答案 $10^{-5}$ 的范围内将被认为是正确的。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: n = <span class="hljs-number">50</span><br>输出: <span class="hljs-number">0.62500</span><br>解释:如果我们选择前两个操作，<span class="hljs-keyword">A</span> 首先将变为空。<br>对于第三个操作，<span class="hljs-keyword">A</span> 和 B 会同时变为空。<br>对于第四个操作，B 首先将变为空。<br>所以 <span class="hljs-keyword">A</span> 变为空的总概率加上 <span class="hljs-keyword">A</span> 和 B 同时变为空的概率的一半是 <span class="hljs-number">0</span>.<span class="hljs-number">25</span> *(<span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">5</span> + <span class="hljs-number">0</span>)= <span class="hljs-number">0</span>.<span class="hljs-number">625</span>。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= n &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span>​​​​​​​<br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在该题的两个解法中，不论是自顶向下的记忆化搜索还是自底向上的动态规划，时间复杂度都是 $O(n^2)$，即使是将 $n$ 除以 $25$ （后面有解释），在该题的数据规模下仍然会 TLE。</p><p>我们可以发现，随着分配次数的增加，汤 A 比汤 B 先分配完的概率或者答案也是增大的。事实上，当 $n &gt;&#x3D; 4475$ 后，这个答案和 $1$ 的误差就已经小于题目容忍的误差了。所以当 $n &lt; 4475$ 时，我们可以通过记忆化搜索或者动态规模得出答案，否则直接返回 $1$ 即可。</p><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>首先，由于数据规模较大以及四种分配操作都是 $25$ 的倍数，因此我们可以将 $n$ 除以 $25$（向上取整），并将四种分配操作变为 $(4, 0),(3, 1),(2, 2),(1, 3)$，且每种操作的概率均为 $0.25$。</p><p>递归求解，当要分给 $A$ 和 $B$ 的汤均小于等于 $0$ 时，依题意返回 $0.5$，当仅 $A$ 小于等于 $0$ 时依题意返回 $1$，仅 $B$ 小于等于 $0$ 时返回 $0$，其他情况递归求解四种情况下的平均值即可。</p><p>同时为了避免重复递归，使用 $cache[i][j]$ 保存 $A$ 剩余 $i$，$B$ 剩余 $j$ 时的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">double</span>[][] cache;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">soupServings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        n= (<span class="hljs-type">int</span>)Math.ceil((<span class="hljs-type">double</span>)n / <span class="hljs-number">25</span>);<br>        <span class="hljs-keyword">if</span>(n &gt;= <span class="hljs-number">179</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(n, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">if</span>(a &lt;= <span class="hljs-number">0</span> &amp;&amp; b &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(b &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cache[a][b] == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> dfs(a - <span class="hljs-number">4</span>, b);<br>            <span class="hljs-type">double</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> dfs(a - <span class="hljs-number">3</span>, b - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">double</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> dfs(a - <span class="hljs-number">2</span>, b - <span class="hljs-number">2</span>);<br>            <span class="hljs-type">double</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dfs(a - <span class="hljs-number">1</span>, b - <span class="hljs-number">3</span>);<br>            cache[a][b] = <span class="hljs-number">0.25</span> * (q + w + e + r);<br>        &#125;<br>        <span class="hljs-keyword">return</span> cache[a][b];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>类似记忆化搜索的思路，可以转成动态规划求解。</p><p>定义 $dp(i, j)$ 表示 $A$ 剩余 $i$ 、 $B$ 剩余 $j$ 时的解，边界情况如同上面所解释的，非边界情况下转移方程为：</p><p>$$<br>\begin{align}<br>&amp;dp(i, j) &#x3D; \frac{1}{4} \times (dp(i - 4, j) + dp(i - 3, j - 1) + dp(i - 2, j - 2) + dp(i - 1, j - 3))\\<br>\end{align}<br>$$</p><p>需要注意的是在这道题中与记忆化搜索相比动态规划会多出一些无效状态的计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">soupServings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        n = (n + <span class="hljs-number">25</span> - <span class="hljs-number">1</span>) / <span class="hljs-number">25</span>; <span class="hljs-comment">// 向上取整</span><br>        <span class="hljs-keyword">if</span>(n &gt;= <span class="hljs-number">179</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">double</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0.5</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n + <span class="hljs-number">1</span>; j++)&#123;<br>                dp[i][j] += dp[Math.max(<span class="hljs-number">0</span>, i - <span class="hljs-number">4</span>)][j] / <span class="hljs-number">4</span>;<br>                dp[i][j] += dp[Math.max(<span class="hljs-number">0</span>, i - <span class="hljs-number">3</span>)][j - <span class="hljs-number">1</span>] / <span class="hljs-number">4</span>;<br>                dp[i][j] += dp[Math.max(<span class="hljs-number">0</span>, i - <span class="hljs-number">2</span>)][Math.max(<span class="hljs-number">0</span>, j - <span class="hljs-number">2</span>)] / <span class="hljs-number">4</span>;<br>                dp[i][j] += dp[i - <span class="hljs-number">1</span>][Math.max(<span class="hljs-number">0</span>, j - <span class="hljs-number">3</span>)] / <span class="hljs-number">4</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6243.到达首都的最少油耗</title>
    <link href="/2022/11/20/LC-6243-%E5%88%B0%E8%BE%BE%E9%A6%96%E9%83%BD%E7%9A%84%E6%9C%80%E5%B0%91%E6%B2%B9%E8%80%97/"/>
    <url>/2022/11/20/LC-6243-%E5%88%B0%E8%BE%BE%E9%A6%96%E9%83%BD%E7%9A%84%E6%9C%80%E5%B0%91%E6%B2%B9%E8%80%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/">leetcode 中等题</a></p><p>给你一棵 n 个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从 0 到 n - 1 ，且恰好有 n - 1 条路。0 是首都。给你一个二维整数数组 roads ，其中 roads[i] &#x3D; [ai, bi] ，表示城市 ai 和 bi 之间有一条 双向路 。</p><p>每个城市里有一个代表，他们都要去首都参加一个会议。</p><p>每座城市里有一辆车。给你一个整数 seats 表示每辆车里面座位的数目。</p><p>城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。</p><p>请你返回到达首都最少需要多少升汽油。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：roads = [[0,1],[0,2],[0,3]], seats = 5<br>输出：3<br>解释：<br>- 代表<span class="hljs-number"> 1 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 2 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 3 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>最少消耗<span class="hljs-number"> 3 </span>升汽油。<br></code></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2<br>输出：7<br>解释：<br>- 代表<span class="hljs-number"> 2 </span>到达城市<span class="hljs-number"> 3 </span>，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 2 </span>和代表<span class="hljs-number"> 3 </span>一起到达城市<span class="hljs-number"> 1 </span>，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 2 </span>和代表<span class="hljs-number"> 3 </span>一起到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 1 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 5 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 6 </span>到达城市<span class="hljs-number"> 4 </span>，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 4 </span>和代表<span class="hljs-number"> 6 </span>一起到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>最少消耗<span class="hljs-number"> 7 </span>升汽油。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：roads </span>=<span class="hljs-string"> [], seats = 1</span><br><span class="hljs-string">输出：0</span><br><span class="hljs-string">解释：没有代表需要从别的城市到达首都。</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> &lt;= n &lt;= <span class="hljs-number">105</span><br><span class="hljs-attribute">roads</span>.length == n - <span class="hljs-number">1</span><br><span class="hljs-attribute">roads</span>[i].length == <span class="hljs-number">2</span><br><span class="hljs-attribute">0</span> &lt;= ai, bi &lt; n<br><span class="hljs-attribute">ai</span> != bi<br><span class="hljs-attribute">roads</span> 表示一棵合法的树。<br><span class="hljs-attribute">1</span> &lt;= seats &lt;= <span class="hljs-number">105</span><br></code></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>车辆可以视为无限的，要使消耗的油最少，可以递归的判断对于每个子节点，汇集到该节点的人一共有多少，那么也就是该节点的子节点数量 $count$，<strong>并且每次都可以取汇集到该节点的所有人到下一个节点最少需要花费的油量</strong> $ceil(\frac{count}{seats})$ 视为该节点的贡献，最后累加所有节点的贡献就为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt;[] g;<br>    <span class="hljs-type">int</span> seats;<br>    <span class="hljs-type">long</span> ans;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumFuelCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] roads, <span class="hljs-type">int</span> seats)</span> &#123;<br>        <span class="hljs-keyword">if</span>(roads.length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.seats = seats;<br>        g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[roads.length + <span class="hljs-number">1</span>];<br>        IntStream.range(<span class="hljs-number">0</span>, roads.length + <span class="hljs-number">1</span>).forEach(i -&gt; g[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] road : roads)&#123;<br>            g[road[<span class="hljs-number">0</span>]].add(road[<span class="hljs-number">1</span>]);<br>            g[road[<span class="hljs-number">1</span>]].add(road[<span class="hljs-number">0</span>]);<br>        &#125;<br>        dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> father)</span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> item : g[p])&#123;<br>            <span class="hljs-keyword">if</span>(item == father)&#123; <span class="hljs-comment">// 题目给的双向边，避免死循环重复遍历</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            size += dfs(item, p);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 0节点不需要计算，所有人都到达了</span><br>            ans += Math.ceil((<span class="hljs-type">double</span>)size / seats); <span class="hljs-comment">// 向上取整等价于 （size + seats - 1) / seats</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-799.香槟塔</title>
    <link href="/2022/11/20/LC-799-%E9%A6%99%E6%A7%9F%E5%A1%94/"/>
    <url>/2022/11/20/LC-799-%E9%A6%99%E6%A7%9F%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/champagne-tower/">leetcode 中等题</a></p><p>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。</p><p><img src="/../img/Snipaste_2022-11-20_20-06-33.png" alt="leetcode"></p><p>现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（ i 和 j 都从0开始）。</p><p>示例1：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">示例 1</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0.00000</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span> <span class="hljs-string">我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入: <span class="hljs-built_in">poured</span>(倾倒香槟总杯数) = <span class="hljs-number">2</span>, <span class="hljs-built_in">query_glass</span>(杯子的位置数) = <span class="hljs-number">1</span>, <span class="hljs-built_in">query_row</span>(行数) = <span class="hljs-number">1</span><br>输出: <span class="hljs-number">0.50000</span><br>解释: 我们在顶层（下标是（<span class="hljs-number">0</span>，<span class="hljs-number">0</span>）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（<span class="hljs-number">1</span>，<span class="hljs-number">0</span>）的玻璃杯和（<span class="hljs-number">1</span>，<span class="hljs-number">1</span>）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。<br></code></pre></td></tr></table></figure><p>示例3:</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: poured = <span class="hljs-number">100000009</span>, query_row = <span class="hljs-number">33</span>, query_glass = <span class="hljs-number">17</span><br>输出: <span class="hljs-number">1.00000</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= poured &lt;= <span class="hljs-number">109</span><br><span class="hljs-symbol">0 </span>&lt;= query_glass &lt;= query_row &lt; <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>首先需要知道除了最上层的杯子，其余所有杯子 $[i, j]$ 的香槟均来自上一层的杯子 $[i - 1, j]$ 和 $[i - 1, j + 1]$，并且当该杯子满后（超过$1$），流出的水会等量的流向下一层 $[i + 1, j]$ 和 $[i + 1, j + 1]$。</p><p>dp，定义 $f(i, j)$ 表示流过该层的香槟总量，那么 $f(0, 0)$ 为 $poured$，可以得到</p><p>$$<br>\begin{align}<br>&amp;f(i + 1, j) +&#x3D; \frac{f(i, j) - 1}{2}\\<br>&amp;f(i + 1, j + 1) +&#x3D; \frac{f(i, j) - 1}{2}\\<br>\end{align}<br>$$</p><p>$min(1, f(queryRow, queryGlass))$ 为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">champagneTower</span><span class="hljs-params">(<span class="hljs-type">int</span> poured, <span class="hljs-type">int</span> query_row, <span class="hljs-type">int</span> query_glass)</span> &#123;<br>        <span class="hljs-type">double</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[query_row + <span class="hljs-number">1</span>][query_row + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = poured;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; query_row; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(dp[i][j] &lt;= <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i + <span class="hljs-number">1</span>][j] += (dp[i][j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] += (dp[i][j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(dp[query_row][query_glass], <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，每层的香槟流量，只依赖于上一层，所以可以用滚动数组的方式进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">champagneTower</span><span class="hljs-params">(<span class="hljs-type">int</span> poured, <span class="hljs-type">int</span> query_row, <span class="hljs-type">int</span> query_glass)</span> &#123;<br>        <span class="hljs-type">double</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[query_row + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = poured;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; query_row; i++)&#123;<br>            <span class="hljs-type">double</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[query_row + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(dp[j] &lt;= <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                temp[j] += (dp[j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                temp[j + <span class="hljs-number">1</span>] += (dp[j] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            &#125;<br>            dp = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(dp[query_glass], <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6242.二叉搜索树最近节点查询</title>
    <link href="/2022/11/20/LC-6242-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E8%8A%82%E7%82%B9%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/11/20/LC-6242-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E8%8A%82%E7%82%B9%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/">leetcode 中等题</a></p><p>给你一个 二叉搜索树 的根节点 root ，和一个由正整数组成、长度为 n 的数组 queries 。</p><p>请你找出一个长度为 n 的 二维 答案数组 answer ，其中 answer[i] &#x3D; [mini, maxi] ：</p><p>mini 是树中小于等于 queries[i] 的 最大值 。如果不存在这样的值，则使用 -1 代替。<br>maxi 是树中大于等于 queries[i] 的 最小值 。如果不存在这样的值，则使用 -1 代替。<br>返回数组 answer 。</p><p>示例1：</p><p><img src="/../img/Snipaste_2022-11-20_23-04-47.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]<br>输出：[[2,2],[4,6],[15,-1]]<br>解释：按下面的描述找出并返回查询的答案：<br>- 树中小于等于<span class="hljs-number"> 2 </span>的最大值是<span class="hljs-number"> 2 </span>，且大于等于<span class="hljs-number"> 2 </span>的最小值也是<span class="hljs-number"> 2 </span>。所以第一个查询的答案是 [2,2] 。<br>- 树中小于等于<span class="hljs-number"> 5 </span>的最大值是<span class="hljs-number"> 4 </span>，且大于等于<span class="hljs-number"> 5 </span>的最小值是<span class="hljs-number"> 6 </span>。所以第二个查询的答案是 [4,6] 。<br>- 树中小于等于<span class="hljs-number"> 16 </span>的最大值是<span class="hljs-number"> 15 </span>，且大于等于<span class="hljs-number"> 16 </span>的最小值不存在。所以第三个查询的答案是 [15,-1] 。<br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">树中节点的数目在范围 <span class="hljs-selector-attr">[2, 105]</span> 内<br><span class="hljs-number">1</span> &lt;= Node<span class="hljs-selector-class">.val</span> &lt;= <span class="hljs-number">106</span><br>n == queries<span class="hljs-selector-class">.length</span><br><span class="hljs-number">1</span> &lt;= n &lt;= <span class="hljs-number">105</span><br><span class="hljs-number">1</span> &lt;= queries<span class="hljs-selector-attr">[i]</span> &lt;= <span class="hljs-number">106</span><br></code></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>需要注意的是题目给的是二叉查找树而不是平衡树，如果直接在树上查找的话，某些数据下树可能会退化成链表导致 TLE。</p><p>中序遍历树得到排序后的数组，再二分查找出 $min_x$ 以及 $max_x$ 即可。</p><p>可以通过两次左闭右开的二分查找分别通过缩小右边界、左边界获得 $min_x$ 和 $max_x$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">closestNodes</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; queries)</span> &#123;<br>        List&lt;Integer&gt; sort = dfs(root, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sort.size();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.size(); i++)&#123;<br>            List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n, target = queries.get(i);<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(sort.get(mid) &lt; target)&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sort.get(mid) &gt;= target)&#123;<br>                    right = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left &lt; n &amp;&amp; sort.get(left) == target)&#123;<br>                cur.add(sort.get(left));<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)&#123;<br>                cur.add(sort.get(left - <span class="hljs-number">1</span>));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.add(-<span class="hljs-number">1</span>);<br>            &#125;<br>            left = <span class="hljs-number">0</span>;<br>            right = n;<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(sort.get(mid) &lt;= target)&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sort.get(mid) &gt; target)&#123;<br>                    right = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; sort.get(left - <span class="hljs-number">1</span>) == target)&#123;<br>                cur.add(sort.get(left - <span class="hljs-number">1</span>));<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left &lt; n)&#123;<br>                cur.add(sort.get(left));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.add(-<span class="hljs-number">1</span>);<br>            &#125;<br>            ans.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; sort)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> sort;<br>        &#125;<br>        dfs(root.left, sort);<br>        sort.add(root.val);<br>        dfs(root.right, sort);<br>        <span class="hljs-keyword">return</span> sort;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然也可以通过缩小右边界一次性得到 $min_x$ 和 $max_x$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">closestNodes</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; queries)</span> &#123;<br>        List&lt;Integer&gt; sort = dfs(root, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sort.size();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.size(); i++)&#123;<br>            List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n, target = queries.get(i);<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(sort.get(mid) &lt; target)&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    right = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left &lt; n &amp;&amp; sort.get(left) == target)&#123;<br>                cur.add(sort.get(left));<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)&#123;<br>                cur.add(sort.get(left - <span class="hljs-number">1</span>));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.add(-<span class="hljs-number">1</span>);<br>            &#125;                       <br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (left &lt; n ? sort.get(left) : -<span class="hljs-number">1</span>);      <br>            cur.add(b);<br>            ans.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; sort)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> sort;<br>        &#125;<br>        dfs(root.left, sort);<br>        sort.add(root.val);<br>        dfs(root.right, sort);<br>        <span class="hljs-keyword">return</span> sort;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缩小左边界一次性得到 $min_x$ 和 $max_x$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 二分查找通过缩小左边界一次性得到 min_x 和 min_y</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">closestNodes</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; queries)</span> &#123;<br>        List&lt;Integer&gt; sort = dfs(root, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sort.size();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.size(); i++)&#123;<br>            List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n, target = queries.get(i);<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(sort.get(mid) &gt; target)&#123;<br>                    right = mid;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> ? sort.get(left - <span class="hljs-number">1</span>) : -<span class="hljs-number">1</span>);<br>            cur.add(a);<br>            <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; sort.get(left - <span class="hljs-number">1</span>) == target)&#123;<br>                cur.add(sort.get(left - <span class="hljs-number">1</span>));<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left &lt; n)&#123;<br>                cur.add(sort.get(left));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.add(-<span class="hljs-number">1</span>);<br>            &#125;<br>            ans.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; sort)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> sort;<br>        &#125;<br>        dfs(root.left, sort);<br>        sort.add(root.val);<br>        dfs(root.right, sort);<br>        <span class="hljs-keyword">return</span> sort;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-792.匹配子序列的单词数</title>
    <link href="/2022/11/18/LC-792-%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
    <url>/2022/11/18/LC-792-%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/number-of-matching-subsequences/">leetcode 中等题</a></p><p>给定字符串 s 和字符串数组 words, 返回  words[i] 中是s的子序列的单词个数 。</p><p>字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。</p><ul><li>例如， “ace” 是 “abcde” 的子序列。</li></ul><p>示例1：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入: s = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>,<span class="hljs-string">&quot;acd&quot;</span>,<span class="hljs-string">&quot;ace&quot;</span>]<br>输出: <span class="hljs-number">3</span><br>解释: 有三个是 s 的子序列的单词: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;acd&quot;</span>, <span class="hljs-string">&quot;ace&quot;</span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入: s = <span class="hljs-string">&quot;dsahjpjauf&quot;</span>, <span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;ahjpjau&quot;</span>,<span class="hljs-string">&quot;ja&quot;</span>,<span class="hljs-string">&quot;ahbwzgqnuk&quot;</span>,<span class="hljs-string">&quot;tnmlanowax&quot;</span>]<br>输出: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1</span> &lt;= s.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">5</span> * <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">words</span>.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">5000</span><br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">words</span>[i].<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">50</span><br><span class="hljs-built_in">words</span>[i]和 s 都只由小写字母组成。<br></code></pre></td></tr></table></figure><h2 id="分桶-二分查找-（贪心）"><a href="#分桶-二分查找-（贪心）" class="headerlink" title="分桶 + 二分查找 （贪心）"></a>分桶 + 二分查找 （贪心）</h2><p>最容易想到的方法就是对于每个 $word$ ，通过双指针的方法和 $s$ 进行匹配，指针 $i$ 和 $j$ 初始时分别指向 $word$ 和 $a$ 的第 $0$ 位字符，如果匹配成功则将两个指针分别向后移动，否则只移动 $j$，如果 $i$ 能匹配结束的话则 $ans$ 加一。</p><p>但是该方法在该题的数据规模下会 TLE，所以需要进行优化。</p><p>一种方法是我们可以将 $s$ 按照每个字符进行分桶，每个桶内存储该字符在 $s$ 内从小到大排列后的索引值。那么对于每个 $word$ 我们都会进行一轮遍历，每一轮都独立维护一个 $next$ 值，并在每次 $i$ 指针后移时，尝试通过二分查找得到当前 $i$ 所指向字符的对应桶内第一个大于 $next$ 的索引值（贪心思路，目的是让每次的 $next$ 都尽量小），然后将 $next$ 更新为该索引值，过程中若不存在大于 $next$ 的索引值则匹配失败，若能匹配结束则 $ans$ 加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numMatchingSubseq</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br>        Map&lt;Character, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            List&lt;Integer&gt; list = map.computeIfAbsent(c, ArrayList::<span class="hljs-keyword">new</span>);<br>            list.add(i);<br>            map.put(c, list);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++)&#123;<br>            <span class="hljs-type">char</span>[] item = words[i].toCharArray();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; item.length; j++)&#123;<br>                List&lt;Integer&gt; list = map.getOrDefault(item[j], <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                <span class="hljs-comment">// 二分查找第一个大于 target 的数</span><br>                <span class="hljs-comment">// 也就是右边界 + 1, 右边界为 left - 1, 右边界 &lt;= target</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = list.size();<br>                <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + right &gt;&gt; <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(list.get(mid) &lt;= next)&#123;<br>                        left = mid + <span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list.get(mid) &gt; next)&#123;<br>                        right = mid;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(left &lt; list.size())&#123;<br>                    next = list.get(left);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似上面的思路，我们也可以对于每个 $word$ 进行逆序遍历，只需要在二分查找时改成找到第一个小于 $i$ 的索引值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numMatchingSubseq</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br>        Map&lt;Character, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            List&lt;Integer&gt; list = map.computeIfAbsent(c, ArrayList::<span class="hljs-keyword">new</span>);<br>            list.add(i);<br>            map.put(c, list);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++)&#123;<br>            <span class="hljs-type">char</span>[] item = words[i].toCharArray();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> item.length - <span class="hljs-number">1</span>; j &gt;=<span class="hljs-number">0</span>; j--)&#123;<br>                List&lt;Integer&gt; list = map.getOrDefault(item[j], <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                <span class="hljs-comment">// 二分查找第一个小于 target 的数</span><br>                <span class="hljs-comment">// 也就是左边界 - 1, 左边界为 left, 左边界 &gt;= target</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = list.size();<br>                <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + right &gt;&gt; <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(list.get(mid) &lt; next)&#123;<br>                        left = mid + <span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list.get(mid) &gt;= next)&#123;<br>                        right = mid;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; left - <span class="hljs-number">1</span> &lt; list.size())&#123;<br>                    next = list.get(left - <span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分桶-多指针"><a href="#分桶-多指针" class="headerlink" title="分桶 + 多指针"></a>分桶 + 多指针</h2><p>上面的做法的思路是对 $s$ 按字符进行分桶，从而加速每一个 $word$ 与 $s$ 之间的匹配速度，相当于每个 $word$ 都会独立匹配一次。</p><p>而另一种做法的思路是将 $s$ 同时与所有 $word$ 进行匹配。具体来说每一个 $word$ 都有着独立的指针 $i$ ，并且初始值为 0，那么对每一个 $word$ 按照当前匹配到的字符，也就是各自 $i$ 指针指向的字符进行分桶。那么我们就可以直接遍历 $s$，每次只需要将 $j$ 所指向字符的对应桶内的所有 $word$ 拿出来并将它们的 $i$ 指针往后移动一位，然后重新维护桶即可，而若当前取出的 $word$ 对应的 $i$ 已经到达结尾，则 $ans$ 加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numMatchingSubseq</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt;[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>            bucket[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; ++i) &#123;<br>            bucket[words[i].charAt(<span class="hljs-number">0</span>) - <span class="hljs-string">&#x27;a&#x27;</span>].offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, <span class="hljs-number">0</span>&#125;);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> bucket[c - <span class="hljs-string">&#x27;a&#x27;</span>].size();<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span>[] item = bucket[c - <span class="hljs-string">&#x27;a&#x27;</span>].poll();<br>                <span class="hljs-keyword">if</span> (item[<span class="hljs-number">1</span>] == words[item[<span class="hljs-number">0</span>]].length() - <span class="hljs-number">1</span>) &#123;<br>                    ++ans;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ++item[<span class="hljs-number">1</span>];<br>                    bucket[words[item[<span class="hljs-number">0</span>]].charAt(item[<span class="hljs-number">1</span>]) - <span class="hljs-string">&#x27;a&#x27;</span>].offer(item);<br>                &#125;<br>                --size;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二分查找</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-891.子序列宽度之和</title>
    <link href="/2022/11/18/LC-891-%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/11/18/LC-891-%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/sum-of-subsequence-widths/">leetcode 困难题</a></p><p>一个序列的 宽度 定义为该序列中<strong>最大元素和最小元素的差值</strong>。</p><p>给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 1e9 + 7 取余 后的结果。</p><p>子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,1,3]</span><br>输出：6<br>解释：子序列为 <span class="hljs-comment">[1]</span>, <span class="hljs-comment">[2]</span>, <span class="hljs-comment">[3]</span>, <span class="hljs-comment">[2,1]</span>, <span class="hljs-comment">[2,3]</span>, <span class="hljs-comment">[1,3]</span>, <span class="hljs-comment">[2,1,3]</span> 。<br>相应的宽度是 0, 0, 0, 1, 1, 2, 2 。<br>宽度之和是 6 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>提示1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">105</span><br><span class="hljs-symbol">1 </span>&lt;= nums[i] &lt;= <span class="hljs-number">105</span><br></code></pre></td></tr></table></figure><h2 id="考虑每个元素的贡献"><a href="#考虑每个元素的贡献" class="headerlink" title="考虑每个元素的贡献"></a>考虑每个元素的贡献</h2><p>考虑到数据范围，肯定是无法通过求具体的子序列来得到答案的。</p><p>我们可以考虑每个元素对答案的贡献来得到最终的答案。并且由于宽度为序列中最大元素和最小元素的差值，那么也就是说每个元素只有在作为某个序列的最小值或者最大值时，才会在该序列中对答案有贡献。容易想到先对数组进行排序，那么排序后就能可以得到以某个 $nums[i]$ 为最大值的序列一共有 $2^i$ 个，因为左边的每个元素都可以选或者不选，即一共会有 $2 \times 2 \times 2 … \times 2$ 个；同理右边就有 $2 ^{j-i-1}$ 个以 $num[i]$ 作为最小值的序列。</p><p>需要注意的是，根据题意，长度为 1 的序列是没有贡献的，所以 $nums[i]$ 的左边不能全部不选，右边也不能全部不选，也就是说，以 $nums[i]$ 作为最大值或最小值的序列数量均需要分别减一。</p><p>那么就可以得到，每个元素对答案的贡献为 $nums[i] \times (2^i - 1 - (2^{j-i-1} - 1) )$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumSubseqWidths</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span>[] pow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        pow[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            pow[i] = pow[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> % MOD;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            ans = (ans + (nums[i] * (pow[i] - <span class="hljs-number">1</span> - pow[n - i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)))% MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(ans % MOD);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>脑筋急转弯/找规律</tag>
      
      <tag>贡献法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-775.全局倒置与局部倒置</title>
    <link href="/2022/11/16/LC-775-%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/"/>
    <url>/2022/11/16/LC-775-%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/global-and-local-inversions/">leetcode 中等题</a></p><p>给你一个长度为 n 的整数数组 nums ，表示由范围 [0, n - 1] 内所有整数组成的一个排列。</p><p>全局倒置 的数目等于满足下述条件不同下标对 (i, j) 的数目：</p><ul><li>0 &lt;&#x3D; i &lt; j &lt; n</li><li>nums[i] &gt; nums[j]</li></ul><p>局部倒置 的数目等于满足下述条件的下标 i 的数目：</p><ul><li>0 &lt;&#x3D; i &lt; n - 1</li><li>nums[i] &gt; nums[i + 1]</li></ul><p>当数组 nums 中 全局倒置 的数量等于 局部倒置 的数量时，返回 true ；否则，返回 false 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,0,2]<br>输出：true<br>解释：有<span class="hljs-number"> 1 </span>个全局倒置，和<span class="hljs-number"> 1 </span>个局部倒置。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,0]<br>输出：false<br>解释：有<span class="hljs-number"> 2 </span>个全局倒置，和<span class="hljs-number"> 1 </span>个局部倒置。<br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">n</span> == nums.length<br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-number">0</span> &lt;= nums[i] &lt; <span class="hljs-built_in">n</span><br>nums 中的所有整数 互不相同<br>nums 是范围 [<span class="hljs-number">0</span>, <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>] 内所有数字组成的一个排列<br></code></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>这道题最容易且方便的做法是，逆序遍历且维护一个 $[i + 2, n]$ 的最小值，如果当前元素大于该最小值返回 $false$ ，如果顺利遍历结束返回 $true$ 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIdealPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> nums[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">3</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; min)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;         <br>            <span class="hljs-comment">// 判断后再更新 min，相当于维护的是 [i + 2, n] 的最小值 </span><br>            min = Math.min(min, nums[i + <span class="hljs-number">1</span>]); <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>但是对于求 <a href="https://zh.m.wikipedia.org/zh-hans/%E9%80%86%E5%BA%8F%E5%AF%B9">逆序对</a> 更加通用的做法是使用 <a href="https://www.acwing.com/blog/content/80/">树状数组</a>。</p><p>首先我们需要构造一个原数组元素到排名的映射，因为这里的 $0 &lt;&#x3D; nums[i] &lt; n$，所以可以使用数组，更加通用的做法是使用 $Map$。</p><p>构建完映射之后只需要顺序遍历原数组（当然逆序也行，只需要修改下查询的方式），再通过查询树状数组的前缀和，就能够得到前面元素比当前元素排名更大的数量，也就是逆序对的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIdealPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 构造 nums[i] 到 排名 的一个映射，更通用的做法是用 Map&lt;&gt;</span><br>        <span class="hljs-type">int</span>[] sort = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        System.arraycopy(nums, <span class="hljs-number">0</span>, sort, <span class="hljs-number">0</span>, n);<br>        Arrays.sort(sort);<br>        <span class="hljs-type">int</span>[] rank = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            rank[sort[i - <span class="hljs-number">1</span>]] = i;<br>        &#125;<br>        <span class="hljs-comment">// 遍历原数组，统计并更新逆序对数量</span><br>        <span class="hljs-type">FenwickTree</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FenwickTree</span>(nums.length);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">local</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, global = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rank[nums[i]];<br>            global += t.query(n) - t.query(r); <span class="hljs-comment">// 逆序对数量/前缀和/前面元素比当前元素排名大的数量</span><br>            t.update(r, <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 局部倒置</span><br>            <span class="hljs-keyword">if</span>(i != n - <span class="hljs-number">1</span> &amp;&amp; nums[i] &gt; nums[i + <span class="hljs-number">1</span>])&#123;<br>                local += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> local == global;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FenwickTree</span>&#123;<br>        <span class="hljs-type">int</span>[] c;<br><br>        FenwickTree(<span class="hljs-type">int</span> size)&#123;<br>            c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size + <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> updateValue)</span>&#123;<br>            <span class="hljs-keyword">while</span>(index &lt; c.length)&#123;<br>                c[index] += updateValue;<br>                index += lowbit(index);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(index &gt; <span class="hljs-number">0</span>)&#123;<br>                ans += c[index];<br>                index -= lowbit(index); <br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>            <span class="hljs-keyword">return</span> x &amp; -x;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>同样由于这里的 $0 &lt;&#x3D; nums[i] &lt; n$，所以其实可以省去排序的步骤，直接将树状数组的大小初始化为 $n$ 即可。</p><p>另外需要注意的是由于树状数组的第 $0$ 位并不存储元素（因为 $lowbit(0) &#x3D; 0$，存储的话会导致循环条件要特殊处理），但是 $nums[i]$ 是会取到 $0$ 的，所以我们每次加入树状数组时再手动加上 $1$ 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIdealPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">FenwickTree</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FenwickTree</span>(nums.length);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">local</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, global = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> nums[i] + <span class="hljs-number">1</span>;      <br>            global += t.query(n) - t.query(item);<br>            t.update(item, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(i != n - <span class="hljs-number">1</span> &amp;&amp; nums[i] &gt; nums[i + <span class="hljs-number">1</span>])&#123;<br>                local += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> local == global;<br>    &#125;<br>    <span class="hljs-comment">// FenwickTree 代码同上</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-805.数组的均值分割</title>
    <link href="/2022/11/14/LC-805-%E6%95%B0%E7%BB%84%E7%9A%84%E5%9D%87%E5%80%BC%E5%88%86%E5%89%B2/"/>
    <url>/2022/11/14/LC-805-%E6%95%B0%E7%BB%84%E7%9A%84%E5%9D%87%E5%80%BC%E5%88%86%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/split-array-with-same-average/">leetcode 困难题</a></p><p>给定你一个整数数组 nums</p><p>我们要将 nums 数组中的每个元素移动到 A 数组 或者 B 数组中，使得 A 数组和 B 数组不为空，并且 average(A) &#x3D;&#x3D; average(B) 。</p><p>如果可以完成则返回true ， 否则返回 false  。</p><p>注意：对于数组 arr ,  average(arr) 是 arr 的所有元素除以 arr 长度的和。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: nums = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>]<br>输出: true<br>解释: 我们可以将数组分割为 [<span class="hljs-number">1,4,5,8</span>] 和 [<span class="hljs-number">2,3,6,7</span>], 他们的平均值都是<span class="hljs-number">4</span>.<span class="hljs-number">5</span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [3,1]</span><br><span class="hljs-section">输出: false</span><br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">30</span><br><span class="hljs-symbol">0 </span>&lt;= nums[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设我们移动了 $k$ 个元素到数组 $A$ 中，移动了 $k_2$ 或者说 $n-k$ 个元素到数组 $B$ 中，分割后的数组为 $A$ 和 $B$，且${sum}(A)$， ${sum}(B)$， ${sum}(nums)$ 分别表示数组 $A$， $B$， $nums$ 的元素和，由于数组 $A$，$B$ 的平均值相等，可以推出：</p><p>$$<br>\begin{align}<br>&amp;\frac{sum(A)}{k} &#x3D; \frac{sum(B)}{n-k}\\<br>\Leftrightarrow &amp; sum(A) \times n - sum(A) \times k &#x3D; sum(B) \times k\\<br>\Leftrightarrow &amp; sum(A) \times n &#x3D; (sum(B) + sum(A)) \times k\\<br>\Leftrightarrow &amp; sum(A) \times n &#x3D; (sum(nums)) \times k\\<br>\Leftrightarrow &amp; \frac{sum(A)}{k} &#x3D; \frac{sum(nums)}{n}\\<br>\end{align}<br>$$</p><p>也就是说如果存在子数组 $A$，$B$ 的平均值相等，则该平均值必然还会等于 $nums$ 的平均值。</p><p><strong>并且我们只需要求出是否存在一个子数组的平均值等于原数组平均值即可</strong>，因为如果存在一个子数组平均值等于原数组平均值的话：<br>$$<br>\begin{align}<br>&amp;\frac{sum(nums)}{n} &#x3D; \frac{sum(A)}{k}\\<br>\Leftrightarrow &amp; \frac{sum(A) + sum(B)}{k + k_2} &#x3D; \frac{sum(A)}{k}\\<br>\Leftrightarrow &amp; \frac{sum(A) + sum(B)}{k_2} &#x3D; \frac{sum(A) \times (k + k_2)}{k \times k_2}\\<br>\Leftrightarrow &amp; \frac{sum(B)}{k_2} &#x3D; \frac{sum(A) \times (k + k_2) - (sum(A) \times k)}{k \times k_2}\\<br>\Leftrightarrow &amp; \frac{sum(B)}{k_2} &#x3D; \frac{sum(A) \times k_2 }{k \times k_2}\\<br>\Leftrightarrow &amp; \frac{sum(B)}{k_2} &#x3D; \frac{sum(A)}{k}\\<br>\end{align}<br>$$<br>可以得出剩余元素组成的子数组的平均值也为原数组平均值。</p><p>那么问题变成求是否存在子数组平均值等于原数组，容易想到的思路是枚举每个子数组，此时一共有 $2^n$ 种方案（每个元素取或不取），由于题目中 <code>n</code> 最大是 <code>30</code>，会 TLE。</p><p>我们可以使用折半查找的方法，将时间复杂度降低到 $O(2^\frac{n}{2})$。</p><p>我们将数组 $nums$ 分成左右两部分，那么子数组 $A$ 可能存在三种情况：</p><ul><li>子数组 $A$ 完全在数组 $nums$ 的左半部分；</li><li>子数组 $A$ 完全在数组 $nums$ 的右半部分；</li><li>子数组 $A$ 一部分在数组 $nums$ 的左半部分，一部分在数组 $nums$ 的右半部分。</li></ul><p>我们分两次来处理数组，每次处理一部分。<br>如果是前两种情况比较好处理，我们只需要在处理对应部分数组时计算平均值，再与原数组的平均值比较即可。</p><p>但如果是第三种情况，则要等我们在处理右半部分时，回过头来通过某种方式搜索左边是否存在符合我们预期的方案（无法简单的通过在哈希表中保存总和来求，因为还和左边数组取了几个有关系），即会花费额外的时间（可能TLE）又难实现。</p><p>所以我们可以将数组 ${nums}$ 中的每个元素减去 $nums$ 的平均值，这样数组的平均值则变为 <code>0</code>。那么此时题目中的问题则变为：能否从 $nums$ 中找出若干个元素组成集合 $A$，使得 $A$ 的元素之和为 <code>0</code>。</p><p>但是如果直接减去 $\frac{sum(nums)}{n}$ 会引进浮点数，如果在 <code>Java</code> 中直接使用 <code>double</code> 进行运算，会因为浮点数的误差出现WA，所以更好的方案是先将 $nums$ 中的每个元素乘以 $n$ 后再减去数组总和，也就是：<br>$$<br>\begin{align}<br>&amp;nums[i] &#x3D; nums[i] - \frac{sum(nums)}{n}\\<br>\Rightarrow &amp;nums[i] &#x3D; nums[i] \times n - \frac{sum(nums) \times n}{n}\\<br>\end{align}<br>$$<br>这样就不会出现浮点数了。</p><p>这样处理后，如果是第一、二种情况，我们只需要在遍历时判断当前方案总和是否等于 $0$ 即可，如果是就直接返回。对于第三种情况，我们也只需要在遍历左边部分时额外再把当前方案的总和保存到哈希表中，然后在遍历右边部分数组的时候，如果当前总和是 $curSum$ ，判断哈希表是否存在 $-curSum$ 即可。</p><p>另外需要注意的是，我们不能同时选择左右两边的所有元素，这样数组 $B$ 就为空了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">splitArraySameAverage</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, m = nums.length / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            nums[i] = nums[i] * n - sum; <span class="hljs-comment">// 避免浮点数</span><br>        &#125;<br>        Set&lt;Integer&gt; exist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; m); i++)&#123; <span class="hljs-comment">// 2 ^（n/2）个方案</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                <span class="hljs-keyword">if</span>((i &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 当前位为 1 代表当前位被选到了，例如 011 代表该轮只选择第一个和第二个元素</span><br>                    curSum += nums[j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(curSum == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            exist.add(curSum);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m; i &lt; n; i++) &#123;<br>            rSum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; (n - m)); i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>((i &amp; (<span class="hljs-number">1</span> &lt;&lt; (j - m))) != <span class="hljs-number">0</span>)&#123;<br>                    curSum += nums[j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(curSum == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(curSum != rSum &amp;&amp; exist.contains(-curSum))&#123; <span class="hljs-comment">// 第一个判断是因为不能同时选择左右两边的所有元素</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>折半搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6236.不重叠回文子字符串的最大数目</title>
    <link href="/2022/11/13/LC-6236-%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/11/13/LC-6236-%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/">leetcode 困难题</a></p><p>给你一个字符串 s 和一个 正 整数 k 。</p><p>从字符串 s 中选出一组满足下述条件且 不重叠 的子字符串：</p><ul><li>每个子字符串的长度 至少 为 k 。</li><li>每个子字符串是一个 回文串 。<br>返回最优方案中能选择的子字符串的 最大 数目。</li></ul><p>子字符串 是字符串中一个连续的字符序列。</p><p><strong>字符串之间互不重叠，也就是说对于任意两个子字符串 s[i..j] 和 s[x..y] ，要么 j &lt; x 要么 i &gt; y 。</strong></p><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abaccdbbd&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：可以选择 <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abaccdbbd&quot;</span> 中斜体加粗的子字符串。<span class="hljs-string">&quot;aba&quot;</span> 和 <span class="hljs-string">&quot;dbbd&quot;</span> 都是回文，且长度至少为 <span class="hljs-attr">k</span> = <span class="hljs-number">3</span> 。<br>可以证明，无法选出两个以上的有效子字符串。<br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">提示：<br><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> k &lt;<span class="hljs-operator">=</span> s.length &lt;<span class="hljs-operator">=</span> <span class="hljs-number">2000</span><br>s 仅由小写英文字母组成<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>我们可以通过两次动态规划得出结果，其中第一次动态规划处理出某个子串 <code>s(i, j)</code> 是否为回文串，第二次动态规划处理如何划分得到最多的不重叠子字符串。</p><hr><p>第一次 <code>dp</code>，定义 <code>f(i, j)</code> 表示子串 <code>s(i, j)</code> 是否为回文串，那么可以得到转移方程：</p><p><code>f(i, j) = s[i] == s[j]</code>，当 <code>j - i &lt;= 1</code> 时</p><p><code>f(i, j) = f(i + 1, j - 1) &amp;&amp; (s[i] == s[j])</code>，当 <code>j - i &gt; 1</code> 时</p><hr><p>第二次 <code>dp</code>，定义 <code>f(i)</code> 表示 <code>s(0, i)</code> 的最多不重叠回文子串数量，那么 <code>f(n)</code> 为答案。</p><p>对于某个 <code>f(i)</code>，可以分两种情况讨论：</p><p>如果 <code>s[i]</code> 不在任意回文子串内的话，那么 <code>f(i) = f(i - 1)</code>，可以作为 <code>f(i)</code> 的初始值。</p><p>如果 <code>s[i]</code> 在某个回文子串内时，枚举左端点 <code>left</code>，可以得到：<br><code>当 s(left, i) 为回文串，f(i) = Max(f(i), f(left - 1) + 1)</code>，其中<code>left</code> 取值范围为 <code>i - left + 1 &gt;= k</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPalindromes</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] c = s.toCharArray();<br>        <span class="hljs-type">boolean</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n + <span class="hljs-number">1</span>; j++)&#123;<br>                <span class="hljs-keyword">if</span>(c[i - <span class="hljs-number">1</span>] == c[j - <span class="hljs-number">1</span>] &amp;&amp; (j - i &lt;= <span class="hljs-number">1</span> || g[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]))&#123;<br>                    g[i][j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            f[i] = f[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// i不参与</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i - k + <span class="hljs-number">1</span>; left &gt;= <span class="hljs-number">1</span>; left--)&#123;<br>                <span class="hljs-keyword">if</span>(g[left][i])&#123;<br>                    f[i] = Math.max(f[i], f[left - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-790.多米诺和托米诺平铺</title>
    <link href="/2022/11/12/LC-790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/"/>
    <url>/2022/11/12/LC-790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/domino-and-tromino-tiling/">leetcode 中等题</a></p><p>有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。<br><img src="/../img/1668239955779.jpg"></p><p>给定整数 n ，返回可以铺满 2 x n 的面板的方法的数量。返回对 10e9 + 7 取模 的值。</p><p><strong>注意下图中的 1-3 方案，是白色瓷砖而不是没铺满，不要产生误解</strong></p><p><img src="/../img/1668239825809.jpg"></p><h2 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h2><ul><li>f(1) &#x3D; 1</li><li>f(2) &#x3D; 2</li><li>f(3) &#x3D; 5</li><li>f(4) &#x3D; 11 &#x3D; 5 * 2 + 1 &#x3D; f(3) * 2 + f(1)</li><li>f(5) &#x3D; 24 &#x3D; 11 * 2 + 2 &#x3D; f(4) * 2 + f(2)</li></ul><p>得出 <code>f(i) = 2 * (f - i) + f(i - 3)</code>，其中 <code>i &gt; 3</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">10</span>];<br>        f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        f[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; i &lt;= n; i++)&#123;<br>            f[i] = (((<span class="hljs-number">2</span> * f[i - <span class="hljs-number">1</span>]) % MOD) + f[i - <span class="hljs-number">3</span>]) % MOD;<br>        &#125;        <br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="找规律-滚动数组"><a href="#找规律-滚动数组" class="headerlink" title="找规律 + 滚动数组"></a>找规律 + 滚动数组</h2><p>可以发现最多会往前依赖到 <code>i - 3</code>，那么只需要保存最近的三个结果即可。</p><p>但这里为了方便（抖机灵），保存了 <code>4</code> 个结果。因为对 <code>2</code> 的 <code>n</code> 次方的取模运算，可以转换成对 <code>n - 1</code> 的与运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br>        f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        f[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> i &amp; <span class="hljs-number">3</span>, pre = i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">3</span>, magic = i - <span class="hljs-number">3</span> &amp; <span class="hljs-number">3</span>;<br>            f[cur] = (((<span class="hljs-number">2</span> * f[pre]) % MOD) + f[magic]) % MOD;<br>        &#125;        <br>        <span class="hljs-keyword">return</span> f[n &amp; <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种类型的题目由于结果固定，且数据范围有限，还能用第一种解法 + 打表对结果进行保存，由于做法类似就不在这里列出了。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>定义 <code>dp[i][j]</code> 为： 在第 <code>i</code> 列前面的正方形都被瓷砖覆盖，当前第 <code>i</code> 列状态为 <code>j</code> 时的方案数。那么第 <code>i</code> 列的正方形有四种（即 <code>j</code> 取值范围）被覆盖的情况：</p><p>第 <code>i</code> 列为空，<code>j</code> 为 <code>0</code>；</p><p>第 <code>i</code> 列上方格子为空，<code>j</code>为 <code>1</code>；</p><p>第 <code>i</code> 列下方格子为空，<code>j</code>为 <code>2</code>；</p><p>第 <code>i</code> 列为满，<code>j</code>为 <code>3</code>。</p><p>那么状态转移如下:</p><p><img src="/../img/20221112170609.png" alt="https://leetcode.cn/problems/domino-and-tromino-tiling/solution/duo-mi-nuo-he-tuo-mi-nuo-ping-pu-by-leet-7n0j/"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>            dp[i][<span class="hljs-number">1</span>] = (dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) % MOD;<br>            dp[i][<span class="hljs-number">2</span>] = (dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % MOD;<br>            dp[i][<span class="hljs-number">3</span>] = (((dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]) % MOD + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % MOD + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][<span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划-滚动数组"><a href="#动态规划-滚动数组" class="headerlink" title="动态规划 + 滚动数组"></a>动态规划 + 滚动数组</h2><p>类似于 <code>找规律 + 滚动数组</code> 的优化，<code>dp[i]</code>只往前依赖于 <code>dp[i - 1]</code>，所以可以把数组的第一维优化成 <code>2</code>。</p><p>稍微要注意的是，由于 <code>0、1、2、3</code> 状态之间存在相互依赖，所以无法优化成一维数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">4</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span>  <span class="hljs-operator">=</span> i &amp; <span class="hljs-number">1</span>, pre = i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>;<br>            dp[cur][<span class="hljs-number">0</span>] = dp[pre][<span class="hljs-number">3</span>];<br>            dp[cur][<span class="hljs-number">1</span>] = (dp[pre][<span class="hljs-number">0</span>] + dp[pre][<span class="hljs-number">2</span>]) % MOD;<br>            dp[cur][<span class="hljs-number">2</span>] = (dp[pre][<span class="hljs-number">0</span>] + dp[pre][<span class="hljs-number">1</span>]) % MOD;<br>            dp[cur][<span class="hljs-number">3</span>] = (((dp[pre][<span class="hljs-number">0</span>] + dp[pre][<span class="hljs-number">3</span>]) % MOD + dp[pre][<span class="hljs-number">1</span>]) % MOD + dp[pre][<span class="hljs-number">2</span>]) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n &amp; <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilings</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;<br>        &#125;;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br>        &#125;;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                ans = mul(matrix, ans);<br>            &#125;<br>            matrix = mul(matrix, matrix);<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 应该等价</span><br>        <span class="hljs-comment">// int[] first = new int[]&#123;0, 0, 0, 1&#125;;</span><br>        <span class="hljs-comment">// return ans[3][0] * first[0] + ans[3][1] * first[1] + ans[3][2] * first[2] + ans[3][3] * first[3];</span><br>        <span class="hljs-keyword">return</span> ans[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] mul(<span class="hljs-type">int</span>[][] a, <span class="hljs-type">int</span>[][] b)&#123;<br>        <span class="hljs-type">int</span>[][] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length][a.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; a.length; j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; a.length; k++)&#123;<br>                    ret[i][j] = (<span class="hljs-type">int</span>)((ret[i][j] + (<span class="hljs-type">long</span>) a[i][k] * b[k][j]) % MOD);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>矩阵快速幂</tag>
      
      <tag>动态规划</tag>
      
      <tag>脑筋急转弯/找规律</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.NULL-The-Missing-Semester-of-Your-CS-Education</title>
    <link href="/2022/11/11/6.NULL-The-Missing-Semester-of-Your-CS-Education/"/>
    <url>/2022/11/11/6.NULL-The-Missing-Semester-of-Your-CS-Education/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://missing.csail.mit.edu/">The Missing Semester of Your CS Education</a></p><p>该课程主要是教如何更高效的使用命令行、编辑器、Git 等工具。</p></blockquote><h2 id="Lecture-1-Course-overview-the-shell"><a href="#Lecture-1-Course-overview-the-shell" class="headerlink" title="Lecture 1 - Course overview + the shell"></a>Lecture 1 - Course overview + the shell</h2><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><ul><li>&gt; 将一个命令&#x2F;程序的输出流重定向到一个 <strong>文件</strong>， &lt; 相反。&gt;&gt; 和 &lt;&lt; 用做追加</li><li>管道符 <code>|</code> 与 &gt; 不同的是，目标可以是 <strong>命令&#x2F;程序</strong></li><li>单引号：所见即所得</li><li>双引号：所见非所得，它会先把变量解析之后，再输出</li></ul><h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><p>这一节练习比较简单，所以其他的省略。</p><ul><li>Write the following into that file, one line at a time:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs file">#!/bin/bash<br>curl --head --silent https://missing.csail.mit.edu<br></code></pre></td></tr></table></figure>The first line might be tricky to get working. It’s helpful to know that # starts a comment in Bash, and ! has a special meaning even within double-quoted (“) strings. Bash treats single-quoted strings (‘) differently: they will do the trick in this case. See the Bash quoting manual page for more information.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;#!/bin/bash&#x27;</span> &gt;&gt; semester<br><span class="hljs-built_in">echo</span> curl --<span class="hljs-built_in">head</span> --silent https://missing.csail.mit.edu  &gt;&gt; semester<br></code></pre></td></tr></table></figure></li><li>Use | and &gt; to write the “last modified” date output by semester into a file called last-modified.txt in your home directory.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./semester | grep last-modified | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&quot; &quot;</span> -f 2- &gt; last-modified.txt<br></code></pre></td></tr></table></figure></li></ul><h2 id="Lecture-2-Shell-Tools-and-Scripting"><a href="#Lecture-2-Shell-Tools-and-Scripting" class="headerlink" title="Lecture 2 - Shell Tools and Scripting"></a>Lecture 2 - Shell Tools and Scripting</h2><h3 id="Notes-1"><a href="#Notes-1" class="headerlink" title="Notes"></a>Notes</h3><ul><li>To assign variables in bash, use the syntax foo&#x3D;bar and access the value of the variable with $foo. Note that foo &#x3D; bar will not work since it is interpreted as calling the foo program with arguments &#x3D; and bar. In general, in shell scripts the space character will perform argument splitting. This behavior can be confusing to use at first, so always check for that.</li><li><code>$_</code> 上条命令的最后一个参数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># e.g.</span><br><span class="hljs-variable">$mkdir</span> <span class="hljs-built_in">test</span><br><span class="hljs-variable">$cd</span> <span class="hljs-variable">$_</span><br></code></pre></td></tr></table></figure></li><li><code>$?</code> 上条命令的错误代码（返回值）</li><li><code>$0</code> 脚本名字，<code>$1</code> 到 <code>$9</code> 为 bash 脚本的第一个到第九个参数</li><li><code>$?</code> 错误代码, 0正常1错误</li><li>花括号{} - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># e.g.</span><br><span class="hljs-variable">$mkdir</span> &#123;foo,bar&#125;<br><span class="hljs-variable">$mkdir</span> &#123;foo,bar&#125;/&#123;a,b,c&#125;<br><span class="hljs-variable">$mkdir</span> foo/x bar/y<br><span class="hljs-variable">$diff</span> &#123;foo,bar&#125;   <br>Common subdirectories: foo/a and bar/a<br>Common subdirectories: foo/b and bar/b<br>Common subdirectories: foo/c and bar/c<br>Only <span class="hljs-keyword">in</span> foo: x<br>Only <span class="hljs-keyword">in</span> bar: y<br></code></pre></td></tr></table></figure></li><li>当您通过 $( ls ) 这样的方式来执行 ls 这个命令时，它的输出结果会替换掉 $( ls ) 。例如，如果执行 for file in $(ls) ，shell首先将调用ls ，然后遍历得到的这些返回值。</li><li>&lt;() 进程替换（process substitution）， &lt;( ls ) 会执行 ls 并将结果输出到一个临时文件中，并将 &lt;( ls ) 替换成临时文件名。这在我们希望返回值 <strong>通过文件而不是STDIN传递</strong> 时很有用。例如， diff &lt;(ls foo) &lt;(ls bar) 会显示文件夹 foo 和 bar 中文件的区别。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># e.g.</span><br><span class="hljs-variable">$cat</span> &lt;(<span class="hljs-built_in">ls</span> foo) &lt;(<span class="hljs-built_in">ls</span> bar)<br>a<br>b<br>c<br>x<br>a<br>b<br>c<br>y<br><span class="hljs-variable">$diff</span> &lt;(<span class="hljs-built_in">ls</span> bar) &lt;(<span class="hljs-built_in">ls</span> foo)<br>4c4<br>&lt; y<br>---<br>&gt; x<br><br></code></pre></td></tr></table></figure></li><li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 ? 和 * 来匹配一个或任意个字符。例如，对于文件foo, foo1, foo2, foo10 和 bar, rm foo?这条命令会删除foo1 和 foo2 ，而rm foo* 则会删除除了bar之外的所有文件。</li><li>find<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># e.g. 删除全部扩展名为.tmp 的文件</span><br>find . -name <span class="hljs-string">&#x27;*.tmp&#x27;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">rm</span> &#123;&#125; \;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Exercises-1"><a href="#Exercises-1" class="headerlink" title="Exercises"></a>Exercises</h3><ul><li><p>Write bash functions marco and polo that do the following. Whenever you execute marco the current working directory should be saved in some manner, then when you execute polo, no matter what directory you are in, polo should cd you back to the directory where you executed marco. For ease of debugging you can write the code in a file marco.sh and (re)load the definitions to your shell by executing source marco.sh.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing  <span class="hljs-built_in">cat</span> marco.sh   <br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-function"><span class="hljs-title">marco</span></span>()&#123;<br>    <span class="hljs-built_in">pwd</span> &gt; /tmp/missing/save-path.log<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">polo</span></span>()&#123;<br>    p=$(<span class="hljs-built_in">cat</span> /tmp/missing/save-path.log)<br>    <span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$p</span>&quot;</span><br>&#125;<br><br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing  <span class="hljs-built_in">cd</span> /usr/local/dev<br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /usr/local/dev  <span class="hljs-built_in">source</span> /tmp/missing/marco.sh <br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /usr/local/dev  marco    <br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /usr/local/dev  <span class="hljs-built_in">cat</span> /tmp/missing/save-path.log <br>/usr/local/dev<br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /usr/local/dev  <span class="hljs-built_in">cd</span> /                          <br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /  polo          <br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /usr/local/dev  <br></code></pre></td></tr></table></figure></li><li><p>Say you have a command that fails rarely. In order to debug it you need to capture its output but it can be time consuming to get a failure run. Write a bash script that runs the following script until it fails and captures its standard output and error streams to files and prints everything at the end. Bonus points if you can also report how many runs it took for the script to fail.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  <span class="hljs-built_in">cat</span> call.sh  <br><span class="hljs-comment">#!/usr/bin/env bash</span><br>count=1<br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span><br>    ./mock &amp;&gt;&gt; out.log<br>    <span class="hljs-keyword">if</span> [[ $? -ne 0 ]]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">cat</span> out.log<br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$count</span>&quot;</span><br>        <span class="hljs-built_in">break</span><br>    <span class="hljs-keyword">fi</span><br>    ((count++))<br><span class="hljs-keyword">done</span><br><br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  ./call.sh <br>119<br> ⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  <span class="hljs-built_in">cat</span> out.log<br>...<br>Everything went according to plan<br>Everything went according to plan<br>Everything went according to plan<br>Something went wrong<br>The error was using magic numbers<br></code></pre></td></tr></table></figure></li><li><p>Your task is to write a command that recursively finds all HTML files in the folder and makes a zip with them. Note that your command should work even if the files have spaces (hint: check -d flag for xargs).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  <span class="hljs-built_in">mkdir</span> &#123;a,b&#125;    <br>⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  <span class="hljs-built_in">touch</span>  &#123;a,b&#125;/&#123;1,2.html,3.html&#125;                  <br>⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  <span class="hljs-built_in">touch</span> &#123;a,b&#125;/&#123;4\ 4.html,5\ 5.html&#125;<br>⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  find . -name <span class="hljs-string">&quot;*.html&quot;</span> -print0 | xargs -0 zip -r 1.zip<br><span class="hljs-comment"># or</span><br>⚡ root@izwz9bpgwmtcoix1llcjwqz  /tmp/missing/lecture-2  find . -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*.html&quot;</span> | xargs -d <span class="hljs-string">&#x27;\n&#x27;</span>  tar -cvzf html.zip<br></code></pre></td></tr></table></figure></li></ul><h2 id="Lecture-3-command-lineShell-Tools-and-Scripting"><a href="#Lecture-3-command-lineShell-Tools-and-Scripting" class="headerlink" title="Lecture 3 - command-lineShell Tools and Scripting"></a>Lecture 3 - command-lineShell Tools and Scripting</h2><h3 id="Notes-2"><a href="#Notes-2" class="headerlink" title="Notes"></a>Notes</h3><h3 id="Exercises-2"><a href="#Exercises-2" class="headerlink" title="Exercises"></a>Exercises</h3><p>Job control<br>2. …<br>However, this strategy will fail if we start in a different bash session, since wait only works for child processes. One feature we did not discuss in the notes is that the kill command’s exit status will be zero on success and nonzero otherwise. kill -0 does not send a signal but will give a nonzero exit status if the process does not exist. Write a bash function called pidwait that takes a pid and waits until the given process completes. You should use sleep to avoid wasting CPU unnecessarily.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># root at izwz9bpgwmtcoix1llcjwqz in /tmp/missing/lecture-3 [7:23:55] → cat pidwait     </span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">kill</span> -0 <span class="hljs-variable">$1</span>;<span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">sleep</span> 1<br><span class="hljs-keyword">done</span><br><span class="hljs-comment"># root at izwz9bpgwmtcoix1llcjwqz in /tmp/missing/lecture-3 [7:22:35] → sleep 35 &amp;</span><br>[1] 16599<br><span class="hljs-comment"># root at izwz9bpgwmtcoix1llcjwqz in /tmp/missing/lecture-3 [7:22:41] → pgrep -f sleep\ 35 | xargs ./pidwait</span><br>+ 16599 <span class="hljs-keyword">done</span>       <span class="hljs-built_in">sleep</span> 35<br>./pidwait: line 2: <span class="hljs-built_in">kill</span>: (16599) - No such process<br></code></pre></td></tr></table></figure><p>Dotfiles<br>5.Migrate all of your current tool configurations to your dotfiles repository.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Now I use https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/lra/m</span>ackup.<br>Other choices https:<span class="hljs-regexp">//</span>dotfiles.github.io<span class="hljs-regexp">/utilities/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-864.获取所有钥匙的最短路径</title>
    <link href="/2022/11/10/LC-864-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/11/10/LC-864-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/shortest-path-to-get-all-keys/">leetcode 困难题</a></p><p>给定一个二维网格 grid ，其中：</p><ul><li>‘.’ 代表一个空房间</li><li>‘#’ 代表一堵</li><li>‘@’ 是起点</li><li>小写字母代表钥匙</li><li>大写字母代表锁</li></ul><p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p><p>假设 k 为 钥匙&#x2F;锁 的个数，且满足 1 &lt;&#x3D; k &lt;&#x3D; 6，字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p><p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。</p><p>示例1：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">grid</span> = [<span class="hljs-string">&quot;@.a.#&quot;</span>,<span class="hljs-string">&quot;###.#&quot;</span>,<span class="hljs-string">&quot;b.A.B&quot;</span>]<br>输出：<span class="hljs-number">8</span><br>解释：目标是获得所有钥匙，而不是打开所有锁。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">grid</span> = [<span class="hljs-string">&quot;@..aA&quot;</span>,<span class="hljs-string">&quot;..B#.&quot;</span>,<span class="hljs-string">&quot;....b&quot;</span>]<br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: grid = [&quot;@Aa&quot;]</span><br><span class="hljs-section">输出: -1</span><br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">m == grid.length<br>n == grid[i].length<br><span class="hljs-number">1</span> &lt;= m, n &lt;= <span class="hljs-number">30</span><br>grid[i][j] 只含有 <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;#&#x27;</span>, <span class="hljs-string">&#x27;@&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>-<span class="hljs-string">&#x27;f&#x27;</span> 以及 <span class="hljs-string">&#x27;A&#x27;</span>-<span class="hljs-string">&#x27;F&#x27;</span><br>钥匙的数目范围是 [<span class="hljs-number">1</span>, <span class="hljs-number">6</span>] <br>每个钥匙都对应一个 不同 的字母<br>每个钥匙正好打开一个对应的锁<br></code></pre></td></tr></table></figure><h2 id="BFS-状态压缩"><a href="#BFS-状态压缩" class="headerlink" title="BFS + 状态压缩"></a>BFS + 状态压缩</h2><p>对于最短路径我们可以通过 <a href="https://oi-wiki.org/graph/bfs/">BFS</a> 求出，并且因为钥匙最多只有 6 把，所以可以通过一个 <code>int</code> 来记录当前路径获得钥匙的情况 (称为 <code>state</code>)，对应位数为 1 时代表已经取得对应钥匙。</p><p>需要注意的是，不同于普通的 <code>BFS</code>：在确定访问状态时，不能仅仅通过坐标 <code>x, y</code> 来确定，还要加入状态，也就是说通过 <code>x, y, state</code> 来确定一个访问状态。</p><p>这是因为比如说经过某个房间 <code>a</code> 后，在房间 <code>b</code> 拿到一把新锁，接着又因为碰到墙壁或者其他未拿到钥匙的锁需要原路返回，重新经过了 <code>a</code>，那么这显然是一条新的有效路径（因为拿到了 <code>b</code> 的锁），所以我们还需要加入钥匙 <code>state</code> 来确定访问状态。反之如果坐标和钥匙 <code>state</code> 都相同，就是无效的路径，无需重新入队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathAllKeys</span><span class="hljs-params">(String[] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">keyCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stratx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, starty = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 初始化图、统计钥匙数量、记录起点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            g[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[m];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> grid[i].charAt(j);<br>                g[i][j] = c;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= sub &amp;&amp; sub &lt;= <span class="hljs-number">23</span>)&#123;<br>                    keyCount++;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;@&#x27;</span>)&#123;<br>                    stratx = i;<br>                    starty = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// Deque for BFS</span><br>        Deque&lt;<span class="hljs-type">int</span>[]&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        deque.offerLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;stratx, starty, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-comment">// 通过 `[x][y][state]` 来确定访问状态，并且记录下此时的路径距离，初始化为 -1 表示未访问过</span><br>        <span class="hljs-type">int</span>[][][] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m][<span class="hljs-number">1</span> &lt;&lt; keyCount];<br>        IntStream.range(<span class="hljs-number">0</span>, n).forEach(i -&gt; IntStream.range(<span class="hljs-number">0</span>, m).forEach(j -&gt; Arrays.fill(vis[i][j], - <span class="hljs-number">1</span>)));<br>        vis[stratx][starty][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            <span class="hljs-type">int</span>[] cur = deque.pollFirst();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> vis[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]][cur[<span class="hljs-number">2</span>]] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; help.length; i++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>] + help[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>] + help[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(!checkIndex(x, y, n, m) || g[x][y] == <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> g[x][y];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">if</span>(c != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;@&#x27;</span> &amp;&amp; (c &amp; <span class="hljs-number">32</span>) == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 锁</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">need</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;A&#x27;</span>);<br>                    <span class="hljs-keyword">if</span>((state &amp; need) != need)&#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(c != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; (c &amp; <span class="hljs-number">32</span>) == <span class="hljs-number">32</span>)&#123; <br>                    <span class="hljs-comment">// 钥匙</span><br>                    state |= (<span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;a&#x27;</span>));<br>                    <span class="hljs-keyword">if</span>(getCurKeyCount(state) == keyCount)&#123;<br>                        <span class="hljs-keyword">return</span> d;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(vis[x][y][state] == -<span class="hljs-number">1</span>)&#123;<br>                    vis[x][y][state] = d;<br>                    deque.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x, y, state&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> xLimit, <span class="hljs-type">int</span> yLimit)</span>&#123;<br>        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; xLimit &amp;&amp; y &lt; yLimit;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCurKeyCount</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(state &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>((state &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                count++;<br>            &#125;<br>            state = state &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>状态压缩</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about-windows</title>
    <link href="/2022/11/10/about-windows/"/>
    <url>/2022/11/10/about-windows/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前 <code>windows</code> 使用的比较多，在日常使用中会重复遇到一些问题，但总是解决后过段时间就忘了，所以在此记录下来。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>需要知道的是，<code>cmd</code> 和 <code>PowerShell</code> 打印某个环境变量的方式是不同的</p><ul><li>cmd<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">echo</span> <span class="hljs-variable">%Path%</span><br></code></pre></td></tr></table></figure></li><li>PowerShell<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-variable">$env:path</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="刷新环境变量"><a href="#刷新环境变量" class="headerlink" title="刷新环境变量"></a>刷新环境变量</h3><p><a href="https://github.com/chocolatey/choco">choco</a> 内置的 <code>refreshenv</code> 可以帮助我们在不重启终端的情况下方便的刷新环境变量。</p><p>需要注意的是虽然旧版命令行可以通过重启终端的手段刷新环境变量，但在 <a href="https://github.com/microsoft/terminal">win11 默认的 terminal</a> 中由于 <a href="https://github.com/microsoft/terminal/issues/1125">某些问题</a> 导致无法确保重启终端能够刷新环境变量。在这种时候，使用 <code>choco</code> 中的 <code>refreshenv</code> 几乎就是必须的了。</p><ul><li><p>cmd</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">refreshenv<br></code></pre></td></tr></table></figure></li><li><p>可能会发现在 <code>PowerShell</code> 中使用该命令并没有生效，这是因为还要进行 <a href="https://docs.chocolatey.org/en-us/troubleshooting#why-does-choco-tab-not-work-for-me">some additional work</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Uncategorized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6232.最小移动总距离</title>
    <link href="/2022/11/08/LC-6232-%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%80%BB%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/11/08/LC-6232-%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%80%BB%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/minimum-total-distance-traveled/">leetcode 困难题</a></p><p>X 轴上有一些机器人和工厂。给你一个整数数组 robot ，其中 robot[i] 是第 i 个机器人的位置。再给你一个二维整数数组 factory ，其中 factory[j] &#x3D; [positionj, limitj] ，表示第 j 个工厂的位置在 positionj ，且第 j 个工厂最多可以修理 limitj 个机器人。</p><p>每个机器人所在的位置 互不相同 。每个工厂所在的位置也 互不相同 。注意一个机器人可能一开始跟一个工厂在 相同的位置 。</p><p>所有机器人一开始都是坏的，他们会沿着设定的方向一直移动。设定的方向要么是 X 轴的正方向，要么是 X 轴的负方向。当一个机器人经过一个没达到上限的工厂时，这个工厂会维修这个机器人，且机器人停止移动。</p><p>任何时刻，你都可以设置 部分 机器人的移动方向。你的目标是最小化所有机器人总的移动距离。</p><p>请你返回所有机器人移动的最小总距离。测试数据保证所有机器人都可以被维修。</p><p>注意：</p><p>所有机器人移动速度相同。<br>如果两个机器人移动方向相同，它们永远不会碰撞。<br>如果两个机器人迎面相遇，它们也不会碰撞，它们彼此之间会擦肩而过。<br>如果一个机器人经过了一个已经达到上限的工厂，机器人会当作工厂不存在，继续移动。<br>机器人从位置 x 到位置 y 的移动距离为 |y - x| 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：robot = [0,4,6], factory = [[2,2],[6,2]]<br>输出：4<br>解释：如上图所示：<br>- 第一个机器人从位置<span class="hljs-number"> 0 </span>沿着正方向移动，在第一个工厂处维修。<br>- 第二个机器人从位置<span class="hljs-number"> 4 </span>沿着负方向移动，在第一个工厂处维修。<br>- 第三个机器人在位置<span class="hljs-number"> 6 </span>被第二个工厂维修，它不需要移动。<br>第一个工厂的维修上限是<span class="hljs-number"> 2 </span>，它维修了<span class="hljs-number"> 2 </span>个机器人。<br>第二个工厂的维修上限是<span class="hljs-number"> 2 </span>，它维修了<span class="hljs-number"> 1 </span>个机器人。<br>总移动距离是 |2 - 0| + |2 - 4| + |6 - 6| =<span class="hljs-number"> 4 </span>。没有办法得到比<span class="hljs-number"> 4 </span>更少的总移动距离。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：robot = [1,-1], factory = [[-2,1],[2,1]]<br>输出：2<br>解释：如上图所示：<br>- 第一个机器人从位置<span class="hljs-number"> 1 </span>沿着正方向移动，在第二个工厂处维修。<br>- 第二个机器人在位置 -1 沿着负方向移动，在第一个工厂处维修。<br>第一个工厂的维修上限是<span class="hljs-number"> 1 </span>，它维修了<span class="hljs-number"> 1 </span>个机器人。<br>第二个工厂的维修上限是<span class="hljs-number"> 1 </span>，它维修了<span class="hljs-number"> 1 </span>个机器人。<br>总移动距离是 |2 - 1| + |(-2) - (-1)| =<span class="hljs-number"> 2 </span>。没有办法得到比<span class="hljs-number"> 2 </span>更少的总移动距离。<br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span> &lt;= robot<span class="hljs-selector-class">.length</span>, factory<span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">100</span><br>factory<span class="hljs-selector-attr">[j]</span><span class="hljs-selector-class">.length</span> == <span class="hljs-number">2</span><br>-<span class="hljs-number">109</span> &lt;= robot<span class="hljs-selector-attr">[i]</span>, positionj &lt;= <span class="hljs-number">109</span><br><span class="hljs-number">0</span> &lt;= limitj &lt;= robot<span class="hljs-selector-class">.length</span><br>测试数据保证所有机器人都可以被维修。<br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>有一个关键的结论：</p><blockquote><p>设两个机器人的位置分别为 r1, r2，且 r1 &lt; r2 ，机器人去的工厂的位置为 f1,f2 ，则 f1 必然小于 f2 ，因为如果 f1 &gt; f2 的话，交换这两个机器人去的工厂，移动距离就变小了。</p></blockquote><p>因此我们可以先对机器人和工厂按照位置从小到大排序，那么每个工厂要修复的机器人就将是连续的一段。</p><hr><p><strong>在以下几种解法中，我们统一设 f(i, j) 的含义为第 j 个及其右侧的工厂，修理第 i 个及其右侧的机器人时的最小距离，那么 f(0, 0) 就是题目所求。</strong></p><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>一种解法是递归 + 记忆化搜索。</p><p>对于某个 <code>f(i, j)</code>，我们枚举出第 <code>j</code> 个工厂修任意个机器人的可能（比如修 <code>k</code> 个），同时设修这 <code>k</code> 个机器人所花费的距离为 <code>d(k)</code>，那么只需要取所有 <code>f(i + k + 1, j + 1) + d(k)</code> 的最小值，就是我们要求的 <code>f(i, j)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">long</span>[][] cache;<br>    List&lt;Integer&gt; robot;<br>    <span class="hljs-type">int</span>[][] factory;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTotalDistance</span><span class="hljs-params">(List&lt;Integer&gt; robot, <span class="hljs-type">int</span>[][] factory)</span> &#123;<br>        Collections.sort(robot);<br>        Arrays.sort(factory, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">this</span>.robot = robot;<br>        <span class="hljs-built_in">this</span>.factory = factory;<br>        <span class="hljs-built_in">this</span>.cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[robot.size()][factory.length];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// cache[i][j] 表示第 i 个及其右侧的工厂，修理第 j 个及其右侧的机器人时的最小距离</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= robot.size())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j &gt;= factory.length)&#123;<br>            <span class="hljs-keyword">return</span> Long.MAX_VALUE; <span class="hljs-comment">// Integer.MAX_VALUE 不够大</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(cache[i][j] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> cache[i][j];<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> dfs(i, j + <span class="hljs-number">1</span>); <span class="hljs-comment">// 初始化为当前工厂不修理任何机器人</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; factory[j][<span class="hljs-number">1</span>] &amp;&amp; i + k &lt; robot.size(); k++)&#123;<br>            d +=  Math.abs(robot.get(i + k) - factory[j][<span class="hljs-number">0</span>]); <span class="hljs-comment">// d(a)</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> dfs(i + k + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> temp == Long.MAX_VALUE ? Long.MAX_VALUE : temp + d; <span class="hljs-comment">//防止溢出</span><br>            min = Math.min(min, next);<br>        &#125;<br>        cache[i][j] = min;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><p>根据 <code>记忆化搜索</code> 的解法，我们容易发现前面工厂的状态总是依赖于后面工厂的状态，所以我们只需要逆序遍历 <code>factory</code> 就可以实现动态规划，简略的方程如下：</p><p><code>f(i, j) = min( f(i + k + 1, j + 1) + d(k) ) </code>（ <code>k</code> 取值范围为 <code>[0, factory[i][1]] - 1</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTotalDistance</span><span class="hljs-params">(List&lt;Integer&gt; robot, <span class="hljs-type">int</span>[][] factory)</span> &#123;<br>        Collections.sort(robot);<br>        Arrays.sort(factory, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> robot.size(), fs = factory.length;<br>        <span class="hljs-comment">// dp[i][j] 表示第 i 个及其右侧的工厂，修理第 j 个及其右侧的机器人时的最小距离</span><br>        <span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[rs][fs + <span class="hljs-number">1</span>];<br>        IntStream.range(<span class="hljs-number">0</span>, dp.length).forEach(index -&gt; Arrays.fill(dp[index], Long.MAX_VALUE));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> fs - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rs; i++)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> dp[i][j + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 初始化为一个都不修</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= factory[j][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &amp;&amp; i + k &lt; rs; k++)&#123;<br>                    d += Math.abs(robot.get(i + k) - factory[j][<span class="hljs-number">0</span>]);<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> i + k == rs - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : dp[i + k + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] ;<br>                    <span class="hljs-keyword">if</span>(next != Long.MAX_VALUE)&#123;<br>                        min = Math.min(min, next + d);<br>                    &#125;<br>                &#125;<br>                dp[i][j] = min;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h3><p>就像背包问题一样，我们可以发现工厂 <code>j</code> 只会依赖于工厂 <code>j + 1</code> 的状态，即实际上我们只需要保留最新的工厂状态，可以利用滚动数组进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTotalDistance</span><span class="hljs-params">(List&lt;Integer&gt; robot, <span class="hljs-type">int</span>[][] factory)</span> &#123;<br>        Collections.sort(robot);<br>        Arrays.sort(factory, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> robot.size(), fs = factory.length;<br>        <span class="hljs-comment">// dp[i][j] 表示第 i 个及其右侧的工厂，修理第 j 个及其右侧的机器人时的最小距离</span><br>        <span class="hljs-type">long</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[rs + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, Long.MAX_VALUE);<br>        dp[rs] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> fs - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rs; i++)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> dp[i]; <span class="hljs-comment">// 一个都不修</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= factory[j][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &amp;&amp; i + k &lt; rs; k++)&#123;<br>                    d += Math.abs(robot.get(i + k) - factory[j][<span class="hljs-number">0</span>]);<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> dp[i + k + <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>(next != Long.MAX_VALUE)&#123;<br>                        min = Math.min(min, next + d);<br>                    &#125;<br>                &#125;<br>                dp[i] = min;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6231.雇佣K位工人的总代价</title>
    <link href="/2022/11/06/LC-6231-%E9%9B%87%E4%BD%A3K%E4%BD%8D%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%80%BB%E4%BB%A3%E4%BB%B7/"/>
    <url>/2022/11/06/LC-6231-%E9%9B%87%E4%BD%A3K%E4%BD%8D%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%80%BB%E4%BB%A3%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/total-cost-to-hire-k-workers/">leetcode 中等题</a></p><p>给你一个下标从 0 开始的整数数组 costs ，其中 costs[i] 是雇佣第 i 位工人的代价。</p><p>同时给你两个整数 k 和 candidates 。我们想根据以下规则恰好雇佣 k 位工人：</p><p>总共进行 k 轮雇佣，且每一轮恰好雇佣一位工人。<br>在每一轮雇佣中，从最前面 candidates 和最后面 candidates 人中选出代价最小的一位工人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。<br>比方说，costs &#x3D; [3,2,7,7,1,2] 且 candidates &#x3D; 2 ，第一轮雇佣中，我们选择第 4 位工人，因为他的代价最小 [3,2,7,7,1,2] 。<br>第二轮雇佣，我们选择第 1 位工人，因为他们的代价与第 4 位工人一样都是最小代价，而且下标更小，[3,2,7,7,2] 。注意每一轮雇佣后，剩余工人的下标可能会发生变化。<br>如果剩余员工数目不足 candidates 人，那么下一轮雇佣他们中代价最小的一人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。<br>一位工人只能被选择一次。<br>返回雇佣恰好 k 位工人的总代价。</p><p>示例1：<br>输入：costs &#x3D; [17,12,10,2,7,2,11,20,8], k &#x3D; 3, candidates &#x3D; 4<br>输出：11<br>解释：我们总共雇佣 3 位工人。总代价一开始为 0 。</p><ul><li>第一轮雇佣，我们从 [17,12,10,2,,2,11,20,8] 中选择。最小代价是 2 ，有两位工人，我们选择下标更小的一位工人，即第 3 位工人。总代价是 0 + 2 &#x3D; 2 。</li><li>第二轮雇佣，我们从 [17,12,10,7,2,11,20,8] 中选择。最小代价是 2 ，下标为 4 ，总代价是 2 + 2 &#x3D; 4 。</li><li>第三轮雇佣，我们从 [17,12,10,7,11,20,8] 中选择，最小代价是 7 ，下标为 3 ，总代价是 4 + 7 &#x3D; 11 。注意下标为 3 的工人同时在最前面和最后面 4 位工人中。<br>总雇佣代价是 11 。</li></ul><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= costs.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= costs[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= k, candidates &lt;= costs.length<br></code></pre></td></tr></table></figure><h2 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h2><p>通过两个最小堆模拟 <code>最前面 candidates 和最后面 candidates 个人</code> 即可，具体来说每次取出两个堆的最小值，接着继续尝试维护堆直到 <code>k</code> 轮选人结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">totalCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] costs, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> candidates)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> costs.length;<br>        Comparator&lt;<span class="hljs-type">int</span>[]&gt; cmp = (a, b) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];<br>        &#125;;<br>        <span class="hljs-comment">// 实际上不需要比较下标，可以改成 PriorityQueue&lt;Integer&gt;</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; front = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(cmp); <br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(cmp);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; candidates &amp;&amp; left &lt;= right; i++)&#123; <span class="hljs-comment">// candidates 个人</span><br>            front.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[left], left++&#125;);<br>            <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            tail.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[right], right--&#125;);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(k-- &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span>[] f = front.peek();<br>            <span class="hljs-type">int</span>[] t = tail.peek();<br>            <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span> || (f != <span class="hljs-literal">null</span> &amp;&amp; f[<span class="hljs-number">0</span>] &lt;= t[<span class="hljs-number">0</span>]))&#123;<br>                ans += front.poll()[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">if</span>(left &lt;= right)&#123;<br>                    front.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[left], left++&#125;);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans += tail.poll()[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">if</span>(left &lt;= right)&#123;<br>                    tail.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[right], right--&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6230.长度为K子数组中的最大和</title>
    <link href="/2022/11/06/LC-6230-%E9%95%BF%E5%BA%A6%E4%B8%BAK%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <url>/2022/11/06/LC-6230-%E9%95%BF%E5%BA%A6%E4%B8%BAK%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/">leetcode 中等题</a></p><p>给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和：</p><p>子数组的长度是 k，且<br>子数组中的所有元素 各不相同 。<br>返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。</p><p>子数组 是数组中一段连续非空的元素序列。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,5,4,2,9,9,9], k = 3<br>输出：15<br>解释：nums 中长度为<span class="hljs-number"> 3 </span>的子数组是：<br>- [1,5,4] 满足全部条件，和为<span class="hljs-number"> 10 </span>。<br>- [5,4,2] 满足全部条件，和为<span class="hljs-number"> 11 </span>。<br>- [4,2,9] 满足全部条件，和为<span class="hljs-number"> 15 </span>。<br>- [2,9,9] 不满足全部条件，因为元素<span class="hljs-number"> 9 </span>出现重复。<br>- [9,9,9] 不满足全部条件，因为元素<span class="hljs-number"> 9 </span>出现重复。<br>因为<span class="hljs-number"> 15 </span>是满足全部条件的所有子数组中的最大子数组和，所以返回<span class="hljs-number"> 15 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [4,4,4], k = 3<br>输出：0<br>解释：nums 中长度为<span class="hljs-number"> 3 </span>的子数组是：<br>- [4,4,4] 不满足全部条件，因为元素<span class="hljs-number"> 4 </span>出现重复。<br>因为不存在满足全部条件的子数组，所以返回<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= k &lt;= nums.length &lt;= <span class="hljs-number">1e5</span><br><span class="hljs-symbol">1 </span>&lt;= nums[i] &lt;= <span class="hljs-number">1e5</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>滑动窗口的时间复杂度只有 <code>O(N)</code>，因为不管嵌套了几次内层循环，左右指针都是单调的从 <code>0 -&gt; (n - 1)</code> 递增，即总共的循环次数只会有 <code>n</code> 次，所以时间复杂度是满足题目的数据范围要求的。</p><h2 id="滑动窗口-Set"><a href="#滑动窗口-Set" class="headerlink" title="滑动窗口 + Set"></a>滑动窗口 + Set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumSubarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Set&lt;Integer&gt; exist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n &amp;&amp; j &lt; n; j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightItem</span> <span class="hljs-operator">=</span> nums[j];<br>            <span class="hljs-keyword">while</span>(exist.contains(rightItem))&#123;<br>                <span class="hljs-comment">// 存在重复元素, 移动左指针，直到重复元素被移除了</span><br>                exist.remove(nums[i]);<br>                curSum -= nums[i++];<br>            &#125;<br>            curSum += rightItem;<br>            exist.add(rightItem);<br>            <span class="hljs-keyword">if</span>(exist.size() &gt; k)&#123;<br>                exist.remove(nums[i]);<br>                curSum -= nums[i++];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(exist.size() == k)&#123;<br>                ans = Math.max(ans, curSum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O（N）：左右指针单调的从 <code>0-&gt;(n - 1)</code> 递增，循环次数总共只会有 <code>n</code> 次</li><li>空间复杂度：O（K）</li></ul><h2 id="滑动窗口-Map"><a href="#滑动窗口-Map" class="headerlink" title="滑动窗口 + Map"></a>滑动窗口 + Map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumSubarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Map&lt;Integer, Integer&gt; cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= k - <span class="hljs-number">1</span>; j++)&#123;<br>            cnt.put(nums[j], cnt.getOrDefault(nums[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            curSum += nums[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt.size() == k)&#123;<br>            ans = Math.max(ans, curSum);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = k; j &lt; n; i++, j++)&#123;<br>            curSum -= nums[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> cnt.get(nums[i - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span>(value == <span class="hljs-number">1</span>)&#123;<br>                cnt.remove(nums[i - <span class="hljs-number">1</span>]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cnt.put(nums[i - <span class="hljs-number">1</span>], value - <span class="hljs-number">1</span>);<br>            &#125;<br>            curSum += nums[j];<br>            cnt.put(nums[j], cnt.getOrDefault(nums[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(cnt.size() == k)&#123;<br>                ans = Math.max(ans, curSum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O（N）</li><li>空间复杂度：O（K）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-375.猜数字大小II</title>
    <link href="/2022/11/05/LC-375-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8FII/"/>
    <url>/2022/11/05/LC-375-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8FII/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/">leetcode 中等题</a></p><p>我们正在玩一个猜数游戏，游戏规则如下：</p><p>我从 1 到 n 之间选择一个数字。</p><ol><li>你来猜我选了哪个数字。</li><li>如果你猜到正确的数字，就会赢得游戏 。</li><li>如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。</li><li>每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。</li></ol><p>给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2<br>输出：1<br>解释：有两个可能的数字<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 2 </span>。<br>- 你可以先猜<span class="hljs-number"> 1 </span>。<br>    - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。<br>    - 如果我的数字更大，那么这个数字一定是<span class="hljs-number"> 2 </span>。你猜测数字为<span class="hljs-number"> 2 </span>并赢得游戏，总费用为 $1 。<br>最糟糕的情况下，你需要支付 $1 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">0</span><br>解释：只有一个可能的数字，所以你可以直接猜 <span class="hljs-number">1</span> 并赢得游戏，无需支付任何费用。<br></code></pre></td></tr></table></figure><p>提示:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= n &lt;= <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h2 id="递归-TLE"><a href="#递归-TLE" class="headerlink" title="递归(TLE)"></a>递归(TLE)</h2><p>枚举所有选择，以及对应答案的所有可能，稳 TLE，需要优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt;= end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++)&#123;<br>            <span class="hljs-comment">// 无法决策答案是哪个数，只能取最差情况，因为要确保获胜</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Math.max(dfs(start, i - <span class="hljs-number">1</span>), dfs(i + <span class="hljs-number">1</span>, end)) + i;<br>            <span class="hljs-comment">// 可以决策要猜哪个数，取最好的情况</span><br>            ans = Math.min(ans, cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>容易发现计算的结果其实只跟区间的开始以及结束有关（即 dfs 的入参），同时又因为数据范围只有 1-200 ，所以可以通过一个二维数组 <code>cache</code> 来保存计算过的结果来避免重复计算，<code>cache[i][j]</code> 表示 i 到 j 范围的数确保获胜的最小现金数， <code>cache[1][n]</code> 为题目所求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] cache;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt;= end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cache[start][end] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> cache[start][end];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++)&#123;<br>            <span class="hljs-comment">// 无法决策答案是哪个数，只能取最差情况，因为要确保获胜</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Math.max(dfs(start, i - <span class="hljs-number">1</span>), dfs(i + <span class="hljs-number">1</span>, end)) + i;<br>            <span class="hljs-comment">// 可以决策要猜哪个数，取最好的情况</span><br>            ans = Math.min(ans, cur);<br>        &#125;<br>        cache[start][end] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间-DP"><a href="#区间-DP" class="headerlink" title="区间 DP"></a>区间 DP</h2><p>我们发现在求解 <code>[start, end]</code> 区间时，假设当前选择的数是 <code>i</code>，那么只会依赖区间 <code>[start, i - 1]</code> 和 <code>[ i + 1, end]</code>，同时还具有以下几点性质：</p><ol><li>每次在求解某个区间的结果时，只会依赖更小的区间</li><li><code>f(start, end)</code> 下某个 <code>i</code> 最小成本 &#x3D; <code>max(f(start, i - 1), f(i + 1, end)) + i</code></li><li>如果 <code>start == end</code>，那么最小成本为 0，如果 <code>start + 1 == end</code>, 那么最小成本为 <code>start</code></li></ol><p>由第 1 点可知在求解区间需要逆推，从 <code>[n - 2, n]</code> 开始扩散区间直到求出 <code>[1, n]</code>，整个过程如下：</p><p><code>[n - 2, n - 2 + 2] -&gt; [n - 3, n - 1] -&gt; [n - 3, n] -&gt; ... -&gt; [1, n]</code> </p><p>而由第 3 点我们可以先得到所有 <code>start + 1 &lt;= end</code> 的区间结果，那么在求解其他所有区间的过程中就可以通过第 2 点的式子以及第 3 点的结果逐步得出所有区间的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>             dp[i][i + <span class="hljs-number">1</span>] = i; <span class="hljs-comment">// 初始化所有 start + 1 &lt;= end 区间的结果</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--)&#123; <span class="hljs-comment">// 从小区间开始逐渐扩散</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">2</span>; j &lt;= n; j++)&#123; <br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i; x &lt;= j; x++)&#123; <span class="hljs-comment">// 枚举猜的数</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Math.max(dp[i][x - <span class="hljs-number">1</span>], dp[x + <span class="hljs-number">1</span>][j]) + x; <span class="hljs-comment">// 无法决策答案是哪个数，只能取最差情况，因为要确保获胜</span><br>                    cur = Math.min(cur, t); <span class="hljs-comment">// 取枚举出来的猜某个数的最好结果</span><br>                &#125;<br>                dp[i][j] = cur;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][n];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-10-I.斐波那契数列</title>
    <link href="/2022/11/04/LC-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <url>/2022/11/04/LC-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">leetcode 简单题</a></p><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>,   <span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(N)</span></span> = <span class="hljs-built_in">F</span>(N - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(N - <span class="hljs-number">2</span>), 其中 N &gt; <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007）</p><h2 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1E9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (a + b) % MOD; <br>            a = b;<br>            b = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>对于数列递推问题，可以使用矩阵快速幂进行加速，矩阵快速幂的时间复杂度能够突破线性达到 <code>O(logN)</code>。</p><p><a href="https://oi-wiki.org/math/binary-exponentiation/">OI-WIKI-快速幂</a>　　<a href="https://oi-wiki.org/math/linear-algebra/matrix/#%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95">OI-WIKI-矩阵乘法</a>　　<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247488198&idx=1&sn=8272ca6b0ef6530413da4a270abb68bc&chksm=fd9cb9d9caeb30cf6c2defab0f5204adc158969d64418916e306f6bf50ae0c38518d4e4ba146&token=1067450240&lang=zh_CN#rd">宫水三叶-矩阵快速幂</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1E9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">long</span>[][] matrix = &#123;<br>                &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>                &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;<br>        &#125;;<br>        <span class="hljs-type">long</span>[][] ans = &#123;<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br>        &#125;; <span class="hljs-comment">// 矩阵中的1，对角线为1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((k &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>                ans = mul(matrix, ans); <span class="hljs-comment">// 快速幂，将对应二进制位为 1 时的整系数幂乘起来</span><br>            &#125;<br>            matrix = mul(matrix, matrix);<br>            k &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(ans[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] % MOD); <span class="hljs-comment">// 实际上为 ans[0][0] * f(1) + ans[0][1] * f(0)</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span>[][] mul(<span class="hljs-type">long</span>[][] matrix1, <span class="hljs-type">long</span>[][] matrix2) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix1.length;<br>        <span class="hljs-type">long</span>[][] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                ret[i][j] = (((matrix1[i][<span class="hljs-number">0</span>] * matrix2[<span class="hljs-number">0</span>][j]) % MOD) + ((matrix1[i][<span class="hljs-number">1</span>] * matrix2[<span class="hljs-number">1</span>][j]) % MOD)) % MOD; <span class="hljs-comment">// 同余</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>矩阵快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-464.我能赢吗</title>
    <link href="/2022/11/03/LC-464-%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97/"/>
    <url>/2022/11/03/LC-464-%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/can-i-win/submissions/">leetcode 中等题</a></p><p>两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过  100 的玩家，即为胜者。</p><p>两位玩家不能使用重复的整数 </p><p>给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家是否能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。</p><p>示例 1:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：maxChoosableInteger = 10, desiredTotal = 11<br>输出：false<br>解释：<br>无论第一个玩家选择哪个整数，他都会失败。<br>第一个玩家可以选择从<span class="hljs-number"> 1 </span>到<span class="hljs-number"> 10 </span>的整数。<br>如果第一个玩家选择 1，那么第二个玩家只能选择从<span class="hljs-number"> 2 </span>到<span class="hljs-number"> 10 </span>的整数。<br>第二个玩家可以通过选择整数 10（那么累积和为<span class="hljs-number"> 11 </span>&gt;= desiredTotal），从而取得胜利.<br>同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">maxChoosableInteger</span> = <span class="hljs-number">10</span>, <span class="hljs-attr">desiredTotal</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">maxChoosableInteger</span> = <span class="hljs-number">10</span>, <span class="hljs-attr">desiredTotal</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= maxChoosableInteger &lt;= <span class="hljs-number">20</span><br><span class="hljs-symbol">0 </span>&lt;= desiredTotal &lt;= <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><h2 id="递归-TLE"><a href="#递归-TLE" class="headerlink" title="递归 (TLE)"></a>递归 (TLE)</h2><p>最无脑的做法是直接递归, 用一个 <code>List</code> 来模拟选数的情况，每次选走一个数时 <code>remove</code> 掉对应元素即可，但同时因为要找到最优决策，所以不能改变原集合，只能改变拷贝的 <code>List</code>（如果直接对原集合 <code>remove</code> ，递归结束后不好还原，重新 <code>add</code> 会添加到集合末尾，那整个 for 循环遍历集合就不正确了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canIWin</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> dest)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(IntStream.rangeClosed(<span class="hljs-number">1</span>, n).boxed().collect(Collectors.toList()), dest);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; list, <span class="hljs-type">int</span> dest)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-keyword">if</span>(item &gt;= dest)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            List&lt;Integer&gt; copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list);<br>            copy.remove(i);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> dfs(copy, dest - item);<br>            <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="状态压缩-记忆化搜索"><a href="#状态压缩-记忆化搜索" class="headerlink" title="状态压缩 + 记忆化搜索"></a>状态压缩 + 记忆化搜索</h2><p>上面方案有问题的地方在于直接使用了 <code>List</code> 模拟选数过程，而整个递归过程是存在很多重复计算的，使用 <code>List</code> 无法进行记忆化搜索。</p><p>所以容易发现从一开始使用 <code>List</code> 就是一个 <strong>错误的思路</strong> 。</p><p>由于 n 数据范围为 20，且每个数只能被选择一次，所以我们可以 <strong>用一个 int (32位)</strong> 来表示选数的情况（<code>状态压缩</code>），对应二进制为 1 代表已被选择，否则代表未被选择。这种方案的好处在于很容易就能实现 <code>记忆化搜索</code>，不管是用 <code>int[1 &lt;&lt; 20]</code> 又或者是 <code>Map&lt;Integer, Integer&gt;</code> 。</p><p>整体实现的逻辑还是和上面的版本一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>]; <span class="hljs-comment">// int 的第 n 位为 1 代表 n - 1 被选择</span><br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canIWin</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> dest)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt; dest) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 依题意平手算先出手的玩家输</span><br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, dest) == <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> state, <span class="hljs-type">int</span> dest)</span>&#123;<br>        <span class="hljs-keyword">if</span>(cache[state] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> cache[state];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(((state &gt;&gt; (i - <span class="hljs-number">1</span>)) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">// 玩家不能重复使用整数</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i &gt;= dest)&#123;<br>                <span class="hljs-keyword">return</span> cache[state] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dfs((state | (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>))), dest - i) == -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> cache[state] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cache[state] = -<span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串哈希</title>
    <link href="/2022/11/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <url>/2022/11/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<br><a href="https://oi-wiki.org/string/hash/">OI-WIKI-# 字符串哈希</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247489813&idx=1&sn=7f3bc18ca390d85b17655f7164d8e660">宫水三叶-# 字符串哈希入门</a><br><a href="https://leetcode.cn/problems/repeated-dna-sequences/">Leetcode-187重复的 DNA 序列</a></p></blockquote><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>具体来说，哈希函数最重要的性质可以概括为下面两条：</p><ol><li><p>在 Hash 函数值不一样的时候，两个字符串一定不一样；</p></li><li><p>在 Hash 函数值一样的时候，两个字符串不一定一样（哈希冲突&#x2F;碰撞。但大概率一样，且我们当然希望它们总是一样的）。</p></li></ol><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>我们需要关注的是什么？</p><p>时间复杂度和 Hash 的准确率。</p><p>通常我们采用的是<strong>多项式 Hash</strong>的方法，对于一个长度为 L 的字符串 s 来说，我们可以这样定义多项式 Hash 函数：</p><p><img src="/img/20221001012815.png"></p><p>这种情况下，对于字符串 xyz ，其哈希函数值为 xb^2 + yb + z。</p><p>对于该 Hash 函数的参考实现如下(（效率低下的版本，实际使用时一般不会这么写）)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">233</span>; <br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll; <br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_hash</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span> </span>&#123; <br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123; <br>res = (ll)(res * B + s[i]) % M; <br>&#125; <br><span class="hljs-keyword">return</span> res; <br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">const</span> string&amp; t)</span> </span>&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">get_hash</span>(s) == <span class="hljs-built_in">get_hash</span>(t); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多次询问子串哈希"><a href="#多次询问子串哈希" class="headerlink" title="多次询问子串哈希"></a>多次询问子串哈希</h2><p>单次计算一个字符串的哈希值复杂度是 O(n)，其中 n 为串长，与暴力匹配没有区别，如果需要多次询问一个字符串的子串的哈希值，每次重新计算效率会非常低下。</p><p>一般采取的方法是对整个字符串先 <strong>预处理出每个前缀的哈希值(设该数组为H)</strong> ，将哈希值看成一个 b 进制的数对 m 取模的结果，这样的话可以做到快速求出子串的哈希。</p><p>首先对于F(s[1, i]) ，即原串长度为 i 的前缀（即子串s[1, i]）的哈希值 <strong>(即H[i])</strong> ，按照定义为</p><p><strong>F(s[1, i])  &#x3D; s[1] * b^ (i - 1) + s[2] * b ^ (i - 2) + … + s[i - 1] * b +s[i]</strong> </p><p>现在，我们想要用类似前缀和的方式快速求出子串 s[L, R] 的哈希值即 F(s[L, R])，按照定义哈希值为</p><p><strong>F(s[L, R])  &#x3D; s[L] * b^ (R - L) + s[L + 1] * b ^ (R - L - 1) + … + s[R - 1] * b +s[R]</strong></p><p>对比观察上述两个式子，可以发现 <code>式2</code> 其实可以由 <code>式1</code> 得出，即<br><strong>F(s[L, R])  &#x3D; F(s[1, R]) - F(s[1, L-1]) * b ^ (r - L + 1)</strong> </p><p>那么即字串 S[L, R] 的哈希值等于 H[R] - H[L-1] * B ^ (R - L +1)</p><p>而 B ^ (r - L + 1)  又可以通过 O(n) 的预处理出次方数组，以实现 O(1) 的回答每次询问</p><p>实现，<a href="https://leetcode.cn/problems/repeated-dna-sequences/">Leetcode187</a>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-number">131313</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] POWER = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M]; <span class="hljs-comment">// 次方数组  </span><br>  <br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findRepeatedDnaSequences</span><span class="hljs-params">(String s)</span> &#123;  <br>        <span class="hljs-type">int</span>[] hashTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length() + <span class="hljs-number">1</span>];  <br>        POWER[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++)&#123;  <br>            <span class="hljs-comment">// 预处理前缀哈希数组  </span><br>            hashTable[i] = hashTable[i - <span class="hljs-number">1</span>] * B + s.charAt(i - <span class="hljs-number">1</span>) % M;  <br>            <span class="hljs-comment">// 预处理次方数组</span><br>            POWER[i] = POWER[i - <span class="hljs-number">1</span>] * B;  <br>        &#125;  <br>        Map&lt;Integer, Integer&gt; countMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length() - <span class="hljs-number">10</span> + <span class="hljs-number">1</span>; i++)&#123;  <br>            <span class="hljs-comment">// 子串哈希等于 h(r) - h(l - 1) * b ^ (r - l + 1)            </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hashTable[i + <span class="hljs-number">9</span> + <span class="hljs-number">1</span>] - hashTable[i] * POWER[i + <span class="hljs-number">9</span> - i + <span class="hljs-number">1</span>];  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> countMap.merge(hash, <span class="hljs-number">0</span>, (oldValue, __) -&gt; ++oldValue);  <br>            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">1</span>)&#123;  <br>                ans.add(s.substring(i, i + <span class="hljs-number">10</span>));  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> ans;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collector-and-Stream.reduce()</title>
    <link href="/2022/11/03/Collector-and-Stream.reduce()/"/>
    <url>/2022/11/03/Collector-and-Stream.reduce()/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://leetcode.cn/problems/reformat-phone-number/">删除字符串中的破折号和空字符</a></p><blockquote><p>当然，最简洁的方式是<br>        String s &#x3D; number.replace(“ “, “”).replace(“-“, “”);<br>但这里暂时忽略这种方案，只是为了指出该背景</p></blockquote><p>一种较复杂的方案是使用 Stream，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">justCase</span><span class="hljs-params">(String str)</span>&#123;  <br>    <span class="hljs-keyword">return</span> str.chars()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>)<br>            .collect(Collector.of(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    (__, ___) -&gt; &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;un support parallel stream&quot;</span>);&#125;,<br>                    StringBuilder::toString));  <br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，要将字符数组重新收集成 <code>String</code> 的合理做法应该只有使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">.collect(supplier,  accumulator,  combiner);<br><span class="hljs-comment">// or</span><br>.collect(Collector.of());  <br></code></pre></td></tr></table></figure><p>其余做法例如 <code>mapToObj(String::valueOf).collect(joining)</code> 会频繁创建 String；<br>而 <code>reduce</code> 严格来讲既不是<strong>可变规约</strong>也没有简洁多少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">justCase</span><span class="hljs-params">(String str)</span>&#123;  <br>    <span class="hljs-keyword">return</span>  str.chars().parallel()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>)  <br>            .reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(),  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString();  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实例化-CollectorImpl"><a href="#实例化-CollectorImpl" class="headerlink" title="实例化 CollectorImpl"></a>实例化 CollectorImpl</h2><blockquote><p>这里只对 <code>Collector</code> 做该话题下的简单介绍，详细知识见 javadocs</p></blockquote><p>Collector 接口由四个抽象函数指定，这些函数协同工作以将条目累积到可变结果容器中，并可选择对结果执行最终转换。他们是：</p><ul><li>supplier() ：创建一个新的结果容器</li><li>accumulator() ：将新数据元素合并到结果容器中</li><li>combiner()：将两个结果容器合并为一个（  ）</li><li>finisher() ：对容器执行可选的最终转换</li></ul><p><code>Collector</code> 接口在 JDK 中的实现类位于 <code>Collectors.CollectorImpl</code><br>而实例化  <code>CollectorImpl</code> 有两种途径：</p><ul><li>通过 <code>Collectors</code> 类预定义的例如 <code>Collectors.toList()</code> 等静态工厂方法实例化</li><li>通过 <code>Collector</code> 接口中暴露出的两种 <code>Collector.of</code> 方法实例化：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collector</span>&lt;T, A, R&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T, R&gt; Collector&lt;T, R, R&gt; <span class="hljs-title function_">of</span><br><br><span class="hljs-params">(Supplier&lt;R&gt; supplier,  </span><br><span class="hljs-params">                                          BiConsumer&lt;R, T&gt; accumulator,  </span><br><span class="hljs-params">                                          BinaryOperator&lt;R&gt; combiner,  </span><br><span class="hljs-params">                                          Characteristics... characteristics)</span> <br>                                          <br>                                          &#123;...&#125;<br>                                          <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T, A, R&gt; Collector&lt;T, A, R&gt; <span class="hljs-title function_">of</span><br>    <br><span class="hljs-params">(Supplier&lt;A&gt; supplier,  </span><br><span class="hljs-params">                                             BiConsumer&lt;A, T&gt; accumulator,  </span><br><span class="hljs-params">                                             BinaryOperator&lt;A&gt; combiner,  </span><br><span class="hljs-params">                                             Function&lt;A, R&gt; finisher,  </span><br><span class="hljs-params">                                             Characteristics... characteristics)</span><br><br>                                             &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>可以看到，<code>Collector</code> 接口只提供了两种重载用于实例化 <code>CollectorImpl</code><br>并且这两种重载都必须传入 <code>supplier</code> 、<code>accmulator</code> 以及 <code>combiner</code>，前两个参数很好理解，毕竟 <code>CollectorImpl</code> 不好对此提供默认的实现<br>但是对于组合器  <code>combiner</code>，<strong>由于组合器只有在执行并发规约时会使用到</strong>，也就是说，对于上面场景下的收集器（即不考虑使用并发流的场景），提供一个 <code>combiner</code> 并没有实际意义</p><h2 id="为什么必须提供-combiner"><a href="#为什么必须提供-combiner" class="headerlink" title="为什么必须提供 combiner"></a>为什么必须提供 combiner</h2><p>在<a href="https://stackoverflow.com/questions/24308146/why-is-a-combiner-needed-for-reduce-method-that-converts-type-in-java-8/24316429#24316429">该问题中</a>，发现这种操作在 <code>Scala</code> 中被称为<code>foldLeft</code>。需要注意的是，Java 的库函数中并没有提供等效于 <code>foldLeft</code> 的实现。</p><blockquote><p>在上面的回答中提到：<br>Finally, Java doesn’t provide <code>foldLeft</code> and <code>foldRight</code> operations because they imply a particular ordering of operations that is inherently sequential. This clashes with the design principle stated above of providing APIs that support sequential and parallel operation equally.<br>最后，Java 不提供<code>foldLeft</code>and<code>foldRight</code>操作，因为它们暗示了一种特定的操作顺序，这种顺序本质上是顺序的。这与上述提供同样支持顺序和并行操作的 API 的设计原则相冲突。</p></blockquote><p>虽然该说法有一定说服力，但还是继续搜索了为什么 Java 没有提供 <code>foldLeft</code>，试图继续理解所提到的<code>设计原则</code>。<br>但是结果却找到了<a href="https://bugs.openjdk.org/browse/JDK-8292845">JDK-8292845</a>和<a href="https://bugs.openjdk.org/browse/JDK-8292845">JDK-8292845</a>，但在这两个增强请求中，却没有对相关<code>设计原则</code>进行讨论，而是计划会在将来对此进行实现。</p><p>也许在不久的将来，就会有一种更合理的 folding operations 可以替换上方看似不合理的实现</p><h2 id="reduce-vs-collect"><a href="#reduce-vs-collect" class="headerlink" title="reduce vs collect"></a>reduce vs collect</h2><p>先看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">justCase</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a-b&quot;</span>;  s<br>    Function&lt;String, Stream&lt;Character&gt;&gt; function = str -&gt; str.chars()  <br>            .parallel()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>);  <br>  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(),  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString(); <span class="hljs-comment">// baba  </span><br>  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .collect(Collector.of(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    StringBuilder::append,  <br>                    StringBuilder::toString)); <span class="hljs-comment">// ab</span><br>                    <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .collect(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString(); <span class="hljs-comment">// ab</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现在 <code>parallel stream</code> 下 <code>reduce()</code> 的输出并不符合我们的预期，先查看 <code>reduce()</code> 的方法注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java">...<br> identity值必须是组合器函数的标识。这意味着对于所有u ，<br>     combiner(identity , u) == u<br> 此外， combiner函数必须与accumulator函数兼容；对于所有u和t ，必须满足以下条件：<br>     combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)<br>...<br><br>&lt;U&gt; U <span class="hljs-title function_">reduce</span><span class="hljs-params">(U identity,  BiFunction&lt;U, ? <span class="hljs-built_in">super</span> T, U&gt; accumulator,  BinaryOperator&lt;U&gt; combiner)</span>;<br></code></pre></td></tr></table></figure><p>对这里的约定进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">justCase</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// combiner(identity , u) == u  </span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">identity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(<span class="hljs-string">&#x27;b&#x27;</span>);  <br>BinaryOperator&lt;StringBuilder&gt; combiner = StringBuilder::append;  <br><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply0</span> <span class="hljs-operator">=</span> combiner.apply(identity, u);  <br>log.debug(String.valueOf(apply0.toString().equals(u.toString()))); <span class="hljs-comment">// true  </span><br><br><br><span class="hljs-comment">// combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)  </span><br><span class="hljs-type">Object</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;  <br>BiFunction&lt;StringBuilder, Object, StringBuilder&gt; acc = StringBuilder::append;  <br>  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply1</span> <span class="hljs-operator">=</span> acc.apply(identity, t);  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply2</span> <span class="hljs-operator">=</span> combiner.apply(u, apply1);  <br>  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply3</span> <span class="hljs-operator">=</span> acc.apply(u, t);  <br><br>log.debug(String.valueOf(apply2.toString().equals(apply3.toString()))); <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现我们的用例其实是符合 <code>reduce()</code> 方法在 javadocs 中的约定的，于是继续查看相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 使用提供的标识、累积和组合函数对该流的元素执行 归约 </span><br>reduce(U identity, BiFunction&lt;U,? <span class="hljs-built_in">super</span> T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)<br><br><span class="hljs-comment">// 对此流的元素执行 可变归约 操作</span><br>collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? <span class="hljs-built_in">super</span> T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)<br></code></pre></td></tr></table></figure><p>会发现这其实是因为 <code>reduce()</code> 只是 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#ReductionOperations">Reduction operations</a> 导致的（而 <code>StringBuilder</code> 是可变对象），在该场景下应该使用  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#MutableReduction">Mutable reduction(可变规约)</a> ，也就是 <code>collect()</code></p><p>实际上仔细查看代码会发现 <code>reduce</code> 和 <code>collect</code> 的累加器 <code>accumulator</code> 定义也并不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// Reduction operations 在累加器中返回处理结果，处理结果的类型不能是可变的</span><br>reduce(... BiFunction&lt;U, ? <span class="hljs-built_in">super</span> T, U&gt; accumulator...)<br><span class="hljs-comment">// Mutable reduction(可变规约) 在累加器中不返回处理结果而是通过修改可变容器本身</span><br>collect(...BiConsumer&lt;R, ? <span class="hljs-built_in">super</span> T&gt; accumulator...) <br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#MutableReduction">Mutable reduction(可变规约)</a></p><p><a href="https://stackoverflow.com/questions/56023452/how-does-reduce-method-work-with-parallel-streams-in-java-8">how-does-reduce-method-work-with-parallel-streams-in-java-8</a></p><blockquote><p>The problem lies in you using Stream::reduce for mutable reduction.<br>You should instead use Stream::collect</p></blockquote><p><a href="https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce/38728166#38728166">java-8-streams-collect-vs-reduce</a></p><blockquote><p>The reason is simply that:</p><ul><li>collect() can only work with mutable result objects.</li><li>reduce() is designed to work with immutable result objects.</li></ul></blockquote><p><a href="https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce/22577274#22577274">java-8-streams-collect-vs-reduce</a></p><blockquote><p>reduce是一个“折叠”操作，它将二元运算符应用于流中的每个元素，其中运算符的第一个参数是前一个应用程序的返回值，第二个参数是当前流元素。<br>collect是一种聚合操作，其中创建“集合”并将每个元素“添加”到该集合中。然后将流中不同部分的集合添加到一起。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
