<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LC-864.获取所有钥匙的最短路径</title>
    <link href="/2022/11/10/LC-864-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/11/10/LC-864-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/shortest-path-to-get-all-keys/">leetcode 困难题</a></p><p>给定一个二维网格 grid ，其中：</p><ul><li>‘.’ 代表一个空房间</li><li>‘#’ 代表一堵</li><li>‘@’ 是起点</li><li>小写字母代表钥匙</li><li>大写字母代表锁</li></ul><p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p><p>假设 k 为 钥匙&#x2F;锁 的个数，且满足 1 &lt;&#x3D; k &lt;&#x3D; 6，字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p><p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。</p><p>示例1：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">grid</span> = [<span class="hljs-string">&quot;@.a.#&quot;</span>,<span class="hljs-string">&quot;###.#&quot;</span>,<span class="hljs-string">&quot;b.A.B&quot;</span>]<br>输出：<span class="hljs-number">8</span><br>解释：目标是获得所有钥匙，而不是打开所有锁。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">grid</span> = [<span class="hljs-string">&quot;@..aA&quot;</span>,<span class="hljs-string">&quot;..B#.&quot;</span>,<span class="hljs-string">&quot;....b&quot;</span>]<br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: grid = [&quot;@Aa&quot;]</span><br><span class="hljs-section">输出: -1</span><br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">m == grid.length<br>n == grid[i].length<br><span class="hljs-number">1</span> &lt;= m, n &lt;= <span class="hljs-number">30</span><br>grid[i][j] 只含有 <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;#&#x27;</span>, <span class="hljs-string">&#x27;@&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>-<span class="hljs-string">&#x27;f&#x27;</span> 以及 <span class="hljs-string">&#x27;A&#x27;</span>-<span class="hljs-string">&#x27;F&#x27;</span><br>钥匙的数目范围是 [<span class="hljs-number">1</span>, <span class="hljs-number">6</span>] <br>每个钥匙都对应一个 不同 的字母<br>每个钥匙正好打开一个对应的锁<br></code></pre></td></tr></table></figure><h2 id="BFS-状态压缩"><a href="#BFS-状态压缩" class="headerlink" title="BFS + 状态压缩"></a>BFS + 状态压缩</h2><p>对于最短路径我们可以通过 <a href="https://oi-wiki.org/graph/bfs/">BFS</a> 求出，并且因为钥匙最多只有 6 把，所以可以通过一个 <code>int</code> 来记录当前路径获得钥匙的情况 (称为 <code>state</code>)，对应位数为 1 时代表已经取得对应钥匙。</p><p>需要注意的是，不同于普通的 <code>BFS</code>：在确定访问状态时，不能仅仅通过坐标 <code>x, y</code> 来确定，还要加入状态，也就是说通过 <code>x, y, state</code> 来确定一个访问状态。这是因为比如说经过某个房间 <code>a</code> 后，在房间 <code>b</code> 拿到一把新锁，接着因为碰到墙壁或者其他未拿到钥匙的锁需要原路返回，又重新经过了 <code>a</code>，那么这个时候因为重新经过 <code>a</code> 时钥匙 <code>state</code> 是不同的，就是一条新的有效路径。反之如果钥匙 <code>state</code> 相同，就是已经遍历过的路径，而无需重新入队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathAllKeys</span><span class="hljs-params">(String[] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">keyCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stratx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, starty = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 初始化图、统计钥匙数量、记录起点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            g[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[m];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> grid[i].charAt(j);<br>                g[i][j] = c;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= sub &amp;&amp; sub &lt;= <span class="hljs-number">23</span>)&#123;<br>                    keyCount++;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;@&#x27;</span>)&#123;<br>                    stratx = i;<br>                    starty = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// Deque for BFS</span><br>        Deque&lt;<span class="hljs-type">int</span>[]&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        deque.offerLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;stratx, starty, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-comment">// 通过 `[x][y][state]` 来确定访问状态，并且记录下此时的路径距离，初始化为 -1 表示未访问过</span><br>        <span class="hljs-type">int</span>[][][] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m][<span class="hljs-number">1</span> &lt;&lt; keyCount];<br>        IntStream.range(<span class="hljs-number">0</span>, n).forEach(i -&gt; IntStream.range(<span class="hljs-number">0</span>, m).forEach(j -&gt; Arrays.fill(vis[i][j], - <span class="hljs-number">1</span>)));<br>        vis[stratx][starty][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            <span class="hljs-type">int</span>[] cur = deque.pollFirst();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> vis[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]][cur[<span class="hljs-number">2</span>]] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; help.length; i++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>] + help[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>] + help[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(!checkIndex(x, y, n, m) || g[x][y] == <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> g[x][y];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">if</span>(c != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;@&#x27;</span> &amp;&amp; (c &amp; <span class="hljs-number">32</span>) == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 锁</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">need</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;A&#x27;</span>);<br>                    <span class="hljs-keyword">if</span>((state &amp; need) != need)&#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(c != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; (c &amp; <span class="hljs-number">32</span>) == <span class="hljs-number">32</span>)&#123; <br>                    <span class="hljs-comment">// 钥匙</span><br>                    state |= (<span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;a&#x27;</span>));<br>                    <span class="hljs-keyword">if</span>(getCurKeyCount(state) == keyCount)&#123;<br>                        <span class="hljs-keyword">return</span> d;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(vis[x][y][state] == -<span class="hljs-number">1</span>)&#123;<br>                    vis[x][y][state] = d;<br>                    deque.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x, y, state&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> xLimit, <span class="hljs-type">int</span> yLimit)</span>&#123;<br>        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; xLimit &amp;&amp; y &lt; yLimit;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCurKeyCount</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(state &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>((state &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                count++;<br>            &#125;<br>            state = state &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>状态压缩</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about-windows</title>
    <link href="/2022/11/10/about-windows/"/>
    <url>/2022/11/10/about-windows/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前 <code>windows</code> 还是使用的比较多的，在日常使用中会重复遇到一些问题，但总是解决后过段时间就忘了，所以在此记录下来。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>需要知道的是，<code>cmd</code> 和 <code>PowerShell</code> 打印某个环境变量的方式是不同的</p><ul><li>cmd<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">echo</span> <span class="hljs-variable">%Path%</span><br></code></pre></td></tr></table></figure></li><li>PowerShell<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-variable">$env:path</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="刷新环境变量"><a href="#刷新环境变量" class="headerlink" title="刷新环境变量"></a>刷新环境变量</h3><p><a href="https://github.com/chocolatey/choco">choco</a> 内置的 <code>refreshenv</code> 可以帮助我们在不重启终端的情况下方便的刷新环境变量。</p><p>需要注意的是虽然旧版命令行可以通过重启终端的手段刷新环境变量，但在 <a href="https://github.com/microsoft/terminal">win11 默认的 terminal</a> 中由于存在 <a href="https://github.com/microsoft/terminal/issues/1125">某些问题</a> 导致无法确保重启终端能够刷新环境变量。在这种时候，使用 <code>choco</code> 中的 <code>refreshenv</code> 几乎就是必须的了。</p><ul><li><p>cmd</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">refreshenv<br></code></pre></td></tr></table></figure></li><li><p>可能会发现在 <code>PowerShell</code> 中使用该命令并没有生效，这是因为还要进行 <a href="https://docs.chocolatey.org/en-us/troubleshooting#why-does-choco-tab-not-work-for-me">some additional work</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Uncategorized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6232.最小移动总距离</title>
    <link href="/2022/11/08/LC-6232-%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%80%BB%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/11/08/LC-6232-%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%80%BB%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/minimum-total-distance-traveled/">leetcode 困难题</a></p><p>X 轴上有一些机器人和工厂。给你一个整数数组 robot ，其中 robot[i] 是第 i 个机器人的位置。再给你一个二维整数数组 factory ，其中 factory[j] &#x3D; [positionj, limitj] ，表示第 j 个工厂的位置在 positionj ，且第 j 个工厂最多可以修理 limitj 个机器人。</p><p>每个机器人所在的位置 互不相同 。每个工厂所在的位置也 互不相同 。注意一个机器人可能一开始跟一个工厂在 相同的位置 。</p><p>所有机器人一开始都是坏的，他们会沿着设定的方向一直移动。设定的方向要么是 X 轴的正方向，要么是 X 轴的负方向。当一个机器人经过一个没达到上限的工厂时，这个工厂会维修这个机器人，且机器人停止移动。</p><p>任何时刻，你都可以设置 部分 机器人的移动方向。你的目标是最小化所有机器人总的移动距离。</p><p>请你返回所有机器人移动的最小总距离。测试数据保证所有机器人都可以被维修。</p><p>注意：</p><p>所有机器人移动速度相同。<br>如果两个机器人移动方向相同，它们永远不会碰撞。<br>如果两个机器人迎面相遇，它们也不会碰撞，它们彼此之间会擦肩而过。<br>如果一个机器人经过了一个已经达到上限的工厂，机器人会当作工厂不存在，继续移动。<br>机器人从位置 x 到位置 y 的移动距离为 |y - x| 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：robot = [0,4,6], factory = [[2,2],[6,2]]<br>输出：4<br>解释：如上图所示：<br>- 第一个机器人从位置<span class="hljs-number"> 0 </span>沿着正方向移动，在第一个工厂处维修。<br>- 第二个机器人从位置<span class="hljs-number"> 4 </span>沿着负方向移动，在第一个工厂处维修。<br>- 第三个机器人在位置<span class="hljs-number"> 6 </span>被第二个工厂维修，它不需要移动。<br>第一个工厂的维修上限是<span class="hljs-number"> 2 </span>，它维修了<span class="hljs-number"> 2 </span>个机器人。<br>第二个工厂的维修上限是<span class="hljs-number"> 2 </span>，它维修了<span class="hljs-number"> 1 </span>个机器人。<br>总移动距离是 |2 - 0| + |2 - 4| + |6 - 6| =<span class="hljs-number"> 4 </span>。没有办法得到比<span class="hljs-number"> 4 </span>更少的总移动距离。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：robot = [1,-1], factory = [[-2,1],[2,1]]<br>输出：2<br>解释：如上图所示：<br>- 第一个机器人从位置<span class="hljs-number"> 1 </span>沿着正方向移动，在第二个工厂处维修。<br>- 第二个机器人在位置 -1 沿着负方向移动，在第一个工厂处维修。<br>第一个工厂的维修上限是<span class="hljs-number"> 1 </span>，它维修了<span class="hljs-number"> 1 </span>个机器人。<br>第二个工厂的维修上限是<span class="hljs-number"> 1 </span>，它维修了<span class="hljs-number"> 1 </span>个机器人。<br>总移动距离是 |2 - 1| + |(-2) - (-1)| =<span class="hljs-number"> 2 </span>。没有办法得到比<span class="hljs-number"> 2 </span>更少的总移动距离。<br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span> &lt;= robot<span class="hljs-selector-class">.length</span>, factory<span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">100</span><br>factory<span class="hljs-selector-attr">[j]</span><span class="hljs-selector-class">.length</span> == <span class="hljs-number">2</span><br>-<span class="hljs-number">109</span> &lt;= robot<span class="hljs-selector-attr">[i]</span>, positionj &lt;= <span class="hljs-number">109</span><br><span class="hljs-number">0</span> &lt;= limitj &lt;= robot<span class="hljs-selector-class">.length</span><br>测试数据保证所有机器人都可以被维修。<br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>有一个关键的结论：</p><blockquote><p>设两个机器人的位置分别为 r1, r2，且 r1 &lt; r2 ，机器人去的工厂的位置为 f1,f2 ，则 f1 必然小于 f2 ，因为如果 f1 &gt; f2 的话，交换这两个机器人去的工厂，移动距离就变小了。</p></blockquote><p>因此我们可以先对机器人和工厂按照位置从小到大排序，那么每个工厂要修复的机器人就将是连续的一段。</p><hr><p><strong>在以下几种解法中，我们统一设 f(i, j) 的含义为第 j 个及其右侧的工厂，修理第 i 个及其右侧的机器人时的最小距离，那么 f(0, 0) 就是题目所求。</strong></p><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>一种解法是递归 + 记忆化搜索。</p><p>对于某个 <code>f(i, j)</code>，我们枚举出第 <code>j</code> 个工厂修任意个机器人的可能（比如修 <code>k</code> 个），同时设修这 <code>k</code> 个机器人所花费的距离为 <code>d(k)</code>，那么只需要取所有 <code>f(i + k + 1, j + 1) + d(k)</code> 的最小值，就是我们要求的 <code>f(i, j)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">long</span>[][] cache;<br>    List&lt;Integer&gt; robot;<br>    <span class="hljs-type">int</span>[][] factory;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTotalDistance</span><span class="hljs-params">(List&lt;Integer&gt; robot, <span class="hljs-type">int</span>[][] factory)</span> &#123;<br>        Collections.sort(robot);<br>        Arrays.sort(factory, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">this</span>.robot = robot;<br>        <span class="hljs-built_in">this</span>.factory = factory;<br>        <span class="hljs-built_in">this</span>.cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[robot.size()][factory.length];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// cache[i][j] 表示第 i 个及其右侧的工厂，修理第 j 个及其右侧的机器人时的最小距离</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= robot.size())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j &gt;= factory.length)&#123;<br>            <span class="hljs-keyword">return</span> Long.MAX_VALUE; <span class="hljs-comment">// Integer.MAX_VALUE 不够大</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(cache[i][j] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> cache[i][j];<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> dfs(i, j + <span class="hljs-number">1</span>); <span class="hljs-comment">// 初始化为当前工厂不修理任何机器人</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; factory[j][<span class="hljs-number">1</span>] &amp;&amp; i + k &lt; robot.size(); k++)&#123;<br>            d +=  Math.abs(robot.get(i + k) - factory[j][<span class="hljs-number">0</span>]); <span class="hljs-comment">// d(a)</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> dfs(i + k + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> temp == Long.MAX_VALUE ? Long.MAX_VALUE : temp + d; <span class="hljs-comment">//防止溢出</span><br>            min = Math.min(min, next);<br>        &#125;<br>        cache[i][j] = min;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><p>根据 <code>记忆化搜索</code> 的解法，我们容易发现前面工厂的状态总是依赖于后面工厂的状态，所以我们只需要逆序遍历 <code>factory</code> 就可以实现动态规划，简略的方程如下：</p><p><code>f(i, j) = min( f(i + k + 1, j + 1) + d(k) ) </code>（ <code>k</code> 取值范围为 <code>[0, factory[i][1]] - 1</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTotalDistance</span><span class="hljs-params">(List&lt;Integer&gt; robot, <span class="hljs-type">int</span>[][] factory)</span> &#123;<br>        Collections.sort(robot);<br>        Arrays.sort(factory, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> robot.size(), fs = factory.length;<br>        <span class="hljs-comment">// dp[i][j] 表示第 i 个及其右侧的工厂，修理第 j 个及其右侧的机器人时的最小距离</span><br>        <span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[rs][fs + <span class="hljs-number">1</span>];<br>        IntStream.range(<span class="hljs-number">0</span>, dp.length).forEach(index -&gt; Arrays.fill(dp[index], Long.MAX_VALUE));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> fs - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rs; i++)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> dp[i][j + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 初始化为一个都不修</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= factory[j][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &amp;&amp; i + k &lt; rs; k++)&#123;<br>                    d += Math.abs(robot.get(i + k) - factory[j][<span class="hljs-number">0</span>]);<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> i + k == rs - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : dp[i + k + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] ;<br>                    <span class="hljs-keyword">if</span>(next != Long.MAX_VALUE)&#123;<br>                        min = Math.min(min, next + d);<br>                    &#125;<br>                &#125;<br>                dp[i][j] = min;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h3><p>就像背包问题一样，我们可以发现工厂 <code>j</code> 只会依赖于工厂 <code>j + 1</code> 的状态，即实际上我们只需要保留最新的工厂状态，可以利用滚动数组进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTotalDistance</span><span class="hljs-params">(List&lt;Integer&gt; robot, <span class="hljs-type">int</span>[][] factory)</span> &#123;<br>        Collections.sort(robot);<br>        Arrays.sort(factory, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> robot.size(), fs = factory.length;<br>        <span class="hljs-comment">// dp[i][j] 表示第 i 个及其右侧的工厂，修理第 j 个及其右侧的机器人时的最小距离</span><br>        <span class="hljs-type">long</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[rs + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, Long.MAX_VALUE);<br>        dp[rs] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> fs - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rs; i++)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> dp[i]; <span class="hljs-comment">// 一个都不修</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= factory[j][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &amp;&amp; i + k &lt; rs; k++)&#123;<br>                    d += Math.abs(robot.get(i + k) - factory[j][<span class="hljs-number">0</span>]);<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> dp[i + k + <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>(next != Long.MAX_VALUE)&#123;<br>                        min = Math.min(min, next + d);<br>                    &#125;<br>                &#125;<br>                dp[i] = min;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6231.雇佣K位工人的总代价</title>
    <link href="/2022/11/06/LC-6231-%E9%9B%87%E4%BD%A3K%E4%BD%8D%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%80%BB%E4%BB%A3%E4%BB%B7/"/>
    <url>/2022/11/06/LC-6231-%E9%9B%87%E4%BD%A3K%E4%BD%8D%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%80%BB%E4%BB%A3%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/total-cost-to-hire-k-workers/">leetcode 中等题</a></p><p>给你一个下标从 0 开始的整数数组 costs ，其中 costs[i] 是雇佣第 i 位工人的代价。</p><p>同时给你两个整数 k 和 candidates 。我们想根据以下规则恰好雇佣 k 位工人：</p><p>总共进行 k 轮雇佣，且每一轮恰好雇佣一位工人。<br>在每一轮雇佣中，从最前面 candidates 和最后面 candidates 人中选出代价最小的一位工人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。<br>比方说，costs &#x3D; [3,2,7,7,1,2] 且 candidates &#x3D; 2 ，第一轮雇佣中，我们选择第 4 位工人，因为他的代价最小 [3,2,7,7,1,2] 。<br>第二轮雇佣，我们选择第 1 位工人，因为他们的代价与第 4 位工人一样都是最小代价，而且下标更小，[3,2,7,7,2] 。注意每一轮雇佣后，剩余工人的下标可能会发生变化。<br>如果剩余员工数目不足 candidates 人，那么下一轮雇佣他们中代价最小的一人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。<br>一位工人只能被选择一次。<br>返回雇佣恰好 k 位工人的总代价。</p><p>示例1：<br>输入：costs &#x3D; [17,12,10,2,7,2,11,20,8], k &#x3D; 3, candidates &#x3D; 4<br>输出：11<br>解释：我们总共雇佣 3 位工人。总代价一开始为 0 。</p><ul><li>第一轮雇佣，我们从 [17,12,10,2,,2,11,20,8] 中选择。最小代价是 2 ，有两位工人，我们选择下标更小的一位工人，即第 3 位工人。总代价是 0 + 2 &#x3D; 2 。</li><li>第二轮雇佣，我们从 [17,12,10,7,2,11,20,8] 中选择。最小代价是 2 ，下标为 4 ，总代价是 2 + 2 &#x3D; 4 。</li><li>第三轮雇佣，我们从 [17,12,10,7,11,20,8] 中选择，最小代价是 7 ，下标为 3 ，总代价是 4 + 7 &#x3D; 11 。注意下标为 3 的工人同时在最前面和最后面 4 位工人中。<br>总雇佣代价是 11 。</li></ul><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= costs.length &lt;= <span class="hljs-number">105</span><br><span class="hljs-symbol">1 </span>&lt;= costs[i] &lt;= <span class="hljs-number">105</span><br><span class="hljs-symbol">1 </span>&lt;= k, candidates &lt;= costs.length<br></code></pre></td></tr></table></figure><h2 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h2><p>通过两个最小堆模拟 <code>最前面 candidates 和最后面 candidates 个人</code> 即可，具体来说每次取出两个堆的最小值，接着继续尝试维护堆直到 <code>k</code> 轮选人结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">totalCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] costs, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> candidates)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> costs.length;<br>        Comparator&lt;<span class="hljs-type">int</span>[]&gt; cmp = (a, b) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];<br>        &#125;;<br>        <span class="hljs-comment">// 实际上不需要比较下标，可以改成 PriorityQueue&lt;Integer&gt;</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; front = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(cmp); <br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(cmp);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; candidates &amp;&amp; left &lt;= right; i++)&#123; <span class="hljs-comment">// candidates 个人</span><br>            front.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[left], left++&#125;);<br>            <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            tail.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[right], right--&#125;);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(k-- &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span>[] f = front.peek();<br>            <span class="hljs-type">int</span>[] t = tail.peek();<br>            <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span> || (f != <span class="hljs-literal">null</span> &amp;&amp; f[<span class="hljs-number">0</span>] &lt;= t[<span class="hljs-number">0</span>]))&#123;<br>                ans += front.poll()[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">if</span>(left &lt;= right)&#123;<br>                    front.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[left], left++&#125;);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans += tail.poll()[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">if</span>(left &lt;= right)&#123;<br>                    tail.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;costs[right], right--&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-6230.长度为K子数组中的最大和</title>
    <link href="/2022/11/06/LC-6230-%E9%95%BF%E5%BA%A6%E4%B8%BAK%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <url>/2022/11/06/LC-6230-%E9%95%BF%E5%BA%A6%E4%B8%BAK%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/">leetcode 中等题</a></p><p>给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和：</p><p>子数组的长度是 k，且<br>子数组中的所有元素 各不相同 。<br>返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。</p><p>子数组 是数组中一段连续非空的元素序列。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,5,4,2,9,9,9], k = 3<br>输出：15<br>解释：nums 中长度为<span class="hljs-number"> 3 </span>的子数组是：<br>- [1,5,4] 满足全部条件，和为<span class="hljs-number"> 10 </span>。<br>- [5,4,2] 满足全部条件，和为<span class="hljs-number"> 11 </span>。<br>- [4,2,9] 满足全部条件，和为<span class="hljs-number"> 15 </span>。<br>- [2,9,9] 不满足全部条件，因为元素<span class="hljs-number"> 9 </span>出现重复。<br>- [9,9,9] 不满足全部条件，因为元素<span class="hljs-number"> 9 </span>出现重复。<br>因为<span class="hljs-number"> 15 </span>是满足全部条件的所有子数组中的最大子数组和，所以返回<span class="hljs-number"> 15 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [4,4,4], k = 3<br>输出：0<br>解释：nums 中长度为<span class="hljs-number"> 3 </span>的子数组是：<br>- [4,4,4] 不满足全部条件，因为元素<span class="hljs-number"> 4 </span>出现重复。<br>因为不存在满足全部条件的子数组，所以返回<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= k &lt;= nums.length &lt;= <span class="hljs-number">1e5</span><br><span class="hljs-symbol">1 </span>&lt;= nums[i] &lt;= <span class="hljs-number">1e5</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一开始看到数据范围时候，第一反应就是不能用 <code>O(N^2)</code> 时间复杂度实现。</p><p>当时确实想到了滑动窗口，但是不知道怎么想的觉得滑动窗口需要 <code>O(N^2)</code> 的时间复杂度，就尝试了 <code>前缀和 + TreeSet</code> 的做法，但是想的太复杂了优化不到低于 <code>O(N^2)</code> 的时间复杂度（其实就是蠢）。</p><p>直到后面才发现滑动窗口的时间复杂度就是 <code>O(N)</code>，因为不管嵌套了几次内层循环，左右指针都是单调的从 <code>0-&gt;(n - 1)</code> 递增，即总共的循环次数只会有 <code>n</code> 次，所以时间复杂度是满足要求的。</p><h2 id="滑动窗口-Set"><a href="#滑动窗口-Set" class="headerlink" title="滑动窗口 + Set"></a>滑动窗口 + Set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumSubarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Set&lt;Integer&gt; exist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n &amp;&amp; j &lt; n; j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftItem</span> <span class="hljs-operator">=</span> nums[j];<br>            <span class="hljs-keyword">while</span>(exist.contains(leftItem))&#123;<br>                <span class="hljs-comment">// 存在重复元素, 移动左指针，直到重复元素被移除了</span><br>                exist.remove(nums[i]);<br>                curSum -= nums[i++];<br>            &#125;<br>            curSum += leftItem;<br>            exist.add(leftItem);<br>            <span class="hljs-keyword">if</span>(exist.size() &gt; k)&#123;<br>                exist.remove(nums[i]);<br>                curSum -= nums[i++];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(exist.size() == k)&#123;<br>                ans = Math.max(ans, curSum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O（N）：左右指针单调的从 <code>0-&gt;(n - 1)</code> 递增，循环次数总共只会有 <code>n</code> 次</li><li>空间复杂度：O（K）</li></ul><h2 id="滑动窗口-Map"><a href="#滑动窗口-Map" class="headerlink" title="滑动窗口 + Map"></a>滑动窗口 + Map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumSubarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Map&lt;Integer, Integer&gt; cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= k - <span class="hljs-number">1</span>; j++)&#123;<br>            cnt.put(nums[j], cnt.getOrDefault(nums[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            curSum += nums[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt.size() == k)&#123;<br>            ans = Math.max(ans, curSum);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = k; j &lt; n; i++, j++)&#123;<br>            curSum -= nums[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> cnt.get(nums[i - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span>(value == <span class="hljs-number">1</span>)&#123;<br>                cnt.remove(nums[i - <span class="hljs-number">1</span>]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cnt.put(nums[i - <span class="hljs-number">1</span>], value - <span class="hljs-number">1</span>);<br>            &#125;<br>            curSum += nums[j];<br>            cnt.put(nums[j], cnt.getOrDefault(nums[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(cnt.size() == k)&#123;<br>                ans = Math.max(ans, curSum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O（N）</li><li>空间复杂度：O（K）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-375.猜数字大小II</title>
    <link href="/2022/11/05/LC-375-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8FII/"/>
    <url>/2022/11/05/LC-375-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8FII/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/">leetcode 中等题</a></p><p>我们正在玩一个猜数游戏，游戏规则如下：</p><p>我从 1 到 n 之间选择一个数字。</p><ol><li>你来猜我选了哪个数字。</li><li>如果你猜到正确的数字，就会赢得游戏 。</li><li>如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。</li><li>每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。</li></ol><p>给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2<br>输出：1<br>解释：有两个可能的数字<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 2 </span>。<br>- 你可以先猜<span class="hljs-number"> 1 </span>。<br>    - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。<br>    - 如果我的数字更大，那么这个数字一定是<span class="hljs-number"> 2 </span>。你猜测数字为<span class="hljs-number"> 2 </span>并赢得游戏，总费用为 $1 。<br>最糟糕的情况下，你需要支付 $1 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">0</span><br>解释：只有一个可能的数字，所以你可以直接猜 <span class="hljs-number">1</span> 并赢得游戏，无需支付任何费用。<br></code></pre></td></tr></table></figure><p>提示:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= n &lt;= <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h2 id="递归-TLE"><a href="#递归-TLE" class="headerlink" title="递归(TLE)"></a>递归(TLE)</h2><p>枚举所有选择，以及对应答案的所有可能，稳 TLE，需要优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt;= end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++)&#123;<br>            <span class="hljs-comment">// 无法决策答案是哪个数，只能取最差情况，因为要确保获胜</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Math.max(dfs(start, i - <span class="hljs-number">1</span>), dfs(i + <span class="hljs-number">1</span>, end)) + i;<br>            <span class="hljs-comment">// 可以决策要猜哪个数，取最好的情况</span><br>            ans = Math.min(ans, cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>容易发现计算的结果其实只跟区间的开始以及结束有关（即 dfs 的入参），同时又因为数据范围只有 1-200 ，所以可以通过一个二维数组 <code>cache</code> 来保存计算过的结果来避免重复计算，<code>cache[i][j]</code> 表示 i 到 j 范围的数确保获胜的最小现金数， <code>cache[1][n]</code> 为题目所求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] cache;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt;= end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cache[start][end] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> cache[start][end];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++)&#123;<br>            <span class="hljs-comment">// 无法决策答案是哪个数，只能取最差情况，因为要确保获胜</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Math.max(dfs(start, i - <span class="hljs-number">1</span>), dfs(i + <span class="hljs-number">1</span>, end)) + i;<br>            <span class="hljs-comment">// 可以决策要猜哪个数，取最好的情况</span><br>            ans = Math.min(ans, cur);<br>        &#125;<br>        cache[start][end] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间-DP"><a href="#区间-DP" class="headerlink" title="区间 DP"></a>区间 DP</h2><p>我们发现在求解 <code>[start, end]</code> 区间时，假设当前选择的数是 <code>i</code>，那么只会依赖区间 <code>[start, i - 1]</code> 和 <code>[ i + 1, end]</code>，同时还具有以下几点性质：</p><ol><li>每次在求解某个区间的结果时，只会依赖更小的区间</li><li><code>f(start, end)</code> 下某个 <code>i</code> 最小成本 &#x3D; <code>max(f(start, i - 1), f(i + 1, end)) + i</code></li><li>如果 <code>start == end</code>，那么最小成本为 0，如果 <code>start + 1 == end</code>, 那么最小成本为 <code>start</code></li></ol><p>由第 1 点可知在求解区间需要逆推，从 <code>[n - 2, n]</code> 开始扩散区间直到求出 <code>[1, n]</code>，整个过程如下：</p><p><code>[n - 2, n - 2 + 2] -&gt; [n - 3, n - 1] -&gt; [n - 3, n] -&gt; ... -&gt; [1, n]</code> </p><p>而由第 3 点我们可以先得到所有 <code>start + 1 &lt;= end</code> 的区间结果，那么在求解其他所有区间的过程中就可以通过第 2 点的式子以及第 3 点的结果逐步得出所有区间的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>             dp[i][i + <span class="hljs-number">1</span>] = i; <span class="hljs-comment">// 初始化所有 start + 1 &lt;= end 区间的结果</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--)&#123; <span class="hljs-comment">// 从小区间开始逐渐扩散</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">2</span>; j &lt;= n; j++)&#123; <br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i; x &lt;= j; x++)&#123; <span class="hljs-comment">// 枚举猜的数</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Math.max(dp[i][x - <span class="hljs-number">1</span>], dp[x + <span class="hljs-number">1</span>][j]) + x; <span class="hljs-comment">// 无法决策答案是哪个数，只能取最差情况，因为要确保获胜</span><br>                    cur = Math.min(cur, t); <span class="hljs-comment">// 取枚举出来的猜某个数的最好结果</span><br>                &#125;<br>                dp[i][j] = cur;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][n];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-10-I.斐波那契数列</title>
    <link href="/2022/11/04/LC-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <url>/2022/11/04/LC-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">leetcode 简单题</a></p><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>,   <span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(N)</span></span> = <span class="hljs-built_in">F</span>(N - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(N - <span class="hljs-number">2</span>), 其中 N &gt; <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007）</p><h2 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1E9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> ((a % MOD) + (b % MOD)) % MOD; <span class="hljs-comment">// 同余</span><br>            a = b;<br>            b = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>对于数列递推问题，可以使用矩阵快速幂进行加速，矩阵快速幂的时间复杂度能够突破线性达到 <code>O(logN)</code>。</p><p><a href="https://oi-wiki.org/math/binary-exponentiation/">OI-WIKI-快速幂</a>　　<a href="https://oi-wiki.org/math/linear-algebra/matrix/#%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95">OI-WIKI-矩阵乘法</a>　　<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247488198&idx=1&sn=8272ca6b0ef6530413da4a270abb68bc&chksm=fd9cb9d9caeb30cf6c2defab0f5204adc158969d64418916e306f6bf50ae0c38518d4e4ba146&token=1067450240&lang=zh_CN#rd">宫水三叶-矩阵快速幂</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1E9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">long</span>[][] matrix = &#123;<br>                &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>                &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;<br>        &#125;;<br>        <span class="hljs-type">long</span>[][] ans = &#123;<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br>        &#125;; <span class="hljs-comment">// 矩阵中的1，对角线为1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((k &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>                ans = mul(matrix, ans); <span class="hljs-comment">// 快速幂，将对应二进制位为 1 时的整系数幂乘起来</span><br>            &#125;<br>            matrix = mul(matrix, matrix);<br>            k &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(ans[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] % MOD); <span class="hljs-comment">// 实际上为 ans[0][0] * f(1) + ans[0][1] * f(0)</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span>[][] mul(<span class="hljs-type">long</span>[][] matrix1, <span class="hljs-type">long</span>[][] matrix2) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix1.length;<br>        <span class="hljs-type">long</span>[][] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                ret[i][j] = (((matrix1[i][<span class="hljs-number">0</span>] * matrix2[<span class="hljs-number">0</span>][j]) % MOD) + ((matrix1[i][<span class="hljs-number">1</span>] * matrix2[<span class="hljs-number">1</span>][j]) % MOD)) % MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>矩阵快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-464.我能赢吗</title>
    <link href="/2022/11/03/LC-464-%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97/"/>
    <url>/2022/11/03/LC-464-%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.cn/problems/can-i-win/submissions/">leetcode 中等题</a></p><p>两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过  100 的玩家，即为胜者。</p><p>两位玩家不能使用重复的整数 </p><p>给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家是否能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。</p><p>示例 1:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：maxChoosableInteger = 10, desiredTotal = 11<br>输出：false<br>解释：<br>无论第一个玩家选择哪个整数，他都会失败。<br>第一个玩家可以选择从<span class="hljs-number"> 1 </span>到<span class="hljs-number"> 10 </span>的整数。<br>如果第一个玩家选择 1，那么第二个玩家只能选择从<span class="hljs-number"> 2 </span>到<span class="hljs-number"> 10 </span>的整数。<br>第二个玩家可以通过选择整数 10（那么累积和为<span class="hljs-number"> 11 </span>&gt;= desiredTotal），从而取得胜利.<br>同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">maxChoosableInteger</span> = <span class="hljs-number">10</span>, <span class="hljs-attr">desiredTotal</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">maxChoosableInteger</span> = <span class="hljs-number">10</span>, <span class="hljs-attr">desiredTotal</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= maxChoosableInteger &lt;= <span class="hljs-number">20</span><br><span class="hljs-symbol">0 </span>&lt;= desiredTotal &lt;= <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><h2 id="递归-TLE"><a href="#递归-TLE" class="headerlink" title="递归 (TLE)"></a>递归 (TLE)</h2><p>最无脑的做法是直接递归, 用一个 <code>List</code> 来模拟选数的情况，每次选走一个数时 <code>remove</code> 掉对应元素即可，但同时因为要找到最优决策，所以不能改变原集合，只能改变拷贝的 <code>List</code>（如果直接对原集合 <code>remove</code> ，递归结束后不好还原，重新 <code>add</code> 会添加到集合末尾，那整个 for 循环遍历集合就不正确了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canIWin</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> dest)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(IntStream.rangeClosed(<span class="hljs-number">1</span>, n).boxed().collect(Collectors.toList()), dest);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; list, <span class="hljs-type">int</span> dest)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-keyword">if</span>(item &gt;= dest)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            List&lt;Integer&gt; copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list);<br>            copy.remove(i);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> dfs(copy, dest - item);<br>            <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="状态压缩-记忆化搜索"><a href="#状态压缩-记忆化搜索" class="headerlink" title="状态压缩 + 记忆化搜索"></a>状态压缩 + 记忆化搜索</h2><p>上面方案有问题的地方在于直接使用了 <code>List</code> 模拟选数过程，而整个递归过程是存在很多重复计算的，使用 <code>List</code> 无法进行记忆化搜索。</p><p>所以容易发现从一开始使用 <code>List</code> 就是一个 <strong>错误的思路</strong> 。</p><p>由于 n 数据范围为 20，且每个数只能被选择一次，所以我们可以 <strong>用一个 int (32位)</strong> 来表示选数的情况（<code>状态压缩</code>），对应二进制为 1 代表已被选择，否则代表未被选择。这种方案的好处在于很容易就能实现 <code>记忆化搜索</code>，不管是用 <code>int[1 &lt;&lt; 20]</code> 又或者是 <code>Map&lt;Integer, Integer&gt;</code> 。</p><p>整体实现的逻辑还是和上面的版本一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>]; <span class="hljs-comment">// int 的第 n 位为 1 代表 n - 1 被选择</span><br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canIWin</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> dest)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt; dest) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 依题意平手算先出手的玩家输</span><br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, dest) == <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> state, <span class="hljs-type">int</span> dest)</span>&#123;<br>        <span class="hljs-keyword">if</span>(cache[state] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> cache[state];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(((state &gt;&gt; (i - <span class="hljs-number">1</span>)) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">// 玩家不能重复使用整数</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i &gt;= dest)&#123;<br>                <span class="hljs-keyword">return</span> cache[state] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dfs((state | (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>))), dest - i) == -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> cache[state] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cache[state] = -<span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串哈希</title>
    <link href="/2022/11/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <url>/2022/11/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<br><a href="https://oi-wiki.org/string/hash/">OI-WIKI-# 字符串哈希</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247489813&idx=1&sn=7f3bc18ca390d85b17655f7164d8e660">宫水三叶-# 字符串哈希入门</a><br><a href="https://leetcode.cn/problems/repeated-dna-sequences/">Leetcode-187重复的 DNA 序列</a></p></blockquote><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>具体来说，哈希函数最重要的性质可以概括为下面两条：</p><ol><li><p>在 Hash 函数值不一样的时候，两个字符串一定不一样；</p></li><li><p>在 Hash 函数值一样的时候，两个字符串不一定一样（哈希冲突&#x2F;碰撞。但大概率一样，且我们当然希望它们总是一样的）。</p></li></ol><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>我们需要关注的是什么？</p><p>时间复杂度和 Hash 的准确率。</p><p>通常我们采用的是<strong>多项式 Hash</strong>的方法，对于一个长度为 L 的字符串 s 来说，我们可以这样定义多项式 Hash 函数：</p><p><img src="/img/20221001012815.png"></p><p>这种情况下，对于字符串 xyz ，其哈希函数值为 xb^2 + yb + z。</p><p>对于该 Hash 函数的参考实现如下(（效率低下的版本，实际使用时一般不会这么写）)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">233</span>; <br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll; <br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_hash</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span> </span>&#123; <br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123; <br>res = (ll)(res * B + s[i]) % M; <br>&#125; <br><span class="hljs-keyword">return</span> res; <br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">const</span> string&amp; t)</span> </span>&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">get_hash</span>(s) == <span class="hljs-built_in">get_hash</span>(t); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多次询问子串哈希"><a href="#多次询问子串哈希" class="headerlink" title="多次询问子串哈希"></a>多次询问子串哈希</h2><p>单次计算一个字符串的哈希值复杂度是 O(n)，其中 n 为串长，与暴力匹配没有区别，如果需要多次询问一个字符串的子串的哈希值，每次重新计算效率会非常低下。</p><p>一般采取的方法是对整个字符串先 <strong>预处理出每个前缀的哈希值(设该数组为H)</strong> ，将哈希值看成一个 b 进制的数对 m 取模的结果，这样的话可以做到快速求出子串的哈希。</p><p>首先对于F(s[1, i]) ，即原串长度为 i 的前缀（即子串s[1, i]）的哈希值 <strong>(即H[i])</strong> ，按照定义为</p><p><strong>F(s[1, i])  &#x3D; s[1] * b^ (i - 1) + s[2] * b ^ (i - 2) + … + s[i - 1] * b +s[i]</strong> </p><p>现在，我们想要用类似前缀和的方式快速求出子串 s[L, R] 的哈希值即 F(s[L, R])，按照定义哈希值为</p><p><strong>F(s[L, R])  &#x3D; s[L] * b^ (R - L) + s[L + 1] * b ^ (R - L - 1) + … + s[R - 1] * b +s[R]</strong></p><p>对比观察上述两个式子，可以发现 <code>式2</code> 其实可以由 <code>式1</code> 得出，即<br><strong>F(s[L, R])  &#x3D; F(s[1, R]) - F(s[1, L-1]) * b ^ (r - L + 1)</strong> </p><p>那么即字串 S[L, R] 的哈希值等于 H[R] - H[L-1] * B ^ (R - L +1)</p><p>而 B ^ (r - L + 1)  又可以通过 O(n) 的预处理出次方数组，以实现 O(1) 的回答每次询问</p><p>实现，<a href="https://leetcode.cn/problems/repeated-dna-sequences/">Leetcode187</a>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-number">131313</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] POWER = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M]; <span class="hljs-comment">// 次方数组  </span><br>  <br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findRepeatedDnaSequences</span><span class="hljs-params">(String s)</span> &#123;  <br>        <span class="hljs-type">int</span>[] hashTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length() + <span class="hljs-number">1</span>];  <br>        POWER[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++)&#123;  <br>            <span class="hljs-comment">// 预处理前缀哈希数组  </span><br>            hashTable[i] = hashTable[i - <span class="hljs-number">1</span>] * B + s.charAt(i - <span class="hljs-number">1</span>) % M;  <br>            <span class="hljs-comment">// 预处理次方数组</span><br>            POWER[i] = POWER[i - <span class="hljs-number">1</span>] * B;  <br>        &#125;  <br>        Map&lt;Integer, Integer&gt; countMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length() - <span class="hljs-number">10</span> + <span class="hljs-number">1</span>; i++)&#123;  <br>            <span class="hljs-comment">// 子串哈希等于 h(r) - h(l - 1) * b ^ (r - l + 1)            </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hashTable[i + <span class="hljs-number">9</span> + <span class="hljs-number">1</span>] - hashTable[i] * POWER[i + <span class="hljs-number">9</span> - i + <span class="hljs-number">1</span>];  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> countMap.merge(hash, <span class="hljs-number">0</span>, (oldValue, __) -&gt; ++oldValue);  <br>            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">1</span>)&#123;  <br>                ans.add(s.substring(i, i + <span class="hljs-number">10</span>));  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> ans;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collector-and-Stream.reduce()</title>
    <link href="/2022/11/03/Collector-and-Stream.reduce()/"/>
    <url>/2022/11/03/Collector-and-Stream.reduce()/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://leetcode.cn/problems/reformat-phone-number/">删除字符串中的破折号和空字符</a></p><blockquote><p>当然，最简洁的方式是<br>        String s &#x3D; number.replace(“ “, “”).replace(“-“, “”);<br>但这里暂时忽略这种方案，只是为了指出该背景</p></blockquote><p>一种较复杂的方案是使用 Stream，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">justCase</span><span class="hljs-params">(String str)</span>&#123;  <br>    <span class="hljs-keyword">return</span> str.chars()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>)<br>            .collect(Collector.of(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    (__, ___) -&gt; &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;un support parallel stream&quot;</span>);&#125;,<br>                    StringBuilder::toString));  <br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，要将字符数组重新收集成 <code>String</code> 的合理做法应该只有使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">.collect(supplier,  accumulator,  combiner);<br><span class="hljs-comment">// or</span><br>.collect(Collector.of());  <br></code></pre></td></tr></table></figure><p>其余做法例如 <code>mapToObj(String::valueOf).collect(joining)</code> 会频繁创建 String；<br>而 <code>reduce</code> 严格来讲既不是<strong>可变规约</strong>也没有简洁多少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">justCase</span><span class="hljs-params">(String str)</span>&#123;  <br>    <span class="hljs-keyword">return</span>  str.chars().parallel()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>)  <br>            .reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(),  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString();  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实例化-CollectorImpl"><a href="#实例化-CollectorImpl" class="headerlink" title="实例化 CollectorImpl"></a>实例化 CollectorImpl</h2><blockquote><p>这里只对 <code>Collector</code> 做该话题下的简单介绍，详细知识见 javadocs</p></blockquote><p>Collector 接口由四个抽象函数指定，这些函数协同工作以将条目累积到可变结果容器中，并可选择对结果执行最终转换。他们是：</p><ul><li>supplier() ：创建一个新的结果容器</li><li>accumulator() ：将新数据元素合并到结果容器中</li><li>combiner()：将两个结果容器合并为一个（  ）</li><li>finisher() ：对容器执行可选的最终转换</li></ul><p><code>Collector</code> 接口在 JDK 中的实现类位于 <code>Collectors.CollectorImpl</code><br>而实例化  <code>CollectorImpl</code> 有两种途径：</p><ul><li>通过 <code>Collectors</code> 类预定义的例如 <code>Collectors.toList()</code> 等静态工厂方法实例化</li><li>通过 <code>Collector</code> 接口中暴露出的两种 <code>Collector.of</code> 方法实例化：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collector</span>&lt;T, A, R&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T, R&gt; Collector&lt;T, R, R&gt; <span class="hljs-title function_">of</span><br><br><span class="hljs-params">(Supplier&lt;R&gt; supplier,  </span><br><span class="hljs-params">                                          BiConsumer&lt;R, T&gt; accumulator,  </span><br><span class="hljs-params">                                          BinaryOperator&lt;R&gt; combiner,  </span><br><span class="hljs-params">                                          Characteristics... characteristics)</span> <br>                                          <br>                                          &#123;...&#125;<br>                                          <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T, A, R&gt; Collector&lt;T, A, R&gt; <span class="hljs-title function_">of</span><br>    <br><span class="hljs-params">(Supplier&lt;A&gt; supplier,  </span><br><span class="hljs-params">                                             BiConsumer&lt;A, T&gt; accumulator,  </span><br><span class="hljs-params">                                             BinaryOperator&lt;A&gt; combiner,  </span><br><span class="hljs-params">                                             Function&lt;A, R&gt; finisher,  </span><br><span class="hljs-params">                                             Characteristics... characteristics)</span><br><br>                                             &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>可以看到，<code>Collector</code> 接口只提供了两种重载用于实例化 <code>CollectorImpl</code><br>并且这两种重载都必须传入 <code>supplier</code> 、<code>accmulator</code> 以及 <code>combiner</code>，前两个参数很好理解，毕竟 <code>CollectorImpl</code> 不好对此提供默认的实现<br>但是对于组合器  <code>combiner</code>，<strong>由于组合器只有在执行并发规约时会使用到</strong>，也就是说，对于上面场景下的收集器（即不考虑使用并发流的场景），提供一个 <code>combiner</code> 并没有实际意义</p><h2 id="为什么必须提供-combiner"><a href="#为什么必须提供-combiner" class="headerlink" title="为什么必须提供 combiner"></a>为什么必须提供 combiner</h2><p>在<a href="https://stackoverflow.com/questions/24308146/why-is-a-combiner-needed-for-reduce-method-that-converts-type-in-java-8/24316429#24316429">该问题中</a>，发现这种操作在 <code>Scala</code> 中被称为<code>foldLeft</code>。需要注意的是，Java 的库函数中并没有提供等效于 <code>foldLeft</code> 的实现。</p><blockquote><p>在上面的回答中提到：<br>Finally, Java doesn’t provide <code>foldLeft</code> and <code>foldRight</code> operations because they imply a particular ordering of operations that is inherently sequential. This clashes with the design principle stated above of providing APIs that support sequential and parallel operation equally.<br>最后，Java 不提供<code>foldLeft</code>and<code>foldRight</code>操作，因为它们暗示了一种特定的操作顺序，这种顺序本质上是顺序的。这与上述提供同样支持顺序和并行操作的 API 的设计原则相冲突。</p></blockquote><p>虽然该说法有一定说服力，但还是继续搜索了为什么 Java 没有提供 <code>foldLeft</code>，试图继续理解所提到的<code>设计原则</code>。<br>但是结果却找到了<a href="https://bugs.openjdk.org/browse/JDK-8292845">JDK-8292845</a>和<a href="https://bugs.openjdk.org/browse/JDK-8292845">JDK-8292845</a>，但在这两个增强请求中，却没有对相关<code>设计原则</code>进行讨论，而是计划会在将来对此进行实现。</p><p>也许在不久的将来，就会有一种更合理的 folding operations 可以替换上方看似不合理的实现</p><h2 id="reduce-vs-collect"><a href="#reduce-vs-collect" class="headerlink" title="reduce vs collect"></a>reduce vs collect</h2><p>先看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">justCase</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a-b&quot;</span>;  s<br>    Function&lt;String, Stream&lt;Character&gt;&gt; function = str -&gt; str.chars()  <br>            .parallel()  <br>            .mapToObj(__ -&gt; (<span class="hljs-type">char</span>) __)  <br>            .filter(c -&gt; c != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span>);  <br>  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(),  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString(); <span class="hljs-comment">// baba  </span><br>  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .collect(Collector.of(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    StringBuilder::append,  <br>                    StringBuilder::toString)); <span class="hljs-comment">// ab</span><br>                    <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> function.apply(number)  <br>            .collect(  <br>                    StringBuilder::<span class="hljs-keyword">new</span>,  <br>                    StringBuilder::append,  <br>                    StringBuilder::append).toString(); <span class="hljs-comment">// ab</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现在 <code>parallel stream</code> 下 <code>reduce()</code> 的输出并不符合我们的预期，先查看 <code>reduce()</code> 的方法注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java">...<br> identity值必须是组合器函数的标识。这意味着对于所有u ，<br>     combiner(identity , u) == u<br> 此外， combiner函数必须与accumulator函数兼容；对于所有u和t ，必须满足以下条件：<br>     combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)<br>...<br><br>&lt;U&gt; U <span class="hljs-title function_">reduce</span><span class="hljs-params">(U identity,  BiFunction&lt;U, ? <span class="hljs-built_in">super</span> T, U&gt; accumulator,  BinaryOperator&lt;U&gt; combiner)</span>;<br></code></pre></td></tr></table></figure><p>对这里的约定进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">justCase</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// combiner(identity , u) == u  </span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">identity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(<span class="hljs-string">&#x27;b&#x27;</span>);  <br>BinaryOperator&lt;StringBuilder&gt; combiner = StringBuilder::append;  <br><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply0</span> <span class="hljs-operator">=</span> combiner.apply(identity, u);  <br>log.debug(String.valueOf(apply0.toString().equals(u.toString()))); <span class="hljs-comment">// true  </span><br><br><br><span class="hljs-comment">// combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)  </span><br><span class="hljs-type">Object</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;  <br>BiFunction&lt;StringBuilder, Object, StringBuilder&gt; acc = StringBuilder::append;  <br>  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply1</span> <span class="hljs-operator">=</span> acc.apply(identity, t);  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply2</span> <span class="hljs-operator">=</span> combiner.apply(u, apply1);  <br>  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">apply3</span> <span class="hljs-operator">=</span> acc.apply(u, t);  <br><br>log.debug(String.valueOf(apply2.toString().equals(apply3.toString()))); <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现我们的用例其实是符合 <code>reduce()</code> 方法在 javadocs 中的约定的，于是继续查看相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 使用提供的标识、累积和组合函数对该流的元素执行 归约 </span><br>reduce(U identity, BiFunction&lt;U,? <span class="hljs-built_in">super</span> T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)<br><br><span class="hljs-comment">// 对此流的元素执行 可变归约 操作</span><br>collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? <span class="hljs-built_in">super</span> T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)<br></code></pre></td></tr></table></figure><p>会发现这其实是因为 <code>reduce()</code> 只是 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#ReductionOperations">Reduction operations</a> 导致的（而 <code>StringBuilder</code> 是可变对象），在该场景下应该使用  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#MutableReduction">Mutable reduction(可变规约)</a> ，也就是 <code>collect()</code></p><p>实际上仔细查看代码会发现 <code>reduce</code> 和 <code>collect</code> 的累加器 <code>accumulator</code> 定义也并不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// Reduction operations 在累加器中返回处理结果，处理结果的类型不能是可变的</span><br>reduce(... BiFunction&lt;U, ? <span class="hljs-built_in">super</span> T, U&gt; accumulator...)<br><span class="hljs-comment">// Mutable reduction(可变规约) 在累加器中不返回处理结果而是通过修改可变容器本身</span><br>collect(...BiConsumer&lt;R, ? <span class="hljs-built_in">super</span> T&gt; accumulator...) <br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html#MutableReduction">Mutable reduction(可变规约)</a></p><p><a href="https://stackoverflow.com/questions/56023452/how-does-reduce-method-work-with-parallel-streams-in-java-8">how-does-reduce-method-work-with-parallel-streams-in-java-8</a></p><blockquote><p>The problem lies in you using Stream::reduce for mutable reduction.<br>You should instead use Stream::collect</p></blockquote><p><a href="https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce/38728166#38728166">java-8-streams-collect-vs-reduce</a></p><blockquote><p>The reason is simply that:</p><ul><li>collect() can only work with mutable result objects.</li><li>reduce() is designed to work with immutable result objects.</li></ul></blockquote><p><a href="https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce/22577274#22577274">java-8-streams-collect-vs-reduce</a></p><blockquote><p>reduce是一个“折叠”操作，它将二元运算符应用于流中的每个元素，其中运算符的第一个参数是前一个应用程序的返回值，第二个参数是当前流元素。<br>collect是一种聚合操作，其中创建“集合”并将每个元素“添加”到该集合中。然后将流中不同部分的集合添加到一起。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
